{"ast":null,"code":"var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (obj = {}, obj[\"immer-nothing\"] = true, obj);\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n}\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) invokeGetters = false;\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n      value = desc.get.call(base);\n    }\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      cb(i, value[i], value);\n    }\n  } else {\n    ownKeys(value).forEach(function (key) {\n      return cb(key, value[key], value);\n    });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction clone(obj) {\n  if (!isDraftable(obj)) {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n  for (var key in obj) {\n    cloned[key] = clone(obj[key]);\n  }\n  return cloned;\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\nImmerScope.prototype.usePatches = function usePatches(patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\nImmerScope.prototype.revoke = function revoke$1() {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\nImmerScope.prototype.leave = function leave() {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\n// but share them all instead\n\nvar descriptors = {};\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n    markChangesSweep(scope.drafts);\n  }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\nfunction revoke$1() {\n  this.revoked = true;\n}\nfunction source(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n  return draft[prop];\n}\nfunction get(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(source(state), prop);\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n  return value;\n}\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n  if (!state.modified) {\n    if (is(value, peek(source(state), prop))) {\n      return;\n    }\n    markChanged(state);\n    prepareCopy(state);\n  }\n  state.copy[prop] = value;\n}\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n  return shallowCopy(base);\n}\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function get$1() {\n        return get(this[DRAFT_STATE], prop);\n      },\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n  Object.defineProperty(draft, prop, desc);\n}\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(source(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n        }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n  var state = object[DRAFT_STATE];\n  if (!state) {\n    return;\n  }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) {\n        assigned[i$1] = true;\n      }\n    }\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) {\n        markChangesRecursively(draft[i$2]);\n      }\n    }\n  }\n}\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n      var value = draft[key];\n      var state$1 = value && value[DRAFT_STATE];\n      if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n        return true;\n      }\n    }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n  return keys.length !== Object.keys(base).length;\n}\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n  willFinalize: willFinalize,\n  createProxy: createProxy\n});\nfunction willFinalize$1() {}\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var ref = Array.isArray(base) ?\n  // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n  // although state itself is an object\n  Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\nvar objectTraps = {\n  get: get$1,\n  has: function has(target, prop) {\n    return prop in source$1(target);\n  },\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.base);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // returns the object we should be reading the current value from, which is base, until some change has been made\n\nfunction source$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);\n  return desc && desc.value;\n}\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) {\n    return state;\n  }\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n  var value = source$1(state)[prop];\n  if (state.finalized || !isDraftable(value)) {\n    return value;\n  } // Check for existing draft in modified state.\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== peek$1(state.base, prop)) {\n      return value;\n    } // Store drafts on the copy (when one exists).\n\n    drafts = state.copy;\n  }\n  return drafts[prop] = createProxy$1(value, state);\n}\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n\n    var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n    if (isUnchanged) {\n      return true;\n    }\n    markChanged$1(state);\n  }\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  } else if (state.assigned[prop]) {\n    // if an originally not assigned property was deleted\n    delete state.assigned[prop];\n  }\n  if (state.copy) {\n    delete state.copy[prop];\n  }\n  return true;\n} // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = source$1(state);\n  var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n  if (desc) {\n    desc.writable = true;\n    desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n  }\n  return desc;\n}\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n    if (state.parent) {\n      markChanged$1(state.parent);\n    }\n  }\n}\nvar modernProxy = /*#__PURE__*/Object.freeze({\n  willFinalize: willFinalize$1,\n  createProxy: createProxy$1\n});\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    assign = [copy, base], base = assign[0], copy = assign[1];\n    assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1];\n  }\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n  var end = base.length;\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n}\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n    var path = patch.path;\n    var op = patch.op;\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    if (!path.length) {\n      throw new Error(\"Illegal state\");\n    }\n    var base = draft;\n    for (var i = 0; i < path.length - 1; i++) {\n      base = base[path[i]];\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n    }\n    var key = path[path.length - 1];\n    switch (op) {\n      case \"replace\":\n        // if value is an object, then it's assigned by reference\n        // in the following add or remove ops, the value field inside the patch will also be modifyed\n        // so we use value from the cloned patch\n        base[key] = value;\n        break;\n      case \"add\":\n        if (Array.isArray(base)) {\n          // TODO: support \"foo/-\" paths for appending to an array\n          base.splice(key, 0, value);\n        } else {\n          base[key] = value;\n        }\n        break;\n      case \"remove\":\n        if (Array.isArray(base)) {\n          base.splice(key, 1);\n        } else {\n          delete base[key];\n        }\n        break;\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n  return draft;\n};\nfunction verifyMinified() {}\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n};\nImmer.prototype.produce = function produce(base, recipe, patchListener) {\n  var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n      var this$1 = this;\n      if (base === void 0) base = defaultBase;\n      var args = [],\n        len = arguments.length - 1;\n      while (len-- > 0) args[len] = arguments[len + 1];\n      return self.produce(base, function (draft) {\n        return recipe.call.apply(recipe, [this$1, draft].concat(args));\n      }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) {\n        scope.revoke();\n      } else {\n        scope.leave();\n      }\n    }\n    if (result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === undefined) {\n      return base;\n    }\n    return result !== NOTHING ? result : undefined;\n  }\n};\nImmer.prototype.produceWithPatches = function produceWithPatches(arg1, arg2, arg3) {\n  var this$1 = this;\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n      var args = [],\n        len = arguments.length - 1;\n      while (len-- > 0) args[len] = arguments[len + 1];\n      return this$1.produceWithPatches(state, function (draft) {\n        return arg1.apply(void 0, [draft].concat(args));\n      });\n    };\n  } // non-curried form\n\n  if (arg3) {\n    throw new Error(\"A patch listener cannot be passed to produceWithPatches\");\n  }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\nImmer.prototype.createDraft = function createDraft(base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\nImmer.prototype.finishDraft = function finishDraft(draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\nImmer.prototype.setAutoFreeze = function setAutoFreeze(value) {\n  this.autoFreeze = value;\n};\nImmer.prototype.setUseProxies = function setUseProxies(value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\nImmer.prototype.applyPatches = function applyPatches$1(base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n  return this.produce(base, function (draft) {\n    return applyPatches(draft, patches.slice(i + 1));\n  });\n};\n/** @internal */\n\nImmer.prototype.processResult = function processResult(result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n    }\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n  scope.revoke();\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\nImmer.prototype.finalize = function finalize(draft, path, scope) {\n  var this$1 = this;\n  var state = draft[DRAFT_STATE];\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n  if (!state.modified) {\n    return state.base;\n  }\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope);\n    if (this.onDelete) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        for (var prop in assigned) {\n          if (!assigned[prop]) {\n            this.onDelete(state, prop);\n          }\n        }\n      } else {\n        var base = state.base;\n        var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      }\n    }\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      Object.freeze(state.copy);\n    }\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\nImmer.prototype.finalizeTree = function finalizeTree(root, rootPath, scope) {\n  var this$1 = this;\n  var state = root[DRAFT_STATE];\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n    root = state.copy;\n  }\n  var needPatches = !!rootPath && !!scope.patches;\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n    var isDraftProp = !!state && parent === root;\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Preserve non-enumerable properties.\n\n      if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n        parent[prop] = value;\n      } else {\n        Object.defineProperty(parent, prop, {\n          value: value\n        });\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n      if (isDraftProp && value === state.base[prop]) {\n        return;\n      }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, state.base[prop])) {\n      return;\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    else if (isDraftable(value) && !Object.isFrozen(value)) {\n      each(value, finalizeProperty);\n    }\n    if (isDraftProp && this$1.onAssign) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n  each(root, finalizeProperty);\n  return root;\n};\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","map":{"version":3,"names":["NOTHING","Symbol","obj","DRAFTABLE","for","DRAFT_STATE","isDraft","value","isDraftable","isPlainObject","constructor","Array","isArray","proto","Object","getPrototypeOf","prototype","original","base","assign","target","key","has","ownKeys","Reflect","getOwnPropertySymbols","getOwnPropertyNames","concat","shallowCopy","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","map","cloned","ImmerScope","parent","drafts","canAutoFreeze","patches","usePatches","patchListener","inversePatches","revoke","revoke$1","leave","current","enter","draft","descriptors","willFinalize","scope","result","isReplaced","finalizing","markChangesRecursively","markChangesSweep","createProxy","clonePotentialDraft","proxyProperty","state","modified","finalized","assigned","copy","revoked","createHiddenProperty","push","source","peek","assertUnrevoked","prepareCopy","set","markChanged","get$1","set$1","JSON","stringify","hasArrayChanges","hasObjectChanges","object","keys","undefined","i$1","i$2","baseValue","state$1","descriptor","willFinalize$1","createProxy$1","Proxy","revocable","arrayTraps","objectTraps","ref","proxy","source$1","deleteProperty","setPrototypeOf","fn","arguments","apply","isNaN","parseInt","peek$1","isUnchanged","markChanged$1","owner","generatePatches","basePath","generateArrayPatches","generateObjectPatches","assign$1","delta","start","end","path","op","replaceCount","path$1","assignedValue","origValue","applyPatches","list","patch","join","splice","verifyMinified","configDefaults","useProxies","autoFreeze","process","env","NODE_ENV","name","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","recipe","defaultBase","self","curriedProduce","this$1","args","hasError","Promise","then","processResult","error","produceWithPatches","arg1","arg2","arg3","nextState","p","ip","createDraft","isManual","finishDraft","setAutoFreeze","modernProxy","legacyProxy","applyPatches$1","baseDraft","finalize","isFrozen","finalizeTree","freeze","root","rootPath","needPatches","finalizeProperty","isDraftProp","immer"],"sources":["/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/node_modules/immer/src/common.js","/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/node_modules/immer/src/scope.js","/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/node_modules/immer/src/es5.js","/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/node_modules/immer/src/proxy.js","/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/node_modules/immer/src/patches.js","/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/node_modules/immer/src/immer.js","/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/node_modules/immer/src/index.js"],"sourcesContent":["export const NOTHING =\n\ttypeof Symbol !== \"undefined\"\n\t\t? Symbol(\"immer-nothing\")\n\t\t: {[\"immer-nothing\"]: true}\n\nexport const DRAFTABLE =\n\ttypeof Symbol !== \"undefined\" && Symbol.for\n\t\t? Symbol.for(\"immer-draftable\")\n\t\t: \"__$immer_draftable\"\n\nexport const DRAFT_STATE =\n\ttypeof Symbol !== \"undefined\" && Symbol.for\n\t\t? Symbol.for(\"immer-state\")\n\t\t: \"__$immer_state\"\n\nexport function isDraft(value) {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\nexport function isDraftable(value) {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\n\t)\n}\n\nexport function isPlainObject(value) {\n\tif (!value || typeof value !== \"object\") return false\n\tif (Array.isArray(value)) return true\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\nexport function original(value) {\n\tif (value && value[DRAFT_STATE]) {\n\t\treturn value[DRAFT_STATE].base\n\t}\n\t// otherwise return undefined\n}\n\nexport const assign =\n\tObject.assign ||\n\tfunction assign(target, value) {\n\t\tfor (let key in value) {\n\t\t\tif (has(value, key)) {\n\t\t\t\ttarget[key] = value[key]\n\t\t\t}\n\t\t}\n\t\treturn target\n\t}\n\nexport const ownKeys =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj)\n\t\t\t\t)\n\t\t: Object.getOwnPropertyNames\n\nexport function shallowCopy(base, invokeGetters = false) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst clone = Object.create(Object.getPrototypeOf(base))\n\townKeys(base).forEach(key => {\n\t\tif (key === DRAFT_STATE) {\n\t\t\treturn // Never copy over draft state.\n\t\t}\n\t\tconst desc = Object.getOwnPropertyDescriptor(base, key)\n\t\tlet {value} = desc\n\t\tif (desc.get) {\n\t\t\tif (!invokeGetters) {\n\t\t\t\tthrow new Error(\"Immer drafts cannot have computed properties\")\n\t\t\t}\n\t\t\tvalue = desc.get.call(base)\n\t\t}\n\t\tif (desc.enumerable) {\n\t\t\tclone[key] = value\n\t\t} else {\n\t\t\tObject.defineProperty(clone, key, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\t\t}\n\t})\n\treturn clone\n}\n\nexport function each(value, cb) {\n\tif (Array.isArray(value)) {\n\t\tfor (let i = 0; i < value.length; i++) cb(i, value[i], value)\n\t} else {\n\t\townKeys(value).forEach(key => cb(key, value[key], value))\n\t}\n}\n\nexport function isEnumerable(base, prop) {\n\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\n\treturn !!desc && desc.enumerable\n}\n\nexport function has(thing, prop) {\n\treturn Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function is(x, y) {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport function clone(obj) {\n\tif (!isDraftable(obj)) return obj\n\tif (Array.isArray(obj)) return obj.map(clone)\n\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\tfor (const key in obj) cloned[key] = clone(obj[key])\n\treturn cloned\n}\n","import {DRAFT_STATE} from \"./common\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n\tconstructor(parent) {\n\t\tthis.drafts = []\n\t\tthis.parent = parent\n\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tthis.canAutoFreeze = true\n\n\t\t// To avoid prototype lookups:\n\t\tthis.patches = null\n\t}\n\tusePatches(patchListener) {\n\t\tif (patchListener) {\n\t\t\tthis.patches = []\n\t\t\tthis.inversePatches = []\n\t\t\tthis.patchListener = patchListener\n\t\t}\n\t}\n\trevoke() {\n\t\tthis.leave()\n\t\tthis.drafts.forEach(revoke)\n\t\tthis.drafts = null // Make draft-related methods throw.\n\t}\n\tleave() {\n\t\tif (this === ImmerScope.current) {\n\t\t\tImmerScope.current = this.parent\n\t\t}\n\t}\n}\n\nImmerScope.current = null\nImmerScope.enter = function() {\n\treturn (this.current = new ImmerScope(this.current))\n}\n\nfunction revoke(draft) {\n\tdraft[DRAFT_STATE].revoke()\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraft,\n\tisDraftable,\n\tisEnumerable,\n\tshallowCopy,\n\tDRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors = {}\n\nexport function willFinalize(scope, result, isReplaced) {\n\tscope.drafts.forEach(draft => {\n\t\tdraft[DRAFT_STATE].finalizing = true\n\t})\n\tif (!isReplaced) {\n\t\tif (scope.patches) {\n\t\t\tmarkChangesRecursively(scope.drafts[0])\n\t\t}\n\t\t// This is faster when we don't care about which attributes changed.\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n\t// When a child draft is returned, look for changes.\n\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n}\n\nexport function createProxy(base, parent) {\n\tconst isArray = Array.isArray(base)\n\tconst draft = clonePotentialDraft(base)\n\teach(draft, prop => {\n\t\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n\t})\n\n\t// See \"proxy.js\" for property documentation.\n\tconst scope = parent ? parent.scope : ImmerScope.current\n\tconst state = {\n\t\tscope,\n\t\tmodified: false,\n\t\tfinalizing: false, // es5 only\n\t\tfinalized: false,\n\t\tassigned: {},\n\t\tparent,\n\t\tbase,\n\t\tdraft,\n\t\tcopy: null,\n\t\trevoke,\n\t\trevoked: false // es5 only\n\t}\n\n\tcreateHiddenProperty(draft, DRAFT_STATE, state)\n\tscope.drafts.push(draft)\n\treturn draft\n}\n\nfunction revoke() {\n\tthis.revoked = true\n}\n\nfunction source(state) {\n\treturn state.copy || state.base\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft, prop) {\n\tconst state = draft[DRAFT_STATE]\n\tif (state && !state.finalizing) {\n\t\tstate.finalizing = true\n\t\tconst value = draft[prop]\n\t\tstate.finalizing = false\n\t\treturn value\n\t}\n\treturn draft[prop]\n}\n\nfunction get(state, prop) {\n\tassertUnrevoked(state)\n\tconst value = peek(source(state), prop)\n\tif (state.finalizing) return value\n\t// Create a draft if the value is unmodified.\n\tif (value === peek(state.base, prop) && isDraftable(value)) {\n\t\tprepareCopy(state)\n\t\treturn (state.copy[prop] = createProxy(value, state))\n\t}\n\treturn value\n}\n\nfunction set(state, prop, value) {\n\tassertUnrevoked(state)\n\tstate.assigned[prop] = true\n\tif (!state.modified) {\n\t\tif (is(value, peek(source(state), prop))) return\n\t\tmarkChanged(state)\n\t\tprepareCopy(state)\n\t}\n\tstate.copy[prop] = value\n}\n\nfunction markChanged(state) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (state.parent) markChanged(state.parent)\n\t}\n}\n\nfunction prepareCopy(state) {\n\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base) {\n\tconst state = base && base[DRAFT_STATE]\n\tif (state) {\n\t\tstate.finalizing = true\n\t\tconst draft = shallowCopy(state.draft, true)\n\t\tstate.finalizing = false\n\t\treturn draft\n\t}\n\treturn shallowCopy(base)\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n\tlet desc = descriptors[prop]\n\tif (desc) {\n\t\tdesc.enumerable = enumerable\n\t} else {\n\t\tdescriptors[prop] = desc = {\n\t\t\tconfigurable: true,\n\t\t\tenumerable,\n\t\t\tget() {\n\t\t\t\treturn get(this[DRAFT_STATE], prop)\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tset(this[DRAFT_STATE], prop, value)\n\t\t\t}\n\t\t}\n\t}\n\tObject.defineProperty(draft, prop, desc)\n}\n\nfunction assertUnrevoked(state) {\n\tif (state.revoked === true)\n\t\tthrow new Error(\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\tJSON.stringify(source(state))\n\t\t)\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts) {\n\t// The natural order of drafts in the `scope` array is based on when they\n\t// were accessed. By processing drafts in reverse natural order, we have a\n\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t// have changed, we can avoid any traversal of its ancestor nodes.\n\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\tconst state = drafts[i][DRAFT_STATE]\n\t\tif (!state.modified) {\n\t\t\tif (Array.isArray(state.base)) {\n\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t} else if (hasObjectChanges(state)) markChanged(state)\n\t\t}\n\t}\n}\n\nfunction markChangesRecursively(object) {\n\tif (!object || typeof object !== \"object\") return\n\tconst state = object[DRAFT_STATE]\n\tif (!state) return\n\tconst {base, draft, assigned} = state\n\tif (!Array.isArray(object)) {\n\t\t// Look for added keys.\n\t\tObject.keys(draft).forEach(key => {\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (base[key] === undefined && !has(base, key)) {\n\t\t\t\tassigned[key] = true\n\t\t\t\tmarkChanged(state)\n\t\t\t} else if (!assigned[key]) {\n\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\tmarkChangesRecursively(draft[key])\n\t\t\t}\n\t\t})\n\t\t// Look for removed keys.\n\t\tObject.keys(base).forEach(key => {\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (draft[key] === undefined && !has(draft, key)) {\n\t\t\t\tassigned[key] = false\n\t\t\t\tmarkChanged(state)\n\t\t\t}\n\t\t})\n\t} else if (hasArrayChanges(state)) {\n\t\tmarkChanged(state)\n\t\tassigned.length = true\n\t\tif (draft.length < base.length) {\n\t\t\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\n\t\t} else {\n\t\t\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\n\t\t}\n\t\tfor (let i = 0; i < draft.length; i++) {\n\t\t\t// Only untouched indices trigger recursion.\n\t\t\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\n\t\t}\n\t}\n}\n\nfunction hasObjectChanges(state) {\n\tconst {base, draft} = state\n\n\t// Search for added keys and changed keys. Start at the back, because\n\t// non-numeric keys are ordered by time of definition on the object.\n\tconst keys = Object.keys(draft)\n\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\tconst key = keys[i]\n\t\tconst baseValue = base[key]\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (baseValue === undefined && !has(base, key)) {\n\t\t\treturn true\n\t\t}\n\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t// descriptor is erased. This branch detects any missed changes.\n\t\telse {\n\t\t\tconst value = draft[key]\n\t\t\tconst state = value && value[DRAFT_STATE]\n\t\t\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// At this point, no keys were added or changed.\n\t// Compare key count to determine if keys were deleted.\n\treturn keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n\tconst {draft} = state\n\tif (draft.length !== state.base.length) return true\n\t// See #116\n\t// If we first shorten the length, our array interceptors will be removed.\n\t// If after that new items are added, result in the same original length,\n\t// those last items will have no intercepting property.\n\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t// the last one\n\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\tif (descriptor && !descriptor.get) return true\n\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\treturn false\n}\n\nfunction createHiddenProperty(target, prop, value) {\n\tObject.defineProperty(target, prop, {\n\t\tvalue: value,\n\t\tenumerable: false,\n\t\twritable: true\n\t})\n}\n","\"use strict\"\nimport {\n\tassign,\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tisDraft,\n\tshallowCopy,\n\tDRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// Do nothing before being finalized.\nexport function willFinalize() {}\n\nexport function createProxy(base, parent) {\n\tconst scope = parent ? parent.scope : ImmerScope.current\n\tconst state = {\n\t\t// Track which produce call this is associated with.\n\t\tscope,\n\t\t// True for both shallow and deep changes.\n\t\tmodified: false,\n\t\t// Used during finalization.\n\t\tfinalized: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned: {},\n\t\t// The parent draft state.\n\t\tparent,\n\t\t// The base state.\n\t\tbase,\n\t\t// The base proxy.\n\t\tdraft: null,\n\t\t// Any property proxies.\n\t\tdrafts: {},\n\t\t// The base copy with any updated values.\n\t\tcopy: null,\n\t\t// Called by the `produce` function.\n\t\trevoke: null\n\t}\n\n\tconst {revoke, proxy} = Array.isArray(base)\n\t\t? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n\t\t  // although state itself is an object\n\t\t  Proxy.revocable([state], arrayTraps)\n\t\t: Proxy.revocable(state, objectTraps)\n\n\tstate.draft = proxy\n\tstate.revoke = revoke\n\n\tscope.drafts.push(proxy)\n\treturn proxy\n}\n\nconst objectTraps = {\n\tget,\n\thas(target, prop) {\n\t\treturn prop in source(target)\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(source(target))\n\t},\n\tset,\n\tdeleteProperty,\n\tgetOwnPropertyDescriptor,\n\tdefineProperty() {\n\t\tthrow new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n\t},\n\tgetPrototypeOf(target) {\n\t\treturn Object.getPrototypeOf(target.base)\n\t},\n\tsetPrototypeOf() {\n\t\tthrow new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n\t}\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (isNaN(parseInt(prop))) {\n\t\tthrow new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n\t}\n\treturn objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (prop !== \"length\" && isNaN(parseInt(prop))) {\n\t\tthrow new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n\t}\n\treturn objectTraps.set.call(this, state[0], prop, value)\n}\n\n// returns the object we should be reading the current value from, which is base, until some change has been made\nfunction source(state) {\n\treturn state.copy || state.base\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft, prop) {\n\tconst state = draft[DRAFT_STATE]\n\tconst desc = Reflect.getOwnPropertyDescriptor(\n\t\tstate ? source(state) : draft,\n\t\tprop\n\t)\n\treturn desc && desc.value\n}\n\nfunction get(state, prop) {\n\tif (prop === DRAFT_STATE) return state\n\tlet {drafts} = state\n\n\t// Check for existing draft in unmodified state.\n\tif (!state.modified && has(drafts, prop)) {\n\t\treturn drafts[prop]\n\t}\n\n\tconst value = source(state)[prop]\n\tif (state.finalized || !isDraftable(value)) {\n\t\treturn value\n\t}\n\n\t// Check for existing draft in modified state.\n\tif (state.modified) {\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value !== peek(state.base, prop)) return value\n\t\t// Store drafts on the copy (when one exists).\n\t\tdrafts = state.copy\n\t}\n\n\treturn (drafts[prop] = createProxy(value, state))\n}\n\nfunction set(state, prop, value) {\n\tif (!state.modified) {\n\t\tconst baseValue = peek(state.base, prop)\n\t\t// Optimize based on value's truthiness. Truthy values are guaranteed to\n\t\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\n\t\t// values may be drafts, but falsy values are never drafts.\n\t\tconst isUnchanged = value\n\t\t\t? is(baseValue, value) || value === state.drafts[prop]\n\t\t\t: is(baseValue, value) && prop in state.base\n\t\tif (isUnchanged) return true\n\t\tmarkChanged(state)\n\t}\n\tstate.assigned[prop] = true\n\tstate.copy[prop] = value\n\treturn true\n}\n\nfunction deleteProperty(state, prop) {\n\t// The `undefined` check is a fast path for pre-existing keys.\n\tif (peek(state.base, prop) !== undefined || prop in state.base) {\n\t\tstate.assigned[prop] = false\n\t\tmarkChanged(state)\n\t} else if (state.assigned[prop]) {\n\t\t// if an originally not assigned property was deleted\n\t\tdelete state.assigned[prop]\n\t}\n\tif (state.copy) delete state.copy[prop]\n\treturn true\n}\n\n// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\nfunction getOwnPropertyDescriptor(state, prop) {\n\tconst owner = source(state)\n\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\tif (desc) {\n\t\tdesc.writable = true\n\t\tdesc.configurable = !Array.isArray(owner) || prop !== \"length\"\n\t}\n\treturn desc\n}\n\nfunction markChanged(state) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tstate.copy = assign(shallowCopy(state.base), state.drafts)\n\t\tstate.drafts = null\n\t\tif (state.parent) markChanged(state.parent)\n\t}\n}\n","import {each, clone} from \"./common\"\nimport {createDraft} from \"./immer\"\n\nexport function generatePatches(state, basePath, patches, inversePatches) {\n\tArray.isArray(state.base)\n\t\t? generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t: generateObjectPatches(state, basePath, patches, inversePatches)\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n\tlet {base, copy, assigned} = state\n\n\t// Reduce complexity by ensuring `base` is never longer.\n\tif (copy.length < base.length) {\n\t\t;[base, copy] = [copy, base]\n\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t}\n\n\tconst delta = copy.length - base.length\n\n\t// Find the first replaced index.\n\tlet start = 0\n\twhile (base[start] === copy[start] && start < base.length) {\n\t\t++start\n\t}\n\n\t// Find the last replaced index. Search from the end to optimize splice patches.\n\tlet end = base.length\n\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\n\t\t--end\n\t}\n\n\t// Process replaced indices.\n\tfor (let i = start; i < end; ++i) {\n\t\tif (assigned[i] && copy[i] !== base[i]) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: copy[i]\n\t\t\t})\n\t\t\tinversePatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: base[i]\n\t\t\t})\n\t\t}\n\t}\n\n\tconst replaceCount = patches.length\n\n\t// Process added indices.\n\tfor (let i = end + delta - 1; i >= end; --i) {\n\t\tconst path = basePath.concat([i])\n\t\tpatches[replaceCount + i - end] = {\n\t\t\top: \"add\",\n\t\t\tpath,\n\t\t\tvalue: copy[i]\n\t\t}\n\t\tinversePatches.push({\n\t\t\top: \"remove\",\n\t\t\tpath\n\t\t})\n\t}\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n\tconst {base, copy} = state\n\teach(state.assigned, (key, assignedValue) => {\n\t\tconst origValue = base[key]\n\t\tconst value = copy[key]\n\t\tconst op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\"\n\t\tif (origValue === value && op === \"replace\") return\n\t\tconst path = basePath.concat(key)\n\t\tpatches.push(op === \"remove\" ? {op, path} : {op, path, value})\n\t\tinversePatches.push(\n\t\t\top === \"add\"\n\t\t\t\t? {op: \"remove\", path}\n\t\t\t\t: op === \"remove\"\n\t\t\t\t? {op: \"add\", path, value: origValue}\n\t\t\t\t: {op: \"replace\", path, value: origValue}\n\t\t)\n\t})\n}\n\nexport const applyPatches = (draft, patches) => {\n\tfor (const patch of patches) {\n\t\tconst {path, op} = patch\n\t\tconst value = clone(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\n\t\tif (!path.length) throw new Error(\"Illegal state\")\n\n\t\tlet base = draft\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tbase = base[path[i]]\n\t\t\tif (!base || typeof base !== \"object\")\n\t\t\t\tthrow new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n\t\t}\n\n\t\tconst key = path[path.length - 1]\n\t\tswitch (op) {\n\t\t\tcase \"replace\":\n\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t// so we use value from the cloned patch\n\t\t\t\tbase[key] = value\n\t\t\t\tbreak\n\t\t\tcase \"add\":\n\t\t\t\tif (Array.isArray(base)) {\n\t\t\t\t\t// TODO: support \"foo/-\" paths for appending to an array\n\t\t\t\t\tbase.splice(key, 0, value)\n\t\t\t\t} else {\n\t\t\t\t\tbase[key] = value\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"remove\":\n\t\t\t\tif (Array.isArray(base)) {\n\t\t\t\t\tbase.splice(key, 1)\n\t\t\t\t} else {\n\t\t\t\t\tdelete base[key]\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported patch operation: \" + op)\n\t\t}\n\t}\n\n\treturn draft\n}\n","import * as legacyProxy from \"./es5\"\nimport * as modernProxy from \"./proxy\"\nimport {applyPatches, generatePatches} from \"./patches\"\nimport {\n\tassign,\n\teach,\n\thas,\n\tis,\n\tisDraft,\n\tisDraftable,\n\tisEnumerable,\n\tshallowCopy,\n\tDRAFT_STATE,\n\tNOTHING\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\nfunction verifyMinified() {}\n\nconst configDefaults = {\n\tuseProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n\tautoFreeze:\n\t\ttypeof process !== \"undefined\"\n\t\t\t? process.env.NODE_ENV !== \"production\"\n\t\t\t: verifyMinified.name === \"verifyMinified\",\n\tonAssign: null,\n\tonDelete: null,\n\tonCopy: null\n}\n\nexport class Immer {\n\tconstructor(config) {\n\t\tassign(this, configDefaults, config)\n\t\tthis.setUseProxies(this.useProxies)\n\t\tthis.produce = this.produce.bind(this)\n\t}\n\tproduce(base, recipe, patchListener) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(base = defaultBase, ...args) {\n\t\t\t\treturn self.produce(base, draft => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\t// prettier-ignore\n\t\t{\n\t\t\tif (typeof recipe !== \"function\") {\n\t\t\t\tthrow new Error(\"The first or second argument to `produce` must be a function\")\n\t\t\t}\n\t\t\tif (patchListener !== undefined && typeof patchListener !== \"function\") {\n\t\t\t\tthrow new Error(\"The third argument to `produce` must be a function or undefined\")\n\t\t\t}\n\t\t}\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = ImmerScope.enter()\n\t\t\tconst proxy = this.createProxy(base)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) scope.revoke()\n\t\t\t\telse scope.leave()\n\t\t\t}\n\t\t\tif (result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tscope.usePatches(patchListener)\n\t\t\t\t\t\treturn this.processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tscope.revoke()\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tscope.usePatches(patchListener)\n\t\t\treturn this.processResult(result, scope)\n\t\t} else {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) return base\n\t\t\treturn result !== NOTHING ? result : undefined\n\t\t}\n\t}\n\tproduceWithPatches(arg1, arg2, arg3) {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\tconst self = this\n\t\t\treturn (state, ...args) =>\n\t\t\t\tthis.produceWithPatches(state, draft => arg1(draft, ...args))\n\t\t}\n\t\t// non-curried form\n\t\tif (arg3)\n\t\t\tthrow new Error(\"A patch listener cannot be passed to produceWithPatches\")\n\t\tlet patches, inversePatches\n\t\tconst nextState = this.produce(arg1, arg2, (p, ip) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches, inversePatches]\n\t}\n\tcreateDraft(base) {\n\t\tif (!isDraftable(base)) {\n\t\t\tthrow new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\") // prettier-ignore\n\t\t}\n\t\tconst scope = ImmerScope.enter()\n\t\tconst proxy = this.createProxy(base)\n\t\tproxy[DRAFT_STATE].isManual = true\n\t\tscope.leave()\n\t\treturn proxy\n\t}\n\tfinishDraft(draft, patchListener) {\n\t\tconst state = draft && draft[DRAFT_STATE]\n\t\tif (!state || !state.isManual) {\n\t\t\tthrow new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\") // prettier-ignore\n\t\t}\n\t\tif (state.finalized) {\n\t\t\tthrow new Error(\"The given draft is already finalized\") // prettier-ignore\n\t\t}\n\t\tconst {scope} = state\n\t\tscope.usePatches(patchListener)\n\t\treturn this.processResult(undefined, scope)\n\t}\n\tsetAutoFreeze(value) {\n\t\tthis.autoFreeze = value\n\t}\n\tsetUseProxies(value) {\n\t\tthis.useProxies = value\n\t\tassign(this, value ? modernProxy : legacyProxy)\n\t}\n\tapplyPatches(base, patches) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatches(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, draft =>\n\t\t\tapplyPatches(draft, patches.slice(i + 1))\n\t\t)\n\t}\n\t/** @internal */\n\tprocessResult(result, scope) {\n\t\tconst baseDraft = scope.drafts[0]\n\t\tconst isReplaced = result !== undefined && result !== baseDraft\n\t\tthis.willFinalize(scope, result, isReplaced)\n\t\tif (isReplaced) {\n\t\t\tif (baseDraft[DRAFT_STATE].modified) {\n\t\t\t\tscope.revoke()\n\t\t\t\tthrow new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\t\t\t}\n\t\t\tif (isDraftable(result)) {\n\t\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\t\tresult = this.finalize(result, null, scope)\n\t\t\t}\n\t\t\tif (scope.patches) {\n\t\t\t\tscope.patches.push({\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: [],\n\t\t\t\t\tvalue: result\n\t\t\t\t})\n\t\t\t\tscope.inversePatches.push({\n\t\t\t\t\top: \"replace\",\n\t\t\t\t\tpath: [],\n\t\t\t\t\tvalue: baseDraft[DRAFT_STATE].base\n\t\t\t\t})\n\t\t\t}\n\t\t} else {\n\t\t\t// Finalize the base draft.\n\t\t\tresult = this.finalize(baseDraft, [], scope)\n\t\t}\n\t\tscope.revoke()\n\t\tif (scope.patches) {\n\t\t\tscope.patchListener(scope.patches, scope.inversePatches)\n\t\t}\n\t\treturn result !== NOTHING ? result : undefined\n\t}\n\t/**\n\t * @internal\n\t * Finalize a draft, returning either the unmodified base state or a modified\n\t * copy of the base state.\n\t */\n\tfinalize(draft, path, scope) {\n\t\tconst state = draft[DRAFT_STATE]\n\t\tif (!state) {\n\t\t\tif (Object.isFrozen(draft)) return draft\n\t\t\treturn this.finalizeTree(draft, null, scope)\n\t\t}\n\t\t// Never finalize drafts owned by another scope.\n\t\tif (state.scope !== scope) {\n\t\t\treturn draft\n\t\t}\n\t\tif (!state.modified) {\n\t\t\treturn state.base\n\t\t}\n\t\tif (!state.finalized) {\n\t\t\tstate.finalized = true\n\t\t\tthis.finalizeTree(state.draft, path, scope)\n\n\t\t\tif (this.onDelete) {\n\t\t\t\t// The `assigned` object is unreliable with ES5 drafts.\n\t\t\t\tif (this.useProxies) {\n\t\t\t\t\tconst {assigned} = state\n\t\t\t\t\tfor (const prop in assigned) {\n\t\t\t\t\t\tif (!assigned[prop]) this.onDelete(state, prop)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst {base, copy} = state\n\t\t\t\t\teach(base, prop => {\n\t\t\t\t\t\tif (!has(copy, prop)) this.onDelete(state, prop)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.onCopy) {\n\t\t\t\tthis.onCopy(state)\n\t\t\t}\n\n\t\t\t// At this point, all descendants of `state.copy` have been finalized,\n\t\t\t// so we can be sure that `scope.canAutoFreeze` is accurate.\n\t\t\tif (this.autoFreeze && scope.canAutoFreeze) {\n\t\t\t\tObject.freeze(state.copy)\n\t\t\t}\n\n\t\t\tif (path && scope.patches) {\n\t\t\t\tgeneratePatches(state, path, scope.patches, scope.inversePatches)\n\t\t\t}\n\t\t}\n\t\treturn state.copy\n\t}\n\t/**\n\t * @internal\n\t * Finalize all drafts in the given state tree.\n\t */\n\tfinalizeTree(root, rootPath, scope) {\n\t\tconst state = root[DRAFT_STATE]\n\t\tif (state) {\n\t\t\tif (!this.useProxies) {\n\t\t\t\t// Create the final copy, with added keys and without deleted keys.\n\t\t\t\tstate.copy = shallowCopy(state.draft, true)\n\t\t\t}\n\t\t\troot = state.copy\n\t\t}\n\n\t\tconst needPatches = !!rootPath && !!scope.patches\n\t\tconst finalizeProperty = (prop, value, parent) => {\n\t\t\tif (value === parent) {\n\t\t\t\tthrow Error(\"Immer forbids circular references\")\n\t\t\t}\n\n\t\t\t// In the `finalizeTree` method, only the `root` object may be a draft.\n\t\t\tconst isDraftProp = !!state && parent === root\n\n\t\t\tif (isDraft(value)) {\n\t\t\t\tconst path =\n\t\t\t\t\tisDraftProp && needPatches && !state.assigned[prop]\n\t\t\t\t\t\t? rootPath.concat(prop)\n\t\t\t\t\t\t: null\n\n\t\t\t\t// Drafts owned by `scope` are finalized here.\n\t\t\t\tvalue = this.finalize(value, path, scope)\n\n\t\t\t\t// Drafts from another scope must prevent auto-freezing.\n\t\t\t\tif (isDraft(value)) {\n\t\t\t\t\tscope.canAutoFreeze = false\n\t\t\t\t}\n\n\t\t\t\t// Preserve non-enumerable properties.\n\t\t\t\tif (Array.isArray(parent) || isEnumerable(parent, prop)) {\n\t\t\t\t\tparent[prop] = value\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty(parent, prop, {value})\n\t\t\t\t}\n\n\t\t\t\t// Unchanged drafts are never passed to the `onAssign` hook.\n\t\t\t\tif (isDraftProp && value === state.base[prop]) return\n\t\t\t}\n\t\t\t// Unchanged draft properties are ignored.\n\t\t\telse if (isDraftProp && is(value, state.base[prop])) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\t\t\telse if (isDraftable(value) && !Object.isFrozen(value)) {\n\t\t\t\teach(value, finalizeProperty)\n\t\t\t}\n\n\t\t\tif (isDraftProp && this.onAssign) {\n\t\t\t\tthis.onAssign(state, prop, value)\n\t\t\t}\n\t\t}\n\n\t\teach(root, finalizeProperty)\n\t\treturn root\n\t}\n}\n","import {Immer} from \"./immer\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches = immer.produceWithPatches.bind(immer)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\nexport {\n\toriginal,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./common\"\n\nexport {Immer}\n"],"mappings":";AAAA,IAAaA,OAAO,GACnB,OAAOC,MAAP,KAAkB,WAAlB,GACGA,MAAM,CAAC,eAAD,CADT,IAAAC,GAAA,GAEG,IAAAA,GAAA,CAAE,eAAD,IAAmB,MAAAA,GAAA,CAHjB;AAKP,IAAaC,SAAS,GACrB,OAAOF,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACG,GAAxC,GACGH,MAAM,CAACG,GAAP,CAAW,iBAAX,CADH,GAEG,oBAHG;AAKP,IAAaC,WAAW,GACvB,OAAOJ,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACG,GAAxC,GACGH,MAAM,CAACG,GAAP,CAAW,aAAX,CADH,GAEG,gBAHG;AAKP,SAAgBE,OAATA,CAAiBC,KAAjB,EAAwB;SACvB,CAAC,CAACA,KAAF,IAAW,CAAC,CAACA,KAAK,CAACF,WAAD,CAAzB;;AAGD,SAAgBG,WAATA,CAAqBD,KAArB,EAA4B;MAC9B,CAACA,KAAL;IAAY,OAAO,KAAP;EAAA;SAEXE,aAAa,CAACF,KAAD,CAAb,IAAwB,CAAC,CAACA,KAAK,CAACJ,SAAD,CAA/B,IAA8C,CAAC,CAACI,KAAK,CAACG,WAAN,CAAkBP,SAAlB,CADjD;;AAKD,SAAgBM,aAATA,CAAuBF,KAAvB,EAA8B;MAChC,CAACA,KAAD,IAAU,OAAOA,KAAP,KAAiB,QAA/B;IAAyC,OAAO,KAAP;EAAA;MACrCI,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAJ;IAA0B,OAAO,IAAP;EAAA;MACpBM,KAAK,GAAGC,MAAM,CAACC,cAAP,CAAsBR,KAAtB,CAAd;SACO,CAACM,KAAD,IAAUA,KAAK,KAAKC,MAAM,CAACE,SAAlC;;AAGD,SAAgBC,QAATA,CAAkBV,KAAlB,EAAyB;MAC3BA,KAAK,IAAIA,KAAK,CAACF,WAAD,CAAlB,EAAiC;WACzBE,KAAK,CAACF,WAAD,CAAL,CAAmBa,IAA1B;GAF8B;;AAOhC,IAAaC,MAAM,GAClBL,MAAM,CAACK,MAAP,IACA,SAASA,MAATA,CAAgBC,MAAhB,EAAwBb,KAAxB,EAA+B;OACzB,IAAIc,GAAT,IAAgBd,KAAhB,EAAuB;QAClBe,GAAG,CAACf,KAAD,EAAQc,GAAR,CAAP,EAAqB;MACpBD,MAAM,CAACC,GAAD,CAAN,GAAcd,KAAK,CAACc,GAAD,CAAnB;;;SAGKD,MAAP;CARK;AAWP,IAAaG,OAAO,GACnB,OAAOC,OAAP,KAAmB,WAAnB,IAAkCA,OAAO,CAACD,OAA1C,GACGC,OAAO,CAACD,OADX,GAEG,OAAOT,MAAM,CAACW,qBAAd,KAAwC,WAAxC,aACAvB,GAAA;EAAA,OACAY,MAAM,CAACY,mBAAP,CAA2BxB,GAA3B,EAAgCyB,MAAhC,CACCb,MAAM,CAACW,qBAAP,CAA6BvB,GAA7B,CADD;AAAA,CAFA,GAKAY,MAAM,CAACY,mBARJ;AAUP,SAAgBE,WAATA,CAAqBV,IAArB,EAA2BW,aAA3B,EAAkD;6CAAV,GAAG;MAC7ClB,KAAK,CAACC,OAAN,CAAcM,IAAd,CAAJ;IAAyB,OAAOA,IAAI,CAACY,KAAL,EAAP;EAAA;MACnBC,KAAK,GAAGjB,MAAM,CAACkB,MAAP,CAAclB,MAAM,CAACC,cAAP,CAAsBG,IAAtB,CAAd,CAAd;EACAK,OAAO,CAACL,IAAD,CAAP,CAAce,OAAd,WAAsBZ,GAAA;QACjBA,GAAG,KAAKhB,WAAZ,EAAyB;aAAA;;QAGnB6B,IAAI,GAAGpB,MAAM,CAACqB,wBAAP,CAAgCjB,IAAhC,EAAsCG,GAAtC,CAAb;IACK,IAAAd,KAAA,GAAA2B,IAAA,CAAA3B,KAAA;QACD2B,IAAI,CAACE,GAAT,EAAc;UACT,CAACP,aAAL,EAAoB;cACb,IAAIQ,KAAJ,CAAU,8CAAV,CAAN;;MAED9B,KAAK,GAAG2B,IAAI,CAACE,GAAL,CAASE,IAAT,CAAcpB,IAAd,CAAR;;QAEGgB,IAAI,CAACK,UAAT,EAAqB;MACpBR,KAAK,CAACV,GAAD,CAAL,GAAad,KAAb;KADD,MAEO;MACNO,MAAM,CAAC0B,cAAP,CAAsBT,KAAtB,EAA6BV,GAA7B,EAAkC;eACjCd,KADiC;QAEjCkC,QAAQ,EAAE,IAFuB;QAGjCC,YAAY,EAAE;OAHf;;GAfF;SAsBOX,KAAP;;AAGD,SAAgBY,IAATA,CAAcpC,KAAd,EAAqBqC,EAArB,EAAyB;MAC3BjC,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAJ,EAA0B;SACpB,IAAIsC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtC,KAAK,CAACuC,MAA1B,EAAkCD,CAAC,EAAnC;MAAuCD,EAAE,CAACC,CAAD,EAAItC,KAAK,CAACsC,CAAD,CAAT,EAActC,KAAd,CAAF;IAAA;GADxC,MAEO;IACNgB,OAAO,CAAChB,KAAD,CAAP,CAAe0B,OAAf,WAAuBZ,GAAA;MAAA,OAAOuB,EAAE,CAACvB,GAAD,EAAMd,KAAK,CAACc,GAAD,CAAX,EAAkBd,KAAlB;IAAA,CAAhC;;;AAIF,SAAgBwC,YAATA,CAAsB7B,IAAtB,EAA4B8B,IAA5B,EAAkC;MAClCd,IAAI,GAAGpB,MAAM,CAACqB,wBAAP,CAAgCjB,IAAhC,EAAsC8B,IAAtC,CAAb;SACO,CAAC,CAACd,IAAF,IAAUA,IAAI,CAACK,UAAtB;;AAGD,SAAgBjB,GAATA,CAAa2B,KAAb,EAAoBD,IAApB,EAA0B;SACzBlC,MAAM,CAACE,SAAP,CAAiBkC,cAAjB,CAAgCZ,IAAhC,CAAqCW,KAArC,EAA4CD,IAA5C,CAAP;;AAGD,SAAgBG,EAATA,CAAYC,CAAZ,EAAeC,CAAf,EAAkB;;MAEpBD,CAAC,KAAKC,CAAV,EAAa;WACLD,CAAC,KAAK,CAAN,IAAW,IAAIA,CAAJ,KAAU,IAAIC,CAAhC;GADD,MAEO;WACCD,CAAC,KAAKA,CAAN,IAAWC,CAAC,KAAKA,CAAxB;;;AAIF,SAAgBtB,KAATA,CAAe7B,GAAf,EAAoB;MACtB,CAACM,WAAW,CAACN,GAAD,CAAhB;IAAuB,OAAOA,GAAP;EAAA;MACnBS,KAAK,CAACC,OAAN,CAAcV,GAAd,CAAJ;IAAwB,OAAOA,GAAG,CAACoD,GAAJ,CAAQvB,KAAR,CAAP;EAAA;MAClBwB,MAAM,GAAGzC,MAAM,CAACkB,MAAP,CAAclB,MAAM,CAACC,cAAP,CAAsBb,GAAtB,CAAd,CAAf;OACK,IAAMmB,GAAX,IAAkBnB,GAAlB;IAAuBqD,MAAM,CAAClC,GAAD,CAAN,GAAcU,KAAK,CAAC7B,GAAG,CAACmB,GAAD,CAAJ,CAAnB;EAAA;SAChBkC,MAAP;;;;;ACrHD,IAAaC,UAAN,GACN,SAAAA,UAAW9C,CAAC+C,MAAD,EAAS;OACdC,MAAL,GAAc,EAAd;OACKD,MAAL,GAAcA,MAAd,CAFmB;;;OAMdE,aAAL,GAAqB,IAArB,CANmB;;OASdC,OAAL,GAAe,IAAf;;AAEDJ,UAAA,CAAAxC,SAAA,CAAA6C,UAAA,YAAAA,WAAWC,aAAD,EAAgB;MACrBA,aAAJ,EAAmB;SACbF,OAAL,GAAe,EAAf;SACKG,cAAL,GAAsB,EAAtB;SACKD,aAAL,GAAqBA,aAArB;;;AAGFN,UAAA,CAAAxC,SAAA,CAAAgD,MAAA,YAAAC,SAAA,EAAS;OACHC,KAAL;OACKR,MAAL,CAAYzB,OAAZ,CAAoB+B,MAApB;OACKN,MAAL,GAAc,IAAd,CAHQ;;AAKTF,UAAA,CAAAxC,SAAA,CAAAkD,KAAA,YAAAA,MAAA,EAAQ;MACH,SAASV,UAAU,CAACW,OAAxB,EAAiC;IAChCX,UAAU,CAACW,OAAX,GAAqB,KAAKV,MAA1B;;;AAKHD,UAAU,CAACW,OAAX,GAAqB,IAArB;AACAX,UAAU,CAACY,KAAX,GAAmB,YAAW;SACrB,KAAKD,OAAL,GAAe,IAAIX,UAAJ,CAAe,KAAKW,OAApB,CAAvB;CADD;AAIA,SAASH,MAATA,CAAgBK,KAAhB,EAAuB;EACtBA,KAAK,CAAChE,WAAD,CAAL,CAAmB2D,MAAnB;;;;;ACzBD,IAAMM,WAAW,GAAG,EAApB;AAEA,SAAgBC,YAATA,CAAsBC,KAAtB,EAA6BC,MAA7B,EAAqCC,UAArC,EAAiD;EACvDF,KAAK,CAACd,MAAN,CAAazB,OAAb,WAAqBoC,KAAA;IACpBA,KAAK,CAAChE,WAAD,CAAL,CAAmBsE,UAAnB,GAAgC,IAAhC;GADD;MAGI,CAACD,UAAL,EAAiB;QACZF,KAAK,CAACZ,OAAV,EAAmB;MAClBgB,sBAAsB,CAACJ,KAAK,CAACd,MAAN,CAAa,CAAb,CAAD,CAAtB;KAFe;;IAKhBmB,gBAAgB,CAACL,KAAK,CAACd,MAAP,CAAhB;GALD;EAAA,KAQK,IAAIpD,OAAO,CAACmE,MAAD,CAAP,IAAmBA,MAAM,CAACpE,WAAD,CAAN,CAAoBmE,KAApB,KAA8BA,KAArD,EAA4D;IAChEK,gBAAgB,CAACL,KAAK,CAACd,MAAP,CAAhB;;;AAIF,SAAgBoB,WAATA,CAAqB5D,IAArB,EAA2BuC,MAA3B,EAAmC;MACnC7C,OAAO,GAAGD,KAAK,CAACC,OAAN,CAAcM,IAAd,CAAhB;MACMmD,KAAK,GAAGU,mBAAmB,CAAC7D,IAAD,CAAjC;EACAyB,IAAI,CAAC0B,KAAD,YAAQrB,IAAA;IACXgC,aAAa,CAACX,KAAD,EAAQrB,IAAR,EAAcpC,OAAO,IAAImC,YAAY,CAAC7B,IAAD,EAAO8B,IAAP,CAArC,CAAb;GADG,CAAJ,CAHyC;;MAQnCwB,KAAK,GAAGf,MAAM,GAAGA,MAAM,CAACe,KAAV,GAAkBhB,UAAU,CAACW,OAAjD;MACMc,KAAK,GAAG;WACbT,KADa;IAEbU,QAAQ,EAAE,KAFG;IAGbP,UAAU,EAAE,KAHC;;IAIbQ,SAAS,EAAE,KAJE;IAKbC,QAAQ,EAAE,EALG;YAMb3B,MANa;UAObvC,IAPa;WAQbmD,KARa;IASbgB,IAAI,EAAE,IATO;YAUbpB,QAVa;IAWbqB,OAAO,EAAE,KAXI;GAAd;EAcAC,oBAAoB,CAAClB,KAAD,EAAQhE,WAAR,EAAqB4E,KAArB,CAApB;EACAT,KAAK,CAACd,MAAN,CAAa8B,IAAb,CAAkBnB,KAAlB;SACOA,KAAP;;AAGD,SAASJ,QAATD,CAAA,EAAkB;OACZsB,OAAL,GAAe,IAAf;;AAGD,SAASG,MAATA,CAAgBR,KAAhB,EAAuB;SACfA,KAAK,CAACI,IAAN,IAAcJ,KAAK,CAAC/D,IAA3B;;;AAID,SAASwE,IAATA,CAAcrB,KAAd,EAAqBrB,IAArB,EAA2B;MACpBiC,KAAK,GAAGZ,KAAK,CAAChE,WAAD,CAAnB;MACI4E,KAAK,IAAI,CAACA,KAAK,CAACN,UAApB,EAAgC;IAC/BM,KAAK,CAACN,UAAN,GAAmB,IAAnB;QACMpE,KAAK,GAAG8D,KAAK,CAACrB,IAAD,CAAnB;IACAiC,KAAK,CAACN,UAAN,GAAmB,KAAnB;WACOpE,KAAP;;SAEM8D,KAAK,CAACrB,IAAD,CAAZ;;AAGD,SAASZ,GAATA,CAAa6C,KAAb,EAAoBjC,IAApB,EAA0B;EACzB2C,eAAe,CAACV,KAAD,CAAf;MACM1E,KAAK,GAAGmF,IAAI,CAACD,MAAM,CAACR,KAAD,CAAP,EAAgBjC,IAAhB,CAAlB;MACIiC,KAAK,CAACN,UAAV;IAAsB,OAAOpE,KAAP;EAAA,CAHG;;MAKrBA,KAAK,KAAKmF,IAAI,CAACT,KAAK,CAAC/D,IAAP,EAAa8B,IAAb,CAAd,IAAoCxC,WAAW,CAACD,KAAD,CAAnD,EAA4D;IAC3DqF,WAAW,CAACX,KAAD,CAAX;WACQA,KAAK,CAACI,IAAN,CAAWrC,IAAX,IAAmB8B,WAAW,CAACvE,KAAD,EAAQ0E,KAAR,CAAtC;;SAEM1E,KAAP;;AAGD,SAASsF,GAATA,CAAaZ,KAAb,EAAoBjC,IAApB,EAA0BzC,KAA1B,EAAiC;EAChCoF,eAAe,CAACV,KAAD,CAAf;EACAA,KAAK,CAACG,QAAN,CAAepC,IAAf,IAAuB,IAAvB;MACI,CAACiC,KAAK,CAACC,QAAX,EAAqB;QAChB/B,EAAE,CAAC5C,KAAD,EAAQmF,IAAI,CAACD,MAAM,CAACR,KAAD,CAAP,EAAgBjC,IAAhB,CAAZ,CAAN;MAA0C;IAAA;IAC1C8C,WAAW,CAACb,KAAD,CAAX;IACAW,WAAW,CAACX,KAAD,CAAX;;EAEDA,KAAK,CAACI,IAAN,CAAWrC,IAAX,IAAmBzC,KAAnB;;AAGD,SAASuF,WAATA,CAAqBb,KAArB,EAA4B;MACvB,CAACA,KAAK,CAACC,QAAX,EAAqB;IACpBD,KAAK,CAACC,QAAN,GAAiB,IAAjB;QACID,KAAK,CAACxB,MAAV;MAAkBqC,WAAW,CAACb,KAAK,CAACxB,MAAP,CAAX;IAAA;;;AAIpB,SAASmC,WAATA,CAAqBX,KAArB,EAA4B;MACvB,CAACA,KAAK,CAACI,IAAX;IAAiBJ,KAAK,CAACI,IAAN,GAAaN,mBAAmB,CAACE,KAAK,CAAC/D,IAAP,CAAhC;EAAA;;AAGlB,SAAS6D,mBAATA,CAA6B7D,IAA7B,EAAmC;MAC5B+D,KAAK,GAAG/D,IAAI,IAAIA,IAAI,CAACb,WAAD,CAA1B;MACI4E,KAAJ,EAAW;IACVA,KAAK,CAACN,UAAN,GAAmB,IAAnB;QACMN,KAAK,GAAGzC,WAAW,CAACqD,KAAK,CAACZ,KAAP,EAAc,IAAd,CAAzB;IACAY,KAAK,CAACN,UAAN,GAAmB,KAAnB;WACON,KAAP;;SAEMzC,WAAW,CAACV,IAAD,CAAlB;;AAGD,SAAS8D,aAATA,CAAuBX,KAAvB,EAA8BrB,IAA9B,EAAoCT,UAApC,EAAgD;MAC3CL,IAAI,GAAGoC,WAAW,CAACtB,IAAD,CAAtB;MACId,IAAJ,EAAU;IACTA,IAAI,CAACK,UAAL,GAAkBA,UAAlB;GADD,MAEO;IACN+B,WAAW,CAACtB,IAAD,CAAX,GAAoBd,IAAI,GAAG;MAC1BQ,YAAY,EAAE,IADY;kBAE1BH,UAF0B;MAG1BH,GAAA,WAAA2D,KAAG3D,CAAA,EAAG;eACEA,GAAG,CAAC,KAAK/B,WAAL,CAAD,EAAoB2C,IAApB,CAAV;OAJyB;MAM1B6C,GAAA,WAAAG,KAAGH,CAACtF,KAAD,EAAQ;QACVsF,GAAG,CAAC,KAAKxF,WAAL,CAAD,EAAoB2C,IAApB,EAA0BzC,KAA1B,CAAH;;KAPF;;EAWDO,MAAM,CAAC0B,cAAP,CAAsB6B,KAAtB,EAA6BrB,IAA7B,EAAmCd,IAAnC;;AAGD,SAASyD,eAATA,CAAyBV,KAAzB,EAAgC;MAC3BA,KAAK,CAACK,OAAN,KAAkB,IAAtB;IACC,MAAM,IAAIjD,KAAJ,CACL,yHACC4D,IAAI,CAACC,SAAL,CAAeT,MAAM,CAACR,KAAD,CAArB,CAFI,CAAN;EAAA;;;AAOF,SAASJ,gBAATA,CAA0BnB,MAA1B,EAAkC;;;;;OAK5B,IAAIb,CAAC,GAAGa,MAAM,CAACZ,MAAP,GAAgB,CAA7B,EAAgCD,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;QACtCoC,KAAK,GAAGvB,MAAM,CAACb,CAAD,CAAN,CAAUxC,WAAV,CAAd;QACI,CAAC4E,KAAK,CAACC,QAAX,EAAqB;UAChBvE,KAAK,CAACC,OAAN,CAAcqE,KAAK,CAAC/D,IAApB,CAAJ,EAA+B;YAC1BiF,eAAe,CAAClB,KAAD,CAAnB;UAA4Ba,WAAW,CAACb,KAAD,CAAX;QAAA;OAD7B,MAEO,IAAImB,gBAAgB,CAACnB,KAAD,CAApB;QAA6Ba,WAAW,CAACb,KAAD,CAAX;MAAA;;;;AAKvC,SAASL,sBAATA,CAAgCyB,MAAhC,EAAwC;MACnC,CAACA,MAAD,IAAW,OAAOA,MAAP,KAAkB,QAAjC;IAA2C;EAAA;MACrCpB,KAAK,GAAGoB,MAAM,CAAChG,WAAD,CAApB;MACI,CAAC4E,KAAL;IAAY;EAAA;;EACC,IAAAZ,KAAA,GAAAY,KAAA,CAAAZ,KAAA;EAAO,IAAAe,QAAA,GAAAH,KAAA,CAAAG,QAAA;MAChB,CAACzE,KAAK,CAACC,OAAN,CAAcyF,MAAd,CAAL,EAA4B;;IAE3BvF,MAAM,CAACwF,IAAP,CAAYjC,KAAZ,EAAmBpC,OAAnB,WAA2BZ,GAAA;;UAEtBH,IAAI,CAACG,GAAD,CAAJ,KAAckF,SAAd,IAA2B,CAACjF,GAAG,CAACJ,IAAD,EAAOG,GAAP,CAAnC,EAAgD;QAC/C+D,QAAQ,CAAC/D,GAAD,CAAR,GAAgB,IAAhB;QACAyE,WAAW,CAACb,KAAD,CAAX;OAFD,MAGO,IAAI,CAACG,QAAQ,CAAC/D,GAAD,CAAb,EAAoB;;QAE1BuD,sBAAsB,CAACP,KAAK,CAAChD,GAAD,CAAN,CAAtB;;KAPF,EAF2B;;IAa3BP,MAAM,CAACwF,IAAP,CAAYpF,IAAZ,EAAkBe,OAAlB,WAA0BZ,GAAA;;UAErBgD,KAAK,CAAChD,GAAD,CAAL,KAAekF,SAAf,IAA4B,CAACjF,GAAG,CAAC+C,KAAD,EAAQhD,GAAR,CAApC,EAAkD;QACjD+D,QAAQ,CAAC/D,GAAD,CAAR,GAAgB,KAAhB;QACAyE,WAAW,CAACb,KAAD,CAAX;;KAJF;GAbD,MAoBO,IAAIkB,eAAe,CAAClB,KAAD,CAAnB,EAA4B;IAClCa,WAAW,CAACb,KAAD,CAAX;IACAG,QAAQ,CAACtC,MAAT,GAAkB,IAAlB;QACIuB,KAAK,CAACvB,MAAN,GAAe5B,IAAI,CAAC4B,MAAxB,EAAgC;WAC1B,IAAID,CAAC,GAAGwB,KAAK,CAACvB,MAAnB,EAA2BD,CAAC,GAAG3B,IAAI,CAAC4B,MAApC,EAA4CD,CAAC,EAA7C;QAAiDuC,QAAQ,CAACvC,CAAD,CAAR,GAAc,KAAd;MAAA;KADlD,MAEO;WACD,IAAI2D,GAAC,GAAGtF,IAAI,CAAC4B,MAAlB,EAA0B0D,GAAC,GAAGnC,KAAK,CAACvB,MAApC,EAA4C0D,GAAC,EAA7C;QAAiDpB,QAAQ,CAACoB,GAAD,CAAR,GAAc,IAAd;MAAA;;SAE7C,IAAIC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGpC,KAAK,CAACvB,MAA1B,EAAkC2D,GAAC,EAAnC,EAAuC;;UAElCrB,QAAQ,CAACqB,GAAD,CAAR,KAAgBF,SAApB;QAA+B3B,sBAAsB,CAACP,KAAK,CAACoC,GAAD,CAAN,CAAtB;MAAA;;;;AAKlC,SAASL,gBAATA,CAA0BnB,KAA1B,EAAiC;;EACnB,IAAAZ,KAAA,GAAAY,KAAA,CAAAZ,KAAA,CADmB;;;MAK1BiC,IAAI,GAAGxF,MAAM,CAACwF,IAAP,CAAYjC,KAAZ,CAAb;OACK,IAAIxB,CAAC,GAAGyD,IAAI,CAACxD,MAAL,GAAc,CAA3B,EAA8BD,CAAC,IAAI,CAAnC,EAAsCA,CAAC,EAAvC,EAA2C;QACpCxB,GAAG,GAAGiF,IAAI,CAACzD,CAAD,CAAhB;QACM6D,SAAS,GAAGxF,IAAI,CAACG,GAAD,CAAtB,CAF0C;;QAItCqF,SAAS,KAAKH,SAAd,IAA2B,CAACjF,GAAG,CAACJ,IAAD,EAAOG,GAAP,CAAnC,EAAgD;aACxC,IAAP;KADD;;SAKK;UACEd,KAAK,GAAG8D,KAAK,CAAChD,GAAD,CAAnB;UACMsF,OAAK,GAAGpG,KAAK,IAAIA,KAAK,CAACF,WAAD,CAA5B;UACIsG,OAAK,GAAGA,OAAK,CAACzF,IAAN,KAAewF,SAAlB,GAA8B,CAACvD,EAAE,CAAC5C,KAAD,EAAQmG,SAAR,CAA1C,EAA8D;eACtD,IAAP;;;GAnB6B;;;SA0BzBJ,IAAI,CAACxD,MAAL,KAAgBhC,MAAM,CAACwF,IAAP,CAAYpF,IAAZ,EAAkB4B,MAAzC;;AAGD,SAASqD,eAATA,CAAyBlB,KAAzB,EAAgC;EACxB,IAAAZ,KAAA,GAAAY,KAAA,CAAAZ,KAAA;MACHA,KAAK,CAACvB,MAAN,KAAiBmC,KAAK,CAAC/D,IAAN,CAAW4B,MAAhC;IAAwC,OAAO,IAAP;EAAA,CAFT;;;;;;;;MAUzB8D,UAAU,GAAG9F,MAAM,CAACqB,wBAAP,CAAgCkC,KAAhC,EAAuCA,KAAK,CAACvB,MAAN,GAAe,CAAtD,CAAnB,CAV+B;;MAY3B8D,UAAU,IAAI,CAACA,UAAU,CAACxE,GAA9B;IAAmC,OAAO,IAAP;EAAA,CAZJ;;SAcxB,KAAP;;AAGD,SAASmD,oBAATA,CAA8BnE,MAA9B,EAAsC4B,IAAtC,EAA4CzC,KAA5C,EAAmD;EAClDO,MAAM,CAAC0B,cAAP,CAAsBpB,MAAtB,EAA8B4B,IAA9B,EAAoC;IACnCzC,KAAK,EAAEA,KAD4B;IAEnCgC,UAAU,EAAE,KAFuB;IAGnCE,QAAQ,EAAE;GAHX;;;;;;ACnPM,SAASoE,cAATtC,CAAA,EAAwB;AAE/B,SAAgBuC,aAAThC,CAAqB5D,IAArB,EAA2BuC,MAA3B,EAAmC;MACnCe,KAAK,GAAGf,MAAM,GAAGA,MAAM,CAACe,KAAV,GAAkBhB,UAAU,CAACW,OAAjD;MACMc,KAAK,GAAG;;WAEbT,KAFa;;IAIbU,QAAQ,EAAE,KAJG;;IAMbC,SAAS,EAAE,KANE;;IAQbC,QAAQ,EAAE,EARG;;YAUb3B,MAVa;;UAYbvC,IAZa;;IAcbmD,KAAK,EAAE,IAdM;;IAgBbX,MAAM,EAAE,EAhBK;;IAkBb2B,IAAI,EAAE,IAlBO;;IAoBbrB,MAAM,EAAE;GApBT;YAuBwBrD,KAAK,CAACC,OAAN,CAAcM,IAAd;EAAA;;EAGrB6F,KAAK,CAACC,SAAN,CAAgB,CAAC/B,KAAD,CAAhB,EAAyBgC,UAAzB,CAHqB,GAIrBF,KAAK,CAACC,SAAN,CAAgB/B,KAAhB,EAAuBiC,WAAvB;EAJI,IAAAlD,MAAA,GAAAmD,GAAA,CAAAnD,MAAA;EAAQ,IAAAoD,KAAA,GAAAD,GAAA,CAAAC,KAAA;EAMfnC,KAAK,CAACZ,KAAN,GAAc+C,KAAd;EACAnC,KAAK,CAACjB,MAAN,GAAeA,MAAf;EAEAQ,KAAK,CAACd,MAAN,CAAa8B,IAAb,CAAkB4B,KAAlB;SACOA,KAAP;;AAGD,IAAMF,WAAW,GAAG;OACnBnB,KADmB;EAEnBzE,GAAA,WAAAA,GAAGA,CAACF,MAAD,EAAS4B,IAAT,EAAe;WACVA,IAAI,IAAIqE,QAAM,CAACjG,MAAD,CAArB;GAHkB;EAKnBG,OAAA,WAAAA,OAAOA,CAACH,MAAD,EAAS;WACRI,OAAO,CAACD,OAAR,CAAgB8F,QAAM,CAACjG,MAAD,CAAtB,CAAP;GANkB;OAQnB4E,KARmB;kBASnBsB,cATmB;4BAUnBnF,wBAVmB;EAWnBK,cAAA,WAAAA,cAAcA,CAAA,EAAG;UACV,IAAIH,KAAJ,CAAU,0DAAV,CAAN,CADgB;GAXE;EAcnBtB,cAAA,WAAAA,cAAcA,CAACK,MAAD,EAAS;WACfN,MAAM,CAACC,cAAP,CAAsBK,MAAM,CAACF,IAA7B,CAAP;GAfkB;EAiBnBqG,cAAA,WAAAA,cAAcA,CAAA,EAAG;UACV,IAAIlF,KAAJ,CAAU,0DAAV,CAAN,CADgB;;CAjBlB;AAsBA,IAAM4E,UAAU,GAAG,EAAnB;AACAtE,IAAI,CAACuE,WAAD,YAAe7F,GAAD,EAAMmG,EAAN;EACjBP,UAAU,CAAC5F,GAAD,CAAV,GAAkB,YAAW;IAC5BoG,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;WACOD,EAAE,CAACE,KAAH,CAAS,IAAT,EAAeD,SAAf,CAAP;GAFD;CADG,CAAJ;AAMAR,UAAU,CAACK,cAAX,GAA4B,UAASrC,KAAT,EAAgBjC,IAAhB,EAAsB;MAC7C2E,KAAK,CAACC,QAAQ,CAAC5E,IAAD,CAAT,CAAT,EAA2B;UACpB,IAAIX,KAAJ,CAAU,4CAAV,CAAN,CAD0B;;SAGpB6E,WAAW,CAACI,cAAZ,CAA2BhF,IAA3B,CAAgC,IAAhC,EAAsC2C,KAAK,CAAC,CAAD,CAA3C,EAAgDjC,IAAhD,CAAP;CAJD;AAMAiE,UAAU,CAACpB,GAAX,GAAiB,UAASZ,KAAT,EAAgBjC,IAAhB,EAAsBzC,KAAtB,EAA6B;MACzCyC,IAAI,KAAK,QAAT,IAAqB2E,KAAK,CAACC,QAAQ,CAAC5E,IAAD,CAAT,CAA9B,EAAgD;UACzC,IAAIX,KAAJ,CAAU,qEAAV,CAAN,CAD+C;;SAGzC6E,WAAW,CAACrB,GAAZ,CAAgBvD,IAAhB,CAAqB,IAArB,EAA2B2C,KAAK,CAAC,CAAD,CAAhC,EAAqCjC,IAArC,EAA2CzC,KAA3C,CAAP;CAJD;;AAQA,SAAS8G,QAAT5B,CAAgBR,KAAhB,EAAuB;SACfA,KAAK,CAACI,IAAN,IAAcJ,KAAK,CAAC/D,IAA3B;;;AAID,SAAS2G,MAATnC,CAAcrB,KAAd,EAAqBrB,IAArB,EAA2B;MACpBiC,KAAK,GAAGZ,KAAK,CAAChE,WAAD,CAAnB;MACM6B,IAAI,GAAGV,OAAO,CAACW,wBAAR,CACZ8C,KAAK,GAAGoC,QAAM,CAACpC,KAAD,CAAT,GAAmBZ,KADZ,EAEZrB,IAFY,CAAb;SAIOd,IAAI,IAAIA,IAAI,CAAC3B,KAApB;;AAGD,SAASwF,KAAT3D,CAAa6C,KAAb,EAAoBjC,IAApB,EAA0B;MACrBA,IAAI,KAAK3C,WAAb;IAA0B,OAAO4E,KAAP;EAAA;EACrB,IAAAvB,MAAA,GAAAuB,KAAA,CAAAvB,MAAA,CAFoB;;MAKrB,CAACuB,KAAK,CAACC,QAAP,IAAmB5D,GAAG,CAACoC,MAAD,EAASV,IAAT,CAA1B,EAA0C;WAClCU,MAAM,CAACV,IAAD,CAAb;;MAGKzC,KAAK,GAAG8G,QAAM,CAACpC,KAAD,CAAN,CAAcjC,IAAd,CAAd;MACIiC,KAAK,CAACE,SAAN,IAAmB,CAAC3E,WAAW,CAACD,KAAD,CAAnC,EAA4C;WACpCA,KAAP;GAXwB;;MAerB0E,KAAK,CAACC,QAAV,EAAoB;;QAEf3E,KAAK,KAAKsH,MAAI,CAAC5C,KAAK,CAAC/D,IAAP,EAAa8B,IAAb,CAAlB;MAAsC,OAAOzC,KAAP;IAAA,CAFnB;;IAInBmD,MAAM,GAAGuB,KAAK,CAACI,IAAf;;SAGO3B,MAAM,CAACV,IAAD,CAAN,GAAe8D,aAAW,CAACvG,KAAD,EAAQ0E,KAAR,CAAlC;;AAGD,SAASe,KAATH,CAAaZ,KAAb,EAAoBjC,IAApB,EAA0BzC,KAA1B,EAAiC;MAC5B,CAAC0E,KAAK,CAACC,QAAX,EAAqB;QACdwB,SAAS,GAAGmB,MAAI,CAAC5C,KAAK,CAAC/D,IAAP,EAAa8B,IAAb,CAAtB,CADoB;;;;QAKd8E,WAAW,GAAGvH,KAAK,GACtB4C,EAAE,CAACuD,SAAD,EAAYnG,KAAZ,CAAF,IAAwBA,KAAK,KAAK0E,KAAK,CAACvB,MAAN,CAAaV,IAAb,CADZ,GAEtBG,EAAE,CAACuD,SAAD,EAAYnG,KAAZ,CAAF,IAAwByC,IAAI,IAAIiC,KAAK,CAAC/D,IAFzC;QAGI4G,WAAJ;MAAiB,OAAO,IAAP;IAAA;IACjBC,aAAW,CAAC9C,KAAD,CAAX;;EAEDA,KAAK,CAACG,QAAN,CAAepC,IAAf,IAAuB,IAAvB;EACAiC,KAAK,CAACI,IAAN,CAAWrC,IAAX,IAAmBzC,KAAnB;SACO,IAAP;;AAGD,SAAS+G,cAATA,CAAwBrC,KAAxB,EAA+BjC,IAA/B,EAAqC;;MAEhC6E,MAAI,CAAC5C,KAAK,CAAC/D,IAAP,EAAa8B,IAAb,CAAJ,KAA2BuD,SAA3B,IAAwCvD,IAAI,IAAIiC,KAAK,CAAC/D,IAA1D,EAAgE;IAC/D+D,KAAK,CAACG,QAAN,CAAepC,IAAf,IAAuB,KAAvB;IACA+E,aAAW,CAAC9C,KAAD,CAAX;GAFD,MAGO,IAAIA,KAAK,CAACG,QAAN,CAAepC,IAAf,CAAJ,EAA0B;;WAEzBiC,KAAK,CAACG,QAAN,CAAepC,IAAf,CAAP;;MAEGiC,KAAK,CAACI,IAAV;IAAgB,OAAOJ,KAAK,CAACI,IAAN,CAAWrC,IAAX,CAAP;EAAA;SACT,IAAP;;;;AAKD,SAASb,wBAATA,CAAkC8C,KAAlC,EAAyCjC,IAAzC,EAA+C;MACxCgF,KAAK,GAAGX,QAAM,CAACpC,KAAD,CAApB;MACM/C,IAAI,GAAGV,OAAO,CAACW,wBAAR,CAAiC6F,KAAjC,EAAwChF,IAAxC,CAAb;MACId,IAAJ,EAAU;IACTA,IAAI,CAACO,QAAL,GAAgB,IAAhB;IACAP,IAAI,CAACQ,YAAL,GAAoB,CAAC/B,KAAK,CAACC,OAAN,CAAcoH,KAAd,CAAD,IAAyBhF,IAAI,KAAK,QAAtD;;SAEMd,IAAP;;AAGD,SAAS6F,aAATjC,CAAqBb,KAArB,EAA4B;MACvB,CAACA,KAAK,CAACC,QAAX,EAAqB;IACpBD,KAAK,CAACC,QAAN,GAAiB,IAAjB;IACAD,KAAK,CAACI,IAAN,GAAalE,MAAM,CAACS,WAAW,CAACqD,KAAK,CAAC/D,IAAP,CAAZ,EAA0B+D,KAAK,CAACvB,MAAhC,CAAnB;IACAuB,KAAK,CAACvB,MAAN,GAAe,IAAf;QACIuB,KAAK,CAACxB,MAAV;MAAkBsE,aAAW,CAAC9C,KAAK,CAACxB,MAAP,CAAX;IAAA;;;;;;;ACpLb,SAASwE,eAATA,CAAyBhD,KAAzB,EAAgCiD,QAAhC,EAA0CtE,OAA1C,EAAmDG,cAAnD,EAAmE;EACzEpD,KAAK,CAACC,OAAN,CAAcqE,KAAK,CAAC/D,IAApB,IACGiH,oBAAoB,CAAClD,KAAD,EAAQiD,QAAR,EAAkBtE,OAAlB,EAA2BG,cAA3B,CADvB,GAEGqE,qBAAqB,CAACnD,KAAD,EAAQiD,QAAR,EAAkBtE,OAAlB,EAA2BG,cAA3B,CAFxB;;AAKD,SAASoE,oBAATA,CAA8BlD,KAA9B,EAAqCiD,QAArC,EAA+CtE,OAA/C,EAAwDG,cAAxD,EAAwE;;;EAC5D,IAAAsB,IAAA,GAAAJ,KAAA,CAAAI,IAAA;EAAM,IAAAD,QAAA,GAAAH,KAAA,CAAAG,QAAA,CADsD;;MAInEC,IAAI,CAACvC,MAAL,GAAc5B,IAAI,CAAC4B,MAAvB,EAA+B;aACd,CAACuC,IAAD,EAAOnE,IAAP,GAAdA,IAAA,GAAAC,MAAA,KAAMkE,IAAA,GAAAlE,MAAA;eACqB,CAAC4C,cAAD,EAAiBH,OAAjB,GAA3BA,OAAA,GAAAyE,QAAA,KAAStE,cAAA,GAAAsE,QAAA;;MAGNC,KAAK,GAAGjD,IAAI,CAACvC,MAAL,GAAc5B,IAAI,CAAC4B,MAAjC,CATuE;;MAYnEyF,KAAK,GAAG,CAAZ;SACOrH,IAAI,CAACqH,KAAD,CAAJ,KAAgBlD,IAAI,CAACkD,KAAD,CAApB,IAA+BA,KAAK,GAAGrH,IAAI,CAAC4B,MAAnD,EAA2D;MACxDyF,KAAF;GAdsE;;MAkBnEC,GAAG,GAAGtH,IAAI,CAAC4B,MAAf;SACO0F,GAAG,GAAGD,KAAN,IAAerH,IAAI,CAACsH,GAAG,GAAG,CAAP,CAAJ,KAAkBnD,IAAI,CAACmD,GAAG,GAAGF,KAAN,GAAc,CAAf,CAA5C,EAA+D;MAC5DE,GAAF;GApBsE;;OAwBlE,IAAI3F,CAAC,GAAG0F,KAAb,EAAoB1F,CAAC,GAAG2F,GAAxB,EAA6B,EAAE3F,CAA/B,EAAkC;QAC7BuC,QAAQ,CAACvC,CAAD,CAAR,IAAewC,IAAI,CAACxC,CAAD,CAAJ,KAAY3B,IAAI,CAAC2B,CAAD,CAAnC,EAAwC;UACjC4F,IAAI,GAAGP,QAAQ,CAACvG,MAAT,CAAgB,CAACkB,CAAD,CAAhB,CAAb;MACAe,OAAO,CAAC4B,IAAR,CAAa;QACZkD,EAAE,EAAE,SADQ;cAEZD,IAFY;QAGZlI,KAAK,EAAE8E,IAAI,CAACxC,CAAD;OAHZ;MAKAkB,cAAc,CAACyB,IAAf,CAAoB;QACnBkD,EAAE,EAAE,SADe;cAEnBD,IAFmB;QAGnBlI,KAAK,EAAEW,IAAI,CAAC2B,CAAD;OAHZ;;;MAQI8F,YAAY,GAAG/E,OAAO,CAACd,MAA7B,CAxCuE;;OA2ClE,IAAI0D,GAAC,GAAGgC,GAAG,GAAGF,KAAN,GAAc,CAA3B,EAA8B9B,GAAC,IAAIgC,GAAnC,EAAwC,EAAEhC,GAA1C,EAA6C;QACtCoC,MAAI,GAAGV,QAAQ,CAACvG,MAAT,CAAgB,CAAC6E,GAAD,CAAhB,CAAb;IACA5C,OAAO,CAAC+E,YAAY,GAAGnC,GAAf,GAAmBgC,GAApB,CAAP,GAAkC;MACjCE,EAAE,EAAE,KAD6B;YAEjCE,MAFiC;MAGjCrI,KAAK,EAAE8E,IAAI,CAACmB,GAAD;KAHZ;IAKAzC,cAAc,CAACyB,IAAf,CAAoB;MACnBkD,EAAE,EAAE,QADe;YAEnBE;KAFD;;;AAOF,SAASR,qBAATA,CAA+BnD,KAA/B,EAAsCiD,QAAtC,EAAgDtE,OAAhD,EAAyDG,cAAzD,EAAyE;;EAC3D,IAAAsB,IAAA,GAAAJ,KAAA,CAAAI,IAAA;EACb1C,IAAI,CAACsC,KAAK,CAACG,QAAP,YAAkB/D,GAAD,EAAMwH,aAAN;QACdC,SAAS,GAAG5H,IAAI,CAACG,GAAD,CAAtB;QACMd,KAAK,GAAG8E,IAAI,CAAChE,GAAD,CAAlB;QACMqH,EAAE,GAAG,CAACG,aAAD,GAAiB,QAAjB,GAA4BxH,GAAG,IAAIH,IAAP,GAAc,SAAd,GAA0B,KAAjE;QACI4H,SAAS,KAAKvI,KAAd,IAAuBmI,EAAE,KAAK,SAAlC;MAA6C;IAAA;QACvCD,IAAI,GAAGP,QAAQ,CAACvG,MAAT,CAAgBN,GAAhB,CAAb;IACAuC,OAAO,CAAC4B,IAAR,CAAakD,EAAE,KAAK,QAAP,GAAkB;UAACA,EAAD;YAAKD;KAAvB,GAA+B;UAACC,EAAD;YAAKD,IAAL;aAAWlI;KAAvD;IACAwD,cAAc,CAACyB,IAAf,CACCkD,EAAE,KAAK,KAAP,GACG;MAACA,EAAE,EAAE,QAAL;YAAeD;KADlB,GAEGC,EAAE,KAAK,QAAP,GACA;MAACA,EAAE,EAAE,KAAL;YAAYD,IAAZ;MAAkBlI,KAAK,EAAEuI;KADzB,GAEA;MAACJ,EAAE,EAAE,SAAL;YAAgBD,IAAhB;MAAsBlI,KAAK,EAAEuI;KALjC;GAPG,CAAJ;;AAiBD,IAAaC,YAAY,YAAAA,CAAI1E,KAAD,EAAQT,OAAR;OACtB,IAAA4C,GAAA,MAAAwC,IAAA,GAAepF,OAAA,EAAA4C,GAAA,GAAAwC,IAAA,CAAAlG,MAAA,EAAA0D,GAAA,KAApB,EAA6B;IAAxB,IAAMyC,KAAA,GAAAD,IAAA,CAAAxC,GAAA;;IACG,IAAAkC,EAAA,GAAAO,KAAA,CAAAP,EAAA;QACPnI,KAAK,GAAGwB,KAAK,CAACkH,KAAK,CAAC1I,KAAP,CAAnB,CAF4B;;QAIxB,CAACkI,IAAI,CAAC3F,MAAV;MAAkB,MAAM,IAAIT,KAAJ,CAAU,eAAV,CAAN;IAAA;QAEdnB,IAAI,GAAGmD,KAAX;SACK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4F,IAAI,CAAC3F,MAAL,GAAc,CAAlC,EAAqCD,CAAC,EAAtC,EAA0C;MACzC3B,IAAI,GAAGA,IAAI,CAACuH,IAAI,CAAC5F,CAAD,CAAL,CAAX;UACI,CAAC3B,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B;QACC,MAAM,IAAImB,KAAJ,CAAU,+CAA+CoG,IAAI,CAACS,IAAL,CAAU,GAAV,CAAzD,CAAN;MAAA,CAHwC;;QAMpC7H,GAAG,GAAGoH,IAAI,CAACA,IAAI,CAAC3F,MAAL,GAAc,CAAf,CAAhB;YACQ4F,EAAR;WACM,SAAL;;;;QAICxH,IAAI,CAACG,GAAD,CAAJ,GAAYd,KAAZ;;WAEI,KAAL;YACKI,KAAK,CAACC,OAAN,CAAcM,IAAd,CAAJ,EAAyB;;UAExBA,IAAI,CAACiI,MAAL,CAAY9H,GAAZ,EAAiB,CAAjB,EAAoBd,KAApB;SAFD,MAGO;UACNW,IAAI,CAACG,GAAD,CAAJ,GAAYd,KAAZ;;;WAGG,QAAL;YACKI,KAAK,CAACC,OAAN,CAAcM,IAAd,CAAJ,EAAyB;UACxBA,IAAI,CAACiI,MAAL,CAAY9H,GAAZ,EAAiB,CAAjB;SADD,MAEO;iBACCH,IAAI,CAACG,GAAD,CAAX;;;;cAIK,IAAIgB,KAAJ,CAAU,kCAAkCqG,EAA5C,CAAN;;;SAIIrE,KAAP;CA1CM;ACpEP,SAAS+E,cAATA,CAAA,EAA0B;AAE1B,IAAMC,cAAc,GAAG;EACtBC,UAAU,EAAE,OAAOvC,KAAP,KAAiB,WAAjB,IAAgC,OAAOvF,OAAP,KAAmB,WADzC;EAEtB+H,UAAU,EACT,OAAOC,OAAP,KAAmB,WAAnB,GACGA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAD5B,GAEGN,cAAc,CAACO,IAAf,KAAwB,gBALN;EAMtBC,QAAQ,EAAE,IANY;EAOtBC,QAAQ,EAAE,IAPY;EAQtBC,MAAM,EAAE;CART;AAWA,IAAaC,KAAN,GACN,SAAAA,KAAWrJ,CAACsJ,MAAD,EAAS;QACb,CAAC,IAAD,EAAOX,cAAP,EAAuBW,MAAvB,CAAN;OACKC,aAAL,CAAmB,KAAKX,UAAxB;OACKY,OAAL,GAAe,KAAKA,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CAAf;;AAEDJ,KAAA,CAAA/I,SAAA,CAAAkJ,OAAA,YAAAA,QAAQhJ,IAAD,EAAOkJ,MAAP,EAAetG,aAAf,EAA8B;;;;MAEhC,OAAO5C,IAAP,KAAgB,UAAhB,IAA8B,OAAOkJ,MAAP,KAAkB,UAApD,EAAgE;QACzDC,WAAW,GAAGD,MAApB;UACM,GAAGlJ,IAAT;QAEMoJ,IAAI,GAAG,IAAb;WACO,SAASC,cAATA,CAAwBrJ,IAAI,EAAyB;;+BAAzB,GAAGmJ,WAAA;;;;aAC9BC,IAAI,CAACJ,OAAL,CAAahJ,IAAb,YAAmBmD,KAAA;QAAA,OAAS+F,MAAM,CAAC9H,IAAA,CAAAoF,KAAP,CAAA0C,MAAA,GAAYI,MAAZ,EAAkBnG,KAAlB,EAAA1C,MAAA,CAA4B8I,IAAA,CAA5B;MAAA,CAA5B,CAAP,CAD2D;KAA5D;GAPmC;;;QAc/B,OAAOL,MAAP,KAAkB,UAAtB,EAAkC;YAC3B,IAAI/H,KAAJ,CAAU,8DAAV,CAAN;;QAEGyB,aAAa,KAAKyC,SAAlB,IAA+B,OAAOzC,aAAP,KAAyB,UAA5D,EAAwE;YACjE,IAAIzB,KAAJ,CAAU,iEAAV,CAAN;;;MAIEoC,MAAJ,CAtBoC;;MAyBhCjE,WAAW,CAACU,IAAD,CAAf,EAAuB;QAChBsD,KAAK,GAAGhB,UAAU,CAACY,KAAX,EAAd;QACMgD,KAAK,GAAG,KAAKtC,WAAL,CAAiB5D,IAAjB,CAAd;QACIwJ,QAAQ,GAAG,IAAf;QACI;MACHjG,MAAM,GAAG2F,MAAM,CAAChD,KAAD,CAAf;cACQ,GAAG,KAAX;KAFD,SAGU;;UAELsD,QAAJ;QAAclG,KAAK,CAACR,MAAN;MAAA,CAAd;QACKQ,KAAK,CAACN,KAAN;MAAA;;QAEFO,MAAM,YAAYkG,OAAtB,EAA+B;aACvBlG,MAAM,CAACmG,IAAP,WACNnG,MAAA;QACCD,KAAK,CAACX,UAAN,CAAiBC,aAAjB;eACO0G,MAAA,CAAKK,aAAL,CAAmBpG,MAAnB,EAA2BD,KAA3B,CAAP;OAHK,YAKNsG,KAAA;QACCtG,KAAK,CAACR,MAAN;cACM8G,KAAN;OAPK,CAAP;;IAWDtG,KAAK,CAACX,UAAN,CAAiBC,aAAjB;WACO,KAAK+G,aAAL,CAAmBpG,MAAnB,EAA2BD,KAA3B,CAAP;GAzBD,MA0BO;IACNC,MAAM,GAAG2F,MAAM,CAAClJ,IAAD,CAAf;QACIuD,MAAM,KAAK8B,SAAf;MAA0B,OAAOrF,IAAP;IAAA;WACnBuD,MAAM,KAAKzE,OAAX,GAAqByE,MAArB,GAA8B8B,SAArC;;;AAGFwD,KAAA,CAAA/I,SAAA,CAAA+J,kBAAA,YAAAA,mBAAmBC,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmB;;MAChC,OAAOF,IAAP,KAAgB,UAApB,EAAgC;qBAEvB/F,KAAD;;;;aACNuF,MAAA,CAAKO,kBAAL,CAAwB9F,KAAxB,YAA+BZ,KAAA;QAAA,OAAS2G,IAAA,CAAAtD,KAAI,UAACrD,KAAD,EAAA1C,MAAA,CAAW8I,IAAA,CAAX;MAAA,CAA5C;KADD;GAHmC;;MAOhCS,IAAJ;IACC,MAAM,IAAI7I,KAAJ,CAAU,yDAAV,CAAN;EAAA;MACGuB,OAAJ,EAAaG,cAAb;MACMoH,SAAS,GAAG,KAAKjB,OAAL,CAAac,IAAb,EAAmBC,IAAnB,YAA0BG,CAAD,EAAIC,EAAJ;WACnC,GAAGD,CAAV;kBACc,GAAGC,EAAjB;GAFiB,CAAlB;SAIO,CAACF,SAAD,EAAYvH,OAAZ,EAAqBG,cAArB,CAAP;;AAEDgG,KAAA,CAAA/I,SAAA,CAAAsK,WAAA,YAAAA,YAAYpK,IAAD,EAAO;MACb,CAACV,WAAW,CAACU,IAAD,CAAhB,EAAwB;UACjB,IAAImB,KAAJ,CAAU,0FAAV,CAAN,CADuB;;MAGlBmC,KAAK,GAAGhB,UAAU,CAACY,KAAX,EAAd;MACMgD,KAAK,GAAG,KAAKtC,WAAL,CAAiB5D,IAAjB,CAAd;OACK,CAACb,WAAD,CAAL,CAAmBkL,QAAnB,GAA8B,IAA9B;EACA/G,KAAK,CAACN,KAAN;SACOkD,KAAP;;AAED2C,KAAA,CAAA/I,SAAA,CAAAwK,WAAA,YAAAA,YAAYnH,KAAD,EAAQP,aAAR,EAAuB;MAC3BmB,KAAK,GAAGZ,KAAK,IAAIA,KAAK,CAAChE,WAAD,CAA5B;MACI,CAAC4E,KAAD,IAAU,CAACA,KAAK,CAACsG,QAArB,EAA+B;UACxB,IAAIlJ,KAAJ,CAAU,2EAAV,CAAN,CAD8B;;MAG3B4C,KAAK,CAACE,SAAV,EAAqB;UACd,IAAI9C,KAAJ,CAAU,sCAAV,CAAN,CADoB;;EAGd,IAAAmC,KAAA,GAAAS,KAAA,CAAAT,KAAA;EACPA,KAAK,CAACX,UAAN,CAAiBC,aAAjB;SACO,KAAK+G,aAAL,CAAmBtE,SAAnB,EAA8B/B,KAA9B,CAAP;;AAEDuF,KAAA,CAAA/I,SAAA,CAAAyK,aAAA,YAAAA,cAAclL,KAAD,EAAQ;OACfgJ,UAAL,GAAkBhJ,KAAlB;;AAEDwJ,KAAA,CAAA/I,SAAA,CAAAiJ,aAAA,YAAAA,cAAc1J,KAAD,EAAQ;OACf+I,UAAL,GAAkB/I,KAAlB;QACM,CAAC,IAAD,EAAOA,KAAK,GAAGmL,WAAH,GAAiBC,WAA7B,CAAN;;AAED5B,KAAA,CAAA/I,SAAA,CAAA+H,YAAA,YAAA6C,eAAa1K,IAAD,EAAO0C,OAAP,EAAgB;;;MAGvBf,CAAJ;OACKA,CAAC,GAAGe,OAAO,CAACd,MAAR,GAAiB,CAA1B,EAA6BD,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;QACnCoG,KAAK,GAAGrF,OAAO,CAACf,CAAD,CAArB;QACIoG,KAAK,CAACR,IAAN,CAAW3F,MAAX,KAAsB,CAAtB,IAA2BmG,KAAK,CAACP,EAAN,KAAa,SAA5C,EAAuD;MACtDxH,IAAI,GAAG+H,KAAK,CAAC1I,KAAb;;;;MAKED,OAAO,CAACY,IAAD,CAAX,EAAmB;;WAEX6H,YAAY,CAAC7H,IAAD,EAAO0C,OAAP,CAAnB;GAd0B;;SAiBpB,KAAKsG,OAAL,CAAahJ,IAAb,YAAmBmD,KAAA;IAAA,OACzB0E,YAAY,CAAC1E,KAAD,EAAQT,OAAO,CAAC9B,KAAR,CAAce,CAAC,GAAG,CAAlB,CAAR;EAAA,CADN,CAAP;;;;AAKDkH,KAAA,CAAA/I,SAAA,CAAA6J,aAAA,YAAAA,cAAcpG,MAAD,EAASD,KAAT,EAAgB;MACtBqH,SAAS,GAAGrH,KAAK,CAACd,MAAN,CAAa,CAAb,CAAlB;MACMgB,UAAU,GAAGD,MAAM,KAAK8B,SAAX,IAAwB9B,MAAM,KAAKoH,SAAtD;OACKtH,YAAL,CAAkBC,KAAlB,EAAyBC,MAAzB,EAAiCC,UAAjC;MACIA,UAAJ,EAAgB;QACXmH,SAAS,CAACxL,WAAD,CAAT,CAAuB6E,QAA3B,EAAqC;MACpCV,KAAK,CAACR,MAAN;YACM,IAAI3B,KAAJ,CAAU,mHAAV,CAAN,CAFoC;;QAIjC7B,WAAW,CAACiE,MAAD,CAAf,EAAyB;;MAExBA,MAAM,GAAG,KAAKqH,QAAL,CAAcrH,MAAd,EAAsB,IAAtB,EAA4BD,KAA5B,CAAT;;QAEGA,KAAK,CAACZ,OAAV,EAAmB;MAClBY,KAAK,CAACZ,OAAN,CAAc4B,IAAd,CAAmB;UAChB,EAAE,SADc;YAEd,EAAE,EAFY;aAGb,EAAEf;OAHR;MAKAD,KAAK,CAACT,cAAN,CAAqByB,IAArB,CAA0B;UACvB,EAAE,SADqB;YAErB,EAAE,EAFmB;QAGzBjF,KAAK,EAAEsL,SAAS,CAACxL,WAAD,CAAT,CAAuBa;OAH/B;;GAfF,MAqBO;;IAENuD,MAAM,GAAG,KAAKqH,QAAL,CAAcD,SAAd,EAAyB,EAAzB,EAA6BrH,KAA7B,CAAT;;EAEDA,KAAK,CAACR,MAAN;MACIQ,KAAK,CAACZ,OAAV,EAAmB;IAClBY,KAAK,CAACV,aAAN,CAAoBU,KAAK,CAACZ,OAA1B,EAAmCY,KAAK,CAACT,cAAzC;;SAEMU,MAAM,KAAKzE,OAAX,GAAqByE,MAArB,GAA8B8B,SAArC;;;;;;;;AAODwD,KAAA,CAAA/I,SAAA,CAAA8K,QAAA,YAAAA,SAASzH,KAAD,EAAQoE,IAAR,EAAcjE,KAAd,EAAqB;;MACtBS,KAAK,GAAGZ,KAAK,CAAChE,WAAD,CAAnB;MACI,CAAC4E,KAAL,EAAY;QACPnE,MAAM,CAACiL,QAAP,CAAgB1H,KAAhB,CAAJ;MAA4B,OAAOA,KAAP;IAAA;WACrB,KAAK2H,YAAL,CAAkB3H,KAAlB,EAAyB,IAAzB,EAA+BG,KAA/B,CAAP;GAJ2B;;MAOxBS,KAAK,CAACT,KAAN,KAAgBA,KAApB,EAA2B;WACnBH,KAAP;;MAEG,CAACY,KAAK,CAACC,QAAX,EAAqB;WACbD,KAAK,CAAC/D,IAAb;;MAEG,CAAC+D,KAAK,CAACE,SAAX,EAAsB;IACrBF,KAAK,CAACE,SAAN,GAAkB,IAAlB;SACK6G,YAAL,CAAkB/G,KAAK,CAACZ,KAAxB,EAA+BoE,IAA/B,EAAqCjE,KAArC;QAEI,KAAKqF,QAAT,EAAmB;;UAEd,KAAKP,UAAT,EAAqB;QACb,IAAAlE,QAAA,GAAAH,KAAA,CAAAG,QAAA;aACF,IAAMpC,IAAX,IAAmBoC,QAAnB,EAA6B;cACxB,CAACA,QAAQ,CAACpC,IAAD,CAAb;YAAqB,KAAK6G,QAAL,CAAc5E,KAAd,EAAqBjC,IAArB;UAAA;;OAHvB,MAKO;;QACO,IAAAqC,IAAA,GAAAJ,KAAA,CAAAI,IAAA;QACb1C,IAAI,CAACzB,IAAD,YAAO8B,IAAA;cACN,CAAC1B,GAAG,CAAC+D,IAAD,EAAOrC,IAAP,CAAR;YAAsBwH,MAAA,CAAKX,QAAL,CAAc5E,KAAd,EAAqBjC,IAArB;UAAA;SADnB,CAAJ;;;QAKE,KAAK8G,MAAT,EAAiB;WACXA,MAAL,CAAY7E,KAAZ;KAnBoB;;;QAwBjB,KAAKsE,UAAL,IAAmB/E,KAAK,CAACb,aAA7B,EAA4C;YACrC,CAACsI,MAAP,CAAchH,KAAK,CAACI,IAApB;;QAGGoD,IAAI,IAAIjE,KAAK,CAACZ,OAAlB,EAA2B;MAC1BqE,eAAe,CAAChD,KAAD,EAAQwD,IAAR,EAAcjE,KAAK,CAACZ,OAApB,EAA6BY,KAAK,CAACT,cAAnC,CAAf;;;SAGKkB,KAAK,CAACI,IAAb;;;;;;;AAMD0E,KAAA,CAAA/I,SAAA,CAAAgL,YAAA,YAAAA,aAAaE,IAAD,EAAOC,QAAP,EAAiB3H,KAAjB,EAAwB;;MAC7BS,KAAK,GAAGiH,IAAI,CAAC7L,WAAD,CAAlB;MACI4E,KAAJ,EAAW;QACN,CAAC,KAAKqE,UAAV,EAAsB;;MAErBrE,KAAK,CAACI,IAAN,GAAazD,WAAW,CAACqD,KAAK,CAACZ,KAAP,EAAc,IAAd,CAAxB;;IAED6H,IAAI,GAAGjH,KAAK,CAACI,IAAb;;MAGK+G,WAAW,GAAG,CAAC,CAACD,QAAF,IAAc,CAAC,CAAC3H,KAAK,CAACZ,OAA1C;MACMyI,gBAAgB,YAAAA,CAAIrJ,IAAD,EAAOzC,KAAP,EAAckD,MAAd;QACpBlD,KAAK,KAAKkD,MAAd,EAAsB;YACfpB,KAAK,CAAC,mCAAD,CAAX;KAFgD;;QAM3CiK,WAAW,GAAG,CAAC,CAACrH,KAAF,IAAWxB,MAAM,KAAKyI,IAA1C;QAEI5L,OAAO,CAACC,KAAD,CAAX,EAAoB;UACbkI,IAAI,GACT6D,WAAW,IAAIF,WAAf,IAA8B,CAACnH,KAAK,CAACG,QAAN,CAAepC,IAAf,CAA/B,GACGmJ,QAAQ,CAACxK,MAAT,CAAgBqB,IAAhB,CADH,GAEG,IAHJ,CADmB;;MAOnBzC,KAAK,GAAGiK,MAAA,CAAKsB,QAAL,CAAcvL,KAAd,EAAqBkI,IAArB,EAA2BjE,KAA3B,CAAR,CAPmB;;UAUflE,OAAO,CAACC,KAAD,CAAX,EAAoB;QACnBiE,KAAK,CAACb,aAAN,GAAsB,KAAtB;OAXkB;;UAefhD,KAAK,CAACC,OAAN,CAAc6C,MAAd,KAAyBV,YAAY,CAACU,MAAD,EAAST,IAAT,CAAzC,EAAyD;QACxDS,MAAM,CAACT,IAAD,CAAN,GAAezC,KAAf;OADD,MAEO;QACNO,MAAM,CAAC0B,cAAP,CAAsBiB,MAAtB,EAA8BT,IAA9B,EAAoC;iBAACzC;SAArC;OAlBkB;;UAsBf+L,WAAW,IAAI/L,KAAK,KAAK0E,KAAK,CAAC/D,IAAN,CAAW8B,IAAX,CAA7B;QAA+C;MAAA;KAtBhD;IAAA,KAyBK,IAAIsJ,WAAW,IAAInJ,EAAE,CAAC5C,KAAD,EAAQ0E,KAAK,CAAC/D,IAAN,CAAW8B,IAAX,CAAR,CAArB,EAAgD;;KAAhD;IAAA,KAIA,IAAIxC,WAAW,CAACD,KAAD,CAAX,IAAsB,CAACO,MAAM,CAACiL,QAAP,CAAgBxL,KAAhB,CAA3B,EAAmD;MACvDoC,IAAI,CAACpC,KAAD,EAAQ8L,gBAAR,CAAJ;;QAGGC,WAAW,IAAI9B,MAAA,CAAKZ,QAAxB,EAAkC;aAC5BA,QAAL,CAAc3E,KAAd,EAAqBjC,IAArB,EAA2BzC,KAA3B;;GA1CF;EA8CAoC,IAAI,CAACuJ,IAAD,EAAOG,gBAAP,CAAJ;SACOH,IAAP;;ACnTF,IAAMK,KAAK,GAAG,IAAIxC,KAAJ,EAAd;;;;;;;;;;;;;;;;;;;;;AAqBA,IAAaG,OAAO,GAAGqC,KAAK,CAACrC,OAAtB;AACP;;;;;AAMA,IAAaa,kBAAkB,GAAGwB,KAAK,CAACxB,kBAAN,CAAyBZ,IAAzB,CAA8BoC,KAA9B,CAA3B;;;;;;;AAOP,IAAad,aAAa,GAAGc,KAAK,CAACd,aAAN,CAAoBtB,IAApB,CAAyBoC,KAAzB,CAAtB;;;;;;;;AAQP,IAAatC,aAAa,GAAGsC,KAAK,CAACtC,aAAN,CAAoBE,IAApB,CAAyBoC,KAAzB,CAAtB;;;;;;;AAOP,IAAaX,cAAY,GAAGW,KAAK,CAACxD,YAAN,CAAmBoB,IAAnB,CAAwBoC,KAAxB,CAArB;;;;;;AAMP,IAAajB,WAAW,GAAGiB,KAAK,CAACjB,WAAN,CAAkBnB,IAAlB,CAAuBoC,KAAvB,CAApB;;;;;;;;;;AAUP,IAAaf,WAAW,GAAGe,KAAK,CAACf,WAAN,CAAkBrB,IAAlB,CAAuBoC,KAAvB,CAApB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}