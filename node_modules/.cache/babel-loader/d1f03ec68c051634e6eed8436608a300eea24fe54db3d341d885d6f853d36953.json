{"ast":null,"code":"/*!\n * vwo-fme-javascript-sdk - v1.6.0\n * URL - https://github.com/wingify/vwo-node-sdk\n *\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Dependencies used -\n *  1. murmurhash - ^2.0.1\n *  2. superstruct - ^0.14.x\n *  3. uuid - ^9.0.1\n *  4. vwo-fme-sdk-log-messages - ^0.1.2\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.vwoSdk = t() : e.vwoSdk = t();\n}(this, () => (() => {\n  var e = {\n      8005: e => {\n        !function () {\n          const t = e => new TextEncoder().encode(e);\n          function n(e, n) {\n            let r, o, i, a, s, u, c, l;\n            for (\"string\" == typeof e && (e = t(e)), r = 3 & e.length, o = e.length - r, i = n, s = 3432918353, u = 461845907, l = 0; l < o;) c = 255 & e[l] | (255 & e[++l]) << 8 | (255 & e[++l]) << 16 | (255 & e[++l]) << 24, ++l, c = (65535 & c) * s + (((c >>> 16) * s & 65535) << 16) & 4294967295, c = c << 15 | c >>> 17, c = (65535 & c) * u + (((c >>> 16) * u & 65535) << 16) & 4294967295, i ^= c, i = i << 13 | i >>> 19, a = 5 * (65535 & i) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295, i = 27492 + (65535 & a) + ((58964 + (a >>> 16) & 65535) << 16);\n            switch (c = 0, r) {\n              case 3:\n                c ^= (255 & e[l + 2]) << 16;\n              case 2:\n                c ^= (255 & e[l + 1]) << 8;\n              case 1:\n                c ^= 255 & e[l], c = (65535 & c) * s + (((c >>> 16) * s & 65535) << 16) & 4294967295, c = c << 15 | c >>> 17, c = (65535 & c) * u + (((c >>> 16) * u & 65535) << 16) & 4294967295, i ^= c;\n            }\n            return i ^= e.length, i ^= i >>> 16, i = 2246822507 * (65535 & i) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i ^= i >>> 13, i = 3266489909 * (65535 & i) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, i ^= i >>> 16, i >>> 0;\n          }\n          const r = n;\n          r.v2 = function (e, n) {\n            \"string\" == typeof e && (e = t(e));\n            let r,\n              o = e.length,\n              i = n ^ o,\n              a = 0;\n            for (; o >= 4;) r = 255 & e[a] | (255 & e[++a]) << 8 | (255 & e[++a]) << 16 | (255 & e[++a]) << 24, r = 1540483477 * (65535 & r) + ((1540483477 * (r >>> 16) & 65535) << 16), r ^= r >>> 24, r = 1540483477 * (65535 & r) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ r, o -= 4, ++a;\n            switch (o) {\n              case 3:\n                i ^= (255 & e[a + 2]) << 16;\n              case 2:\n                i ^= (255 & e[a + 1]) << 8;\n              case 1:\n                i ^= 255 & e[a], i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16);\n            }\n            return i ^= i >>> 13, i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16), i ^= i >>> 15, i >>> 0;\n          }, r.v3 = n, e.exports = r;\n        }();\n      },\n      9709: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.onInit = t.init = t.VWO = void 0;\n        var i = n(9426),\n          a = n(1359),\n          s = n(4782),\n          u = n(7128),\n          c = n(8754),\n          l = n(5520),\n          g = function () {\n            function e(t) {\n              return e.setInstance(t);\n            }\n            return e.setInstance = function (e) {\n              var t = this,\n                n = null == e ? void 0 : e.vwoBuilder;\n              return this.vwoBuilder = n || new i.VWOBuilder(e), this.instance = this.vwoBuilder.setLogger().setSettingsService().setStorage().setNetworkManager().setSegmentation().initPolling(), this.vwoBuilder.getSettings().then(function (e) {\n                return t.vwoBuilder.build(e);\n              });\n            }, Object.defineProperty(e, \"Instance\", {\n              get: function () {\n                return this.instance;\n              },\n              enumerable: !1,\n              configurable: !0\n            }), e;\n          }();\n        t.VWO = g;\n        var d = {};\n        t.init = function (e) {\n          return r(this, void 0, void 0, function () {\n            var t, n, r;\n            return o(this, function (o) {\n              t = new Date().toISOString();\n              try {\n                return (0, a.isObject)(e) || (r = (0, c.buildMessage)(u.ErrorLogMessagesEnum.INIT_OPTIONS_ERROR, {\n                  date: t\n                }), console.error(r)), (null == e ? void 0 : e.sdkKey) && (0, a.isString)(null == e ? void 0 : e.sdkKey) || (r = (0, c.buildMessage)(u.ErrorLogMessagesEnum.INIT_OPTIONS_SDK_KEY_ERROR, {\n                  date: t\n                }), console.error(r)), e.accountId || (r = (0, c.buildMessage)(u.ErrorLogMessagesEnum.INIT_OPTIONS_ACCOUNT_ID_ERROR, {\n                  date: t\n                }), console.error(r)), e.platform = l.PlatformEnum.CLIENT, n = new g(e), d = {\n                  vwoInitDeferred: new s.Deferred(),\n                  isSettingsFetched: !1,\n                  instance: null\n                }, [2, n.then(function (e) {\n                  return d.isSettingsFetched = !0, d.instance = e, d.vwoInitDeferred.resolve(e), e;\n                })];\n              } catch (e) {\n                r = (0, c.buildMessage)(u.ErrorLogMessagesEnum.API_THROW_ERROR, {\n                  apiName: \"init\",\n                  err: e\n                }), console.info(\"[INFO]: VWO-SDK \".concat(new Date().toISOString(), \" \").concat(r));\n              }\n              return [2];\n            });\n          });\n        }, t.onInit = function () {\n          return r(this, void 0, void 0, function () {\n            var e, t, n;\n            return o(this, function (r) {\n              e = \"onInit\";\n              try {\n                return d.vwoInitDeferred = new s.Deferred(), t = new Date().toISOString(), d.isSettingsFetched ? (n = (0, c.buildMessage)(u.InfoLogMessagesEnum.ON_INIT_ALREADY_RESOLVED, {\n                  date: t,\n                  apiName: e\n                }), console.info(n), d.vwoInitDeferred.resolve(d.instance)) : setTimeout(function () {\n                  if (!d.isSettingsFetched) {\n                    var e = (0, c.buildMessage)(u.InfoLogMessagesEnum.ON_INIT_SETTINGS_FAILED, {\n                      date: t\n                    });\n                    console.error(e), d.vwoInitDeferred.reject(new Error(\"VWO settings could not be fetched\"));\n                  }\n                }, 5e3), [2, d.vwoInitDeferred.promise];\n              } catch (t) {\n                n = (0, c.buildMessage)(u.ErrorLogMessagesEnum.API_THROW_ERROR, {\n                  apiName: e,\n                  err: t\n                }), console.info(\"[INFO]: VWO-SDK \".concat(new Date().toISOString(), \" \").concat(n));\n              }\n              return [2];\n            });\n          });\n        };\n      },\n      9426: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.VWOBuilder = void 0;\n        var r = n(4580),\n          o = n(6710),\n          i = n(4986),\n          a = n(9401),\n          s = n(1522),\n          u = n(470),\n          c = n(7128),\n          l = n(1359),\n          g = n(8667),\n          d = n(8754),\n          p = n(4782),\n          f = n(362),\n          h = n(1720),\n          v = function () {\n            function e(e) {\n              this.options = e;\n            }\n            return e.prototype.setNetworkManager = function () {\n              var e,\n                t,\n                n,\n                i = o.NetworkManager.Instance;\n              return i.attachClient(null === (t = null === (e = this.options) || void 0 === e ? void 0 : e.network) || void 0 === t ? void 0 : t.client), r.LogManager.Instance.debug((0, d.buildMessage)(c.DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n                service: \"Network Layer\"\n              })), i.getConfig().setDevelopmentMode(null === (n = this.options) || void 0 === n ? void 0 : n.isDevelopmentMode), this;\n            }, e.prototype.setSegmentation = function () {\n              var e;\n              return i.SegmentationManager.Instance.attachEvaluator(null === (e = this.options) || void 0 === e ? void 0 : e.segmentation), r.LogManager.Instance.debug((0, d.buildMessage)(c.DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n                service: \"Segmentation Evaluator\"\n              })), this;\n            }, e.prototype.fetchSettings = function (e) {\n              var t = this,\n                n = new p.Deferred();\n              return this.isSettingsFetchInProgress ? this.fetchSettings(e) : (this.isSettingsFetchInProgress = !0, this.settingFileManager.getSettings(e).then(function (r) {\n                e || (t.originalSettings = r), t.isSettingsFetchInProgress = !1, n.resolve(r);\n              }), n.promise);\n            }, e.prototype.getSettings = function (e) {\n              var t = new p.Deferred();\n              try {\n                !e && this.settings ? (r.LogManager.Instance.info(\"Using already fetched and cached settings\"), t.resolve(this.settings)) : this.fetchSettings(e).then(function (e) {\n                  t.resolve(e);\n                });\n              } catch (e) {\n                r.LogManager.Instance.error(\"Failed to fetch settings. Error: \" + e), t.resolve({});\n              }\n              return t.promise;\n            }, e.prototype.setStorage = function () {\n              return this.options.storage ? this.storage = a.Storage.Instance.attachConnector(this.options.storage) : this.storage = null, this;\n            }, e.prototype.setSettingsService = function () {\n              return this.settingFileManager = new u.SettingsService(this.options), this;\n            }, e.prototype.setLogger = function () {\n              return this.logManager = new r.LogManager(this.options.logger || {}), r.LogManager.Instance.debug((0, d.buildMessage)(c.DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n                service: \"Logger\"\n              })), this;\n            }, e.prototype.getRandomUserId = function () {\n              var e = \"getRandomUserId\";\n              try {\n                return r.LogManager.Instance.debug((0, d.buildMessage)(c.DebugLogMessagesEnum.API_CALLED, {\n                  apiName: e\n                })), (0, h.getRandomUUID)(this.options.sdkKey);\n              } catch (t) {\n                r.LogManager.Instance.error((0, d.buildMessage)(c.ErrorLogMessagesEnum.API_THROW_ERROR, {\n                  apiName: e,\n                  err: t\n                }));\n              }\n            }, e.prototype.initPolling = function () {\n              return this.options.pollInterval ? this.options.pollInterval && !(0, l.isNumber)(this.options.pollInterval) || this.options.pollInterval && this.options.pollInterval < 1e3 ? (r.LogManager.Instance.error((0, d.buildMessage)(c.ErrorLogMessagesEnum.INIT_OPTIONS_INVALID, {\n                key: \"pollInterval\",\n                correctType: \"number\"\n              })), this) : (this.checkAndPoll(), this) : this;\n            }, e.prototype.build = function (e) {\n              return this.vwoInstance = new s.VWOClient(e, this.options), this.vwoInstance;\n            }, e.prototype.checkAndPoll = function () {\n              var e = this,\n                t = this.options.pollInterval;\n              setInterval(function () {\n                e.getSettings(!0).then(function (t) {\n                  var n = JSON.stringify(e.originalSettings);\n                  if (JSON.stringify(t) !== n) {\n                    e.originalSettings = t;\n                    var o = (0, g.cloneObject)(t);\n                    r.LogManager.Instance.info(c.InfoLogMessagesEnum.POLLING_SET_SETTINGS), (0, f.setSettingsAndAddCampaignsToRules)(o, e.vwoInstance);\n                  } else r.LogManager.Instance.info(c.InfoLogMessagesEnum.POLLING_NO_CHANGE_IN_SETTINGS);\n                }).catch(function () {\n                  r.LogManager.Instance.error(c.ErrorLogMessagesEnum.POLLING_FETCH_SETTINGS_FAILED);\n                });\n              }, t);\n            }, e;\n          }();\n        t.VWOBuilder = v;\n      },\n      1522: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.VWOClient = void 0;\n        var i = n(4580),\n          a = n(6612),\n          s = n(8164),\n          u = n(977),\n          c = n(7128),\n          l = n(9846),\n          g = n(9752),\n          d = n(7675),\n          p = n(8694),\n          f = n(1359),\n          h = n(8754),\n          v = n(4782),\n          y = n(362),\n          m = n(8925),\n          E = function () {\n            function e(e, t) {\n              return this.options = t, (0, y.setSettingsAndAddCampaignsToRules)(e, this), p.UrlUtil.init({\n                collectionPrefix: this.settings.getCollectionPrefix()\n              }), (0, m.setShouldWaitForTrackingCalls)(this.options.shouldWaitForTrackingCalls || !1), i.LogManager.Instance.info(c.InfoLogMessagesEnum.CLIENT_INITIALIZED), this;\n            }\n            return e.prototype.getFlag = function (e, t) {\n              var n = \"getFlag\",\n                r = new v.Deferred(),\n                o = {\n                  isEnabled: function () {\n                    return !1;\n                  },\n                  getVariables: function () {\n                    return [];\n                  },\n                  getVariable: function (e, t) {\n                    return t;\n                  }\n                };\n              try {\n                var s = new d.default(this.options);\n                if (i.LogManager.Instance.debug((0, h.buildMessage)(c.DebugLogMessagesEnum.API_CALLED, {\n                  apiName: n\n                })), !(0, f.isString)(e)) throw i.LogManager.Instance.error((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_INVALID_PARAM, {\n                  apiName: n,\n                  key: \"featureKey\",\n                  type: (0, f.getType)(e),\n                  correctType: \"string\"\n                })), new TypeError(\"TypeError: featureKey should be a string\");\n                if (!new l.SettingsSchema().isSettingsValid(this.originalSettings)) throw i.LogManager.Instance.error(c.ErrorLogMessagesEnum.API_SETTING_INVALID), new Error(\"TypeError: Invalid Settings\");\n                if (!t || !t.id) throw i.LogManager.Instance.error(c.ErrorLogMessagesEnum.API_CONTEXT_INVALID), new TypeError(\"TypeError: Invalid context\");\n                var u = new g.ContextModel().modelFromDictionary(t);\n                new a.FlagApi().get(e, this.settings, u, s).then(function (e) {\n                  r.resolve(e);\n                }).catch(function () {\n                  r.resolve(o);\n                });\n              } catch (e) {\n                i.LogManager.Instance.info((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_THROW_ERROR, {\n                  apiName: n,\n                  err: e\n                })), r.resolve(o);\n              }\n              return r.promise;\n            }, e.prototype.trackEvent = function (e, t, n) {\n              var r;\n              void 0 === n && (n = {});\n              var o = \"trackEvent\",\n                a = new v.Deferred();\n              try {\n                var s = new d.default(this.options);\n                if (i.LogManager.Instance.debug((0, h.buildMessage)(c.DebugLogMessagesEnum.API_CALLED, {\n                  apiName: o\n                })), !(0, f.isString)(e)) throw i.LogManager.Instance.error((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_INVALID_PARAM, {\n                  apiName: o,\n                  key: \"eventName\",\n                  type: (0, f.getType)(e),\n                  correctType: \"string\"\n                })), new TypeError(\"TypeError: Event-name should be a string\");\n                if (!(0, f.isObject)(n)) throw i.LogManager.Instance.error((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_INVALID_PARAM, {\n                  apiName: o,\n                  key: \"eventProperties\",\n                  type: (0, f.getType)(n),\n                  correctType: \"object\"\n                })), new TypeError(\"TypeError: eventProperties should be an object\");\n                if (!new l.SettingsSchema().isSettingsValid(this.originalSettings)) throw i.LogManager.Instance.error(c.ErrorLogMessagesEnum.API_SETTING_INVALID), new Error(\"TypeError: Invalid Settings\");\n                if (!t || !t.id) throw i.LogManager.Instance.error(c.ErrorLogMessagesEnum.API_CONTEXT_INVALID), new TypeError(\"TypeError: Invalid context\");\n                var p = new g.ContextModel().modelFromDictionary(t);\n                new u.TrackApi().track(this.settings, e, p, n, s).then(function (e) {\n                  a.resolve(e);\n                }).catch(function () {\n                  var t;\n                  a.resolve(((t = {})[e] = !1, t));\n                });\n              } catch (t) {\n                i.LogManager.Instance.info((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_THROW_ERROR, {\n                  apiName: o,\n                  err: t\n                })), a.resolve(((r = {})[e] = !1, r));\n              }\n              return a.promise;\n            }, e.prototype.setAttribute = function (e, t, n) {\n              return r(this, void 0, void 0, function () {\n                var r, a, u;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      r = \"setAttribute\", o.label = 1;\n                    case 1:\n                      if (o.trys.push([1, 3,, 4]), i.LogManager.Instance.debug((0, h.buildMessage)(c.DebugLogMessagesEnum.API_CALLED, {\n                        apiName: r\n                      })), !(0, f.isString)(e)) throw i.LogManager.Instance.error((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_INVALID_PARAM, {\n                        apiName: r,\n                        key: \"attributeKey\",\n                        type: (0, f.getType)(e),\n                        correctType: \"string\"\n                      })), new TypeError(\"TypeError: attributeKey should be a string\");\n                      if (!(0, f.isString)(t) && !(0, f.isNumber)(t) && !(0, f.isBoolean)(t)) throw i.LogManager.Instance.error((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_INVALID_PARAM, {\n                        apiName: r,\n                        key: \"attributeValue\",\n                        type: (0, f.getType)(t),\n                        correctType: \"boolean | string | number\"\n                      })), new TypeError(\"TypeError: attributeValue should be a string\");\n                      if (!n || !n.id) throw i.LogManager.Instance.error(c.ErrorLogMessagesEnum.API_CONTEXT_INVALID), new TypeError(\"TypeError: Invalid context\");\n                      return a = new g.ContextModel().modelFromDictionary(n), [4, new s.SetAttributeApi().setAttribute(this.settings, e, t, a)];\n                    case 2:\n                      return o.sent(), [3, 4];\n                    case 3:\n                      return u = o.sent(), i.LogManager.Instance.info((0, h.buildMessage)(c.ErrorLogMessagesEnum.API_THROW_ERROR, {\n                        apiName: r,\n                        err: u\n                      })), [3, 4];\n                    case 4:\n                      return [2];\n                  }\n                });\n              });\n            }, e;\n          }();\n        t.VWOClient = E;\n      },\n      6612: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__assign || function () {\n            return r = Object.assign || function (e) {\n              for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n              return e;\n            }, r.apply(this, arguments);\n          },\n          o = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          i = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.FlagApi = void 0;\n        var a = n(3780),\n          s = n(4237),\n          u = n(4273),\n          c = n(7128),\n          l = n(2144),\n          g = n(502),\n          d = n(4580),\n          p = n(4986),\n          f = n(8792),\n          h = n(9181),\n          v = n(1359),\n          y = n(2245),\n          m = n(8667),\n          E = n(162),\n          I = n(8754),\n          b = n(4782),\n          _ = n(6195),\n          S = n(8925),\n          T = function () {\n            function e() {}\n            return e.prototype.get = function (e, t, n, T) {\n              return o(this, void 0, void 0, function () {\n                var o, A, R, M, w, L, N, V, C, P, D, U, x, k, G, F, j, K, H, W, B, q, Q, X, Y, z, J, Z, $, ee, te, ne, re, oe, ie, ae, se, ue;\n                return i(this, function (i) {\n                  switch (i.label) {\n                    case 0:\n                      return o = !1, A = null, R = null, M = !1, w = {}, L = new b.Deferred(), N = new Map(), V = (0, m.getFeatureFromKey)(t, e), C = {\n                        featureName: null == V ? void 0 : V.getName(),\n                        featureId: null == V ? void 0 : V.getId(),\n                        featureKey: null == V ? void 0 : V.getKey(),\n                        userId: null == n ? void 0 : n.getId(),\n                        api: s.ApiEnum.GET_FLAG\n                      }, P = new f.StorageService(), [4, new a.StorageDecorator().getFeatureFromStorage(e, n, P)];\n                    case 1:\n                      if (null == (D = i.sent()) ? void 0 : D.experimentVariationId) {\n                        if (D.experimentKey && (U = (0, h.getVariationFromCampaignKey)(t, D.experimentKey, D.experimentVariationId))) return d.LogManager.Instance.info((0, I.buildMessage)(c.InfoLogMessagesEnum.STORED_VARIATION_FOUND, {\n                          variationKey: U.getKey(),\n                          userId: n.getId(),\n                          experimentType: \"experiment\",\n                          experimentKey: D.experimentKey\n                        })), L.resolve({\n                          isEnabled: function () {\n                            return !0;\n                          },\n                          getVariables: function () {\n                            return null == U ? void 0 : U.getVariables();\n                          },\n                          getVariable: function (e, t) {\n                            var n;\n                            return (null === (n = null == U ? void 0 : U.getVariables().find(function (t) {\n                              return new g.VariableModel().modelFromDictionary(t).getKey() === e;\n                            })) || void 0 === n ? void 0 : n.getValue()) || t;\n                          }\n                        }), [2, L.promise];\n                      } else (null == D ? void 0 : D.rolloutKey) && (null == D ? void 0 : D.rolloutId) && (te = (0, h.getVariationFromCampaignKey)(t, D.rolloutKey, D.rolloutVariationId)) && (d.LogManager.Instance.info((0, I.buildMessage)(c.InfoLogMessagesEnum.STORED_VARIATION_FOUND, {\n                        variationKey: te.getKey(),\n                        userId: n.getId(),\n                        experimentType: \"rollout\",\n                        experimentKey: D.rolloutKey\n                      })), d.LogManager.Instance.debug((0, I.buildMessage)(c.DebugLogMessagesEnum.EXPERIMENTS_EVALUATION_WHEN_ROLLOUT_PASSED, {\n                        userId: n.getId()\n                      })), o = !0, M = !0, A = te, x = {\n                        rolloutId: D.rolloutId,\n                        rolloutKey: D.rolloutKey,\n                        rolloutVariationId: D.rolloutVariationId\n                      }, N.set(e, x), Object.assign(w, x));\n                      return (0, v.isObject)(V) && void 0 !== V ? [4, p.SegmentationManager.Instance.setContextualData(t, V, n)] : (d.LogManager.Instance.error((0, I.buildMessage)(c.ErrorLogMessagesEnum.FEATURE_NOT_FOUND, {\n                        featureKey: e\n                      })), L.reject({}), [2, L.promise]);\n                    case 2:\n                      if (i.sent(), !((k = (0, m.getSpecificRulesBasedOnType)(V, u.CampaignTypeEnum.ROLLOUT)).length > 0) || o) return [3, 10];\n                      G = [], F = 0, j = k, i.label = 3;\n                    case 3:\n                      return F < j.length ? (Y = j[F], [4, (0, _.evaluateRule)(t, V, Y, n, N, null, P, C)]) : [3, 6];\n                    case 4:\n                      return K = i.sent(), J = K.preSegmentationResult, $ = K.updatedDecision, Object.assign(C, $), J ? (G.push(Y), N.set(e, {\n                        rolloutId: Y.getId(),\n                        rolloutKey: Y.getKey(),\n                        rolloutVariationId: null === (re = Y.getVariations()[0]) || void 0 === re ? void 0 : re.getId()\n                      }), [3, 6]) : [3, 5];\n                    case 5:\n                      return F++, [3, 3];\n                    case 6:\n                      return G.length > 0 ? (H = new l.CampaignModel().modelFromDictionary(G[0]), te = (0, y.evaluateTrafficAndGetVariation)(t, H, n.getId()), (0, v.isObject)(te) && Object.keys(te).length > 0 ? (o = !0, M = !0, A = te, O(H, te, w, C), (0, S.getShouldWaitForTrackingCalls)() ? [4, (0, E.createAndSendImpressionForVariationShown)(t, H.getId(), te.getId(), n)] : [3, 8]) : [3, 9]) : [3, 9];\n                    case 7:\n                      return i.sent(), [3, 9];\n                    case 8:\n                      (0, E.createAndSendImpressionForVariationShown)(t, H.getId(), te.getId(), n), i.label = 9;\n                    case 9:\n                      return [3, 11];\n                    case 10:\n                      0 === k.length && (d.LogManager.Instance.debug(c.DebugLogMessagesEnum.EXPERIMENTS_EVALUATION_WHEN_NO_ROLLOUT_PRESENT), M = !0), i.label = 11;\n                    case 11:\n                      if (!M) return [3, 18];\n                      W = [], B = (0, m.getAllExperimentRules)(V), q = new Map(), Q = 0, X = B, i.label = 12;\n                    case 12:\n                      return Q < X.length ? (Y = X[Q], [4, (0, _.evaluateRule)(t, V, Y, n, N, q, P, C)]) : [3, 15];\n                    case 13:\n                      return z = i.sent(), J = z.preSegmentationResult, Z = z.whitelistedObject, $ = z.updatedDecision, Object.assign(C, $), J ? (null === Z ? W.push(Y) : (o = !0, R = Z.variation, Object.assign(w, {\n                        experimentId: Y.getId(),\n                        experimentKey: Y.getKey(),\n                        experimentVariationId: Z.variationId\n                      })), [3, 15]) : [3, 14];\n                    case 14:\n                      return Q++, [3, 12];\n                    case 15:\n                      return W.length > 0 ? (ee = new l.CampaignModel().modelFromDictionary(W[0]), te = (0, y.evaluateTrafficAndGetVariation)(t, ee, n.getId()), (0, v.isObject)(te) && Object.keys(te).length > 0 ? (o = !0, R = te, O(ee, te, w, C), (0, S.getShouldWaitForTrackingCalls)() ? [4, (0, E.createAndSendImpressionForVariationShown)(t, ee.getId(), te.getId(), n)] : [3, 17]) : [3, 18]) : [3, 18];\n                    case 16:\n                      return i.sent(), [3, 18];\n                    case 17:\n                      (0, E.createAndSendImpressionForVariationShown)(t, ee.getId(), te.getId(), n), i.label = 18;\n                    case 18:\n                      return o && new a.StorageDecorator().setDataInStorage(r({\n                        featureKey: e,\n                        context: n\n                      }, w), P), T.set(C), T.execute(T.get()), (null === (oe = V.getImpactCampaign()) || void 0 === oe ? void 0 : oe.getCampaignId()) ? (d.LogManager.Instance.info((0, I.buildMessage)(c.InfoLogMessagesEnum.IMPACT_ANALYSIS, {\n                        userId: n.getId(),\n                        featureKey: e,\n                        status: o ? \"enabled\" : \"disabled\"\n                      })), (0, S.getShouldWaitForTrackingCalls)() ? [4, (0, E.createAndSendImpressionForVariationShown)(t, null === (ie = V.getImpactCampaign()) || void 0 === ie ? void 0 : ie.getCampaignId(), o ? 2 : 1, n)] : [3, 20]) : [3, 21];\n                    case 19:\n                      return i.sent(), [3, 21];\n                    case 20:\n                      (0, E.createAndSendImpressionForVariationShown)(t, null === (ae = V.getImpactCampaign()) || void 0 === ae ? void 0 : ae.getCampaignId(), o ? 2 : 1, n), i.label = 21;\n                    case 21:\n                      return ne = null !== (ue = null !== (se = null == R ? void 0 : R.variables) && void 0 !== se ? se : null == A ? void 0 : A.variables) && void 0 !== ue ? ue : [], L.resolve({\n                        isEnabled: function () {\n                          return o;\n                        },\n                        getVariables: function () {\n                          return ne;\n                        },\n                        getVariable: function (e, t) {\n                          var n,\n                            r = ne.find(function (t) {\n                              return t.key === e;\n                            });\n                          return null !== (n = null == r ? void 0 : r.value) && void 0 !== n ? n : t;\n                        }\n                      }), [2, L.promise];\n                  }\n                });\n              });\n            }, e;\n          }();\n        function O(e, t, n, r) {\n          e.getType() === u.CampaignTypeEnum.ROLLOUT ? Object.assign(n, {\n            rolloutId: e.getId(),\n            rolloutKey: e.getKey(),\n            rolloutVariationId: t.getId()\n          }) : Object.assign(n, {\n            experimentId: e.getId(),\n            experimentKey: e.getKey(),\n            experimentVariationId: t.getId()\n          }), Object.assign(r, n);\n        }\n        t.FlagApi = T;\n      },\n      8164: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SetAttributeApi = void 0;\n        var i = n(9693),\n          a = n(8925),\n          s = function () {\n            function e() {}\n            return e.prototype.setAttribute = function (e, t, n, i) {\n              return r(this, void 0, void 0, function () {\n                return o(this, function (r) {\n                  switch (r.label) {\n                    case 0:\n                      return (0, a.getShouldWaitForTrackingCalls)() ? [4, u(e, t, n, i)] : [3, 2];\n                    case 1:\n                      return r.sent(), [3, 3];\n                    case 2:\n                      u(e, t, n, i), r.label = 3;\n                    case 3:\n                      return [2];\n                  }\n                });\n              });\n            }, e;\n          }();\n        t.SetAttributeApi = s;\n        var u = function (e, t, n, s) {\n          return r(void 0, void 0, void 0, function () {\n            var r, u;\n            return o(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  return r = (0, a.getEventsBaseProperties)(e, i.EventEnum.VWO_SYNC_VISITOR_PROP, encodeURIComponent(s.getUserAgent()), s.getIpAddress()), u = (0, a.getAttributePayloadData)(e, s.getId(), i.EventEnum.VWO_SYNC_VISITOR_PROP, t, n, s.getUserAgent(), s.getIpAddress()), [4, (0, a.sendPostApiRequest)(r, u)];\n                case 1:\n                  return o.sent(), [2];\n              }\n            });\n          });\n        };\n      },\n      977: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TrackApi = void 0;\n        var i = n(4237),\n          a = n(7128),\n          s = n(4580),\n          u = n(8667),\n          c = n(8754),\n          l = n(8925),\n          g = function () {\n            function e() {}\n            return e.prototype.track = function (e, t, n, g, p) {\n              return r(this, void 0, void 0, function () {\n                var r, f;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      return (0, u.doesEventBelongToAnyFeature)(t, e) ? (0, l.getShouldWaitForTrackingCalls)() ? [4, d(e, t, n, g)] : [3, 2] : [3, 4];\n                    case 1:\n                      return o.sent(), [3, 3];\n                    case 2:\n                      d(e, t, n, g), o.label = 3;\n                    case 3:\n                      return p.set({\n                        eventName: t,\n                        api: i.ApiEnum.TRACK\n                      }), p.execute(p.get()), [2, (r = {}, r[t] = !0, r)];\n                    case 4:\n                      return s.LogManager.Instance.error((0, c.buildMessage)(a.ErrorLogMessagesEnum.EVENT_NOT_FOUND, {\n                        eventName: t\n                      })), [2, (f = {}, f[t] = !1, f)];\n                  }\n                });\n              });\n            }, e;\n          }();\n        t.TrackApi = g;\n        var d = function (e, t, n, i) {\n          return r(void 0, void 0, void 0, function () {\n            var r, a;\n            return o(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  return r = (0, l.getEventsBaseProperties)(e, t, encodeURIComponent(n.getUserAgent()), n.getIpAddress()), a = (0, l.getTrackGoalPayloadData)(e, n.getId(), t, i, null == n ? void 0 : n.getUserAgent(), null == n ? void 0 : n.getIpAddress()), [4, (0, l.sendPostApiRequest)(r, a)];\n                case 1:\n                  return o.sent(), [2];\n              }\n            });\n          });\n        };\n      },\n      2346: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.BASE_URL = t.HTTPS_PROTOCOL = t.HTTP_PROTOCOL = t.SEED_URL = t.HTTPS = t.HTTP = void 0, t.HTTP = \"http\", t.HTTPS = \"https\", t.SEED_URL = \"https://vwo.com\", t.HTTP_PROTOCOL = \"\".concat(t.HTTP, \"://\"), t.HTTPS_PROTOCOL = \"\".concat(t.HTTPS, \"://\"), t.BASE_URL = \"dev.visualwebsiteoptimizer.com\";\n      },\n      5399: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Constants = void 0;\n        var r,\n          o,\n          i = n(5520),\n          a = n(2346);\n        r = {\n          name: \"vwo-fme-javascript-sdk\",\n          version: \"1.6.0\"\n        }, o = i.PlatformEnum.CLIENT, t.Constants = {\n          SDK_NAME: r.name,\n          SDK_VERSION: r.version,\n          PLATFORM: o,\n          MAX_TRAFFIC_PERCENT: 100,\n          MAX_TRAFFIC_VALUE: 1e4,\n          STATUS_RUNNING: \"RUNNING\",\n          SEED_VALUE: 1,\n          MAX_EVENTS_PER_REQUEST: 5e3,\n          DEFAULT_REQUEST_TIME_INTERVAL: 600,\n          DEFAULT_EVENTS_PER_REQUEST: 100,\n          SEED_URL: a.SEED_URL,\n          HTTP_PROTOCOL: a.HTTP_PROTOCOL,\n          HTTPS_PROTOCOL: a.HTTPS_PROTOCOL,\n          SETTINGS: \"settings\",\n          SETTINGS_EXPIRY: 1e7,\n          SETTINGS_TIMEOUT: 5e4,\n          HOST_NAME: \"dev.visualwebsiteoptimizer.com\",\n          SETTINTS_ENDPOINT: \"/server-side/v2-settings\",\n          LOCATION_ENDPOINT: \"/getLocation\",\n          VWO_FS_ENVIRONMENT: \"vwo_fs_environment\",\n          RANDOM_ALGO: 1,\n          API_VERSION: \"1\"\n        };\n      },\n      3780: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.StorageDecorator = void 0;\n        var i = n(4580),\n          a = n(1172),\n          s = n(7128),\n          u = n(8754),\n          c = n(4782),\n          l = function () {\n            function e() {}\n            return e.prototype.getFeatureFromStorage = function (e, t, n) {\n              return r(this, void 0, void 0, function () {\n                var r;\n                return o(this, function (o) {\n                  return r = new c.Deferred(), n.getDataInStorage(e, t).then(function (e) {\n                    switch (e) {\n                      case a.StorageEnum.STORAGE_UNDEFINED:\n                      case a.StorageEnum.NO_DATA_FOUND:\n                        r.resolve(null);\n                        break;\n                      case a.StorageEnum.INCORRECT_DATA:\n                        r.resolve(a.StorageEnum.INCORRECT_DATA);\n                        break;\n                      case a.StorageEnum.CAMPAIGN_PAUSED:\n                        r.resolve(null);\n                        break;\n                      case a.StorageEnum.VARIATION_NOT_FOUND:\n                        r.resolve(a.StorageEnum.VARIATION_NOT_FOUND);\n                        break;\n                      case a.StorageEnum.WHITELISTED_VARIATION:\n                        r.resolve(null);\n                        break;\n                      default:\n                        r.resolve(e);\n                    }\n                  }), [2, r.promise];\n                });\n              });\n            }, e.prototype.setDataInStorage = function (e, t) {\n              var n = new c.Deferred(),\n                r = e.featureKey,\n                o = e.context,\n                a = e.rolloutId,\n                l = e.rolloutKey,\n                g = e.rolloutVariationId,\n                d = e.experimentId,\n                p = e.experimentKey,\n                f = e.experimentVariationId;\n              return r ? o.id ? !l || p || g ? p && !f ? (i.LogManager.Instance.error((0, u.buildMessage)(s.ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n                key: \"Variation:(experimentKey or rolloutVariationId)\"\n              })), void n.reject()) : (t.setDataInStorage({\n                featureKey: r,\n                userId: o.id,\n                rolloutId: a,\n                rolloutKey: l,\n                rolloutVariationId: g,\n                experimentId: d,\n                experimentKey: p,\n                experimentVariationId: f\n              }), n.resolve(), n.promise) : (i.LogManager.Instance.error((0, u.buildMessage)(s.ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n                key: \"Variation:(rolloutKey, experimentKey or rolloutVariationId)\"\n              })), void n.reject()) : (i.LogManager.Instance.error((0, u.buildMessage)(s.ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n                key: \"Context or Context.id\"\n              })), void n.reject()) : (i.LogManager.Instance.error((0, u.buildMessage)(s.ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n                key: \"featureKey\"\n              })), void n.reject());\n            }, e;\n          }();\n        t.StorageDecorator = l;\n      },\n      4237: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ApiEnum = void 0, function (e) {\n          e.GET_FLAG = \"getFlag\", e.TRACK = \"track\";\n        }(n || (t.ApiEnum = n = {}));\n      },\n      4273: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.CampaignTypeEnum = void 0, function (e) {\n          e.ROLLOUT = \"FLAG_ROLLOUT\", e.AB = \"FLAG_TESTING\", e.PERSONALIZE = \"FLAG_PERSONALIZE\";\n        }(n || (t.CampaignTypeEnum = n = {}));\n      },\n      9693: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.EventEnum = void 0, function (e) {\n          e.VWO_VARIATION_SHOWN = \"vwo_variationShown\", e.VWO_SYNC_VISITOR_PROP = \"vwo_syncVisitorProp\";\n        }(n || (t.EventEnum = n = {}));\n      },\n      4019: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.HeadersEnum = void 0, function (e) {\n          e.USER_AGENT = \"X-Device-User-Agent\", e.IP = \"VWO-X-Forwarded-For\";\n        }(n || (t.HeadersEnum = n = {}));\n      },\n      8202: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.HttpMethodEnum = void 0, function (e) {\n          e.GET = \"GET\", e.POST = \"POST\";\n        }(n || (t.HttpMethodEnum = n = {}));\n      },\n      5520: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.PlatformEnum = void 0, function (e) {\n          e.CLIENT = \"client\", e.SERVER = \"server\";\n        }(n || (t.PlatformEnum = n = {}));\n      },\n      9217: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.StatusEnum = void 0, function (e) {\n          e.PASSED = \"passed\", e.FAILED = \"failed\";\n        }(n || (t.StatusEnum = n = {}));\n      },\n      1172: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.StorageEnum = void 0, function (e) {\n          e[e.STORAGE_UNDEFINED = 0] = \"STORAGE_UNDEFINED\", e[e.INCORRECT_DATA = 1] = \"INCORRECT_DATA\", e[e.NO_DATA_FOUND = 2] = \"NO_DATA_FOUND\", e[e.CAMPAIGN_PAUSED = 3] = \"CAMPAIGN_PAUSED\", e[e.VARIATION_NOT_FOUND = 4] = \"VARIATION_NOT_FOUND\", e[e.WHITELISTED_VARIATION = 5] = \"WHITELISTED_VARIATION\";\n        }(n || (t.StorageEnum = n = {}));\n      },\n      9528: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.UrlEnum = void 0, function (e) {\n          e.BASE_URL = \"dev.visualwebsiteoptimizer.com\", e.SETTINGS_URL = \"/server-side/settings\", e.EVENTS = \"/events/t\", e.ATTRIBUTE_CHECK = \"/check-attribute\", e.GET_USER_DATA = \"/get-user-details\";\n        }(n || (t.UrlEnum = n = {}));\n      },\n      7128: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ErrorLogMessagesEnum = t.InfoLogMessagesEnum = t.DebugLogMessagesEnum = void 0;\n        var r = n(3095),\n          o = r.debugMessages;\n        t.DebugLogMessagesEnum = o;\n        var i = r.infoMessages;\n        t.InfoLogMessagesEnum = i;\n        var a = r.errorMessages;\n        t.ErrorLogMessagesEnum = a;\n      },\n      2144: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.CampaignModel = void 0;\n        var r = n(9094),\n          o = n(502),\n          i = n(2365),\n          a = function () {\n            function e() {\n              this.variations = [], this.metrics = [], this.variables = [];\n            }\n            return e.prototype.copy = function (e) {\n              this.metrics = e.metrics, this.variations = e.variations, this.variables = e.variables, this.processCampaignKeys(e);\n            }, e.prototype.modelFromDictionary = function (e) {\n              return this.processCampaignProperties(e), this.processCampaignKeys(e), this;\n            }, e.prototype.processCampaignProperties = function (e) {\n              var t = this;\n              e.variables && (e.variables.constructor === {}.constructor ? this.variables = [] : e.variables.forEach(function (e) {\n                t.variables.push(new o.VariableModel().modelFromDictionary(e));\n              })), e.variations && (e.variations.constructor === {}.constructor ? this.variations = [] : e.variations.forEach(function (e) {\n                t.variations.push(new i.VariationModel().modelFromDictionary(e));\n              })), e.metrics && (e.metrics && e.metrics.constructor === {}.constructor ? this.metrics = [] : (e.metrics || []).forEach(function (e) {\n                t.metrics.push(new r.MetricModel().modelFromDictionary(e));\n              }));\n            }, e.prototype.processCampaignKeys = function (e) {\n              this.id = e.id, this.percentTraffic = e.percentTraffic, this.name = e.name, this.variationId = e.variationId, this.campaignId = e.campaignId, this.ruleKey = e.ruleKey, this.isForcedVariationEnabled = e.isForcedVariationEnabled, this.isUserListEnabled = e.isUserListEnabled, this.segments = e.segments, this.key = e.key, this.type = e.type;\n            }, e.prototype.getId = function () {\n              return this.id;\n            }, e.prototype.getName = function () {\n              return this.name;\n            }, e.prototype.getSegments = function () {\n              return this.segments;\n            }, e.prototype.getTraffic = function () {\n              return this.percentTraffic;\n            }, e.prototype.getType = function () {\n              return this.type;\n            }, e.prototype.getIsForcedVariationEnabled = function () {\n              return this.isForcedVariationEnabled;\n            }, e.prototype.getIsUserListEnabled = function () {\n              return this.isUserListEnabled;\n            }, e.prototype.getKey = function () {\n              return this.key;\n            }, e.prototype.getMetrics = function () {\n              return this.metrics;\n            }, e.prototype.getVariations = function () {\n              return this.variations;\n            }, e.prototype.getVariables = function () {\n              return this.variables;\n            }, e.prototype.getRuleKey = function () {\n              return this.ruleKey;\n            }, e;\n          }();\n        t.CampaignModel = a;\n      },\n      3836: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.FeatureModel = void 0;\n        var r = n(9378),\n          o = n(9094),\n          i = n(324),\n          a = function () {\n            function e() {\n              this.m = [], this.metrics = [], this.rules = [], this.impactCampaign = null, this.rulesLinkedCampaign = [], this.isGatewayServiceRequired = !1;\n            }\n            return e.prototype.modelFromDictionary = function (e) {\n              var t,\n                n,\n                a,\n                s = this;\n              if (this.id = e.id, this.key = e.key, this.name = e.name, this.type = e.type, (null == e ? void 0 : e.isGatewayServiceRequired) && (this.isGatewayServiceRequired = e.isGatewayServiceRequired), e.impactCampaign && (this.impactCampaign = new r.ImpactCapmaignModel().modelFromDictionary(e.impactCampaign)), e.m && e.m.constructor === {}.constructor || (null === (t = e.metrics) || void 0 === t ? void 0 : t.constructor) === {}.constructor) this.metrics = [];else {\n                var u = e.m || e.metrics;\n                null == u || u.forEach(function (e) {\n                  s.metrics.push(new o.MetricModel().modelFromDictionary(e));\n                });\n              }\n              if ((null === (n = null == e ? void 0 : e.rules) || void 0 === n ? void 0 : n.constructor) === {}.constructor) this.rules = [];else {\n                var c = e.rules;\n                null == c || c.forEach(function (e) {\n                  s.rules.push(new i.RuleModel().modelFromDictionary(e));\n                });\n              }\n              if ((null == e ? void 0 : e.rulesLinkedCampaign) && (null === (a = e.rulesLinkedCampaign) || void 0 === a ? void 0 : a.constructor) !== {}.constructor) {\n                var l = e.rulesLinkedCampaign;\n                this.rulesLinkedCampaign = l;\n              }\n              return this;\n            }, e.prototype.getName = function () {\n              return this.name;\n            }, e.prototype.getType = function () {\n              return this.type;\n            }, e.prototype.getId = function () {\n              return this.id;\n            }, e.prototype.getKey = function () {\n              return this.key;\n            }, e.prototype.getRules = function () {\n              return this.rules;\n            }, e.prototype.getImpactCampaign = function () {\n              return this.impactCampaign;\n            }, e.prototype.getRulesLinkedCampaign = function () {\n              return this.rulesLinkedCampaign;\n            }, e.prototype.setRulesLinkedCampaign = function (e) {\n              this.rulesLinkedCampaign = e;\n            }, e.prototype.getMetrics = function () {\n              return this.metrics;\n            }, e.prototype.getIsGatewayServiceRequired = function () {\n              return this.isGatewayServiceRequired;\n            }, e.prototype.setIsGatewayServiceRequired = function (e) {\n              this.isGatewayServiceRequired = e;\n            }, e;\n          }();\n        t.FeatureModel = a;\n      },\n      9378: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ImpactCapmaignModel = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.modelFromDictionary = function (e) {\n            return this.type = e.type, this.campaignId = e.campaignId, this;\n          }, e.prototype.getCampaignId = function () {\n            return this.campaignId;\n          }, e.prototype.getType = function () {\n            return this.type;\n          }, e;\n        }();\n        t.ImpactCapmaignModel = n;\n      },\n      9094: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.MetricModel = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.modelFromDictionary = function (e) {\n            return this.identifier = e.identifier || e.key, this.id = e.i || e.id, this.type = e.t || e.type, this;\n          }, e.prototype.getId = function () {\n            return this.id;\n          }, e.prototype.getIdentifier = function () {\n            return this.identifier;\n          }, e.prototype.getType = function () {\n            return this.type;\n          }, e;\n        }();\n        t.MetricModel = n;\n      },\n      324: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RuleModel = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.modelFromDictionary = function (e) {\n            return this.type = e.type, this.status = e.status, this.variationId = e.variationId, this.campaignId = e.campaignId, this.ruleKey = e.ruleKey, this;\n          }, e.prototype.getCampaignId = function () {\n            return this.campaignId;\n          }, e.prototype.getVariationId = function () {\n            return this.variationId;\n          }, e.prototype.getStatus = function () {\n            return this.status;\n          }, e.prototype.getType = function () {\n            return this.type;\n          }, e.prototype.getRuleKey = function () {\n            return this.ruleKey;\n          }, e;\n        }();\n        t.RuleModel = n;\n      },\n      502: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.VariableModel = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.modelFromDictionary = function (e) {\n            return this.value = e.val || e.value, this.type = e.type, this.key = e.k || e.key, this.id = e.i || e.id, this;\n          }, e.prototype.setValue = function (e) {\n            this.value = e;\n          }, e.prototype.setKey = function (e) {\n            this.key = e;\n          }, e.prototype.setType = function (e) {\n            this.type = e;\n          }, e.prototype.getId = function () {\n            return this.id;\n          }, e.prototype.getValue = function () {\n            return this.value;\n          }, e.prototype.getType = function () {\n            return this.type;\n          }, e.prototype.getKey = function () {\n            return this.key;\n          }, e;\n        }();\n        t.VariableModel = n;\n      },\n      2365: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.VariationModel = void 0;\n        var r = n(502),\n          o = function () {\n            function e() {\n              this.variables = [], this.variations = [];\n            }\n            return e.prototype.modelFromDictionary = function (t) {\n              var n = this;\n              return this.id = t.i || t.id, this.key = t.n || t.key || t.name, this.weight = t.w || t.weight, this.setStartRange(t.startRangeVariation), this.setEndRange(t.endRangeVariation), (t.seg || t.segments) && (this.segments = t.seg || t.segments), t.variables && (t.variables.constructor === {}.constructor ? this.variables = [] : t.variables.forEach(function (e) {\n                n.variables.push(new r.VariableModel().modelFromDictionary(e));\n              })), t.variations && (t.variations.constructor === {}.constructor ? this.variations = [] : t.variations.forEach(function (t) {\n                n.variations.push(new e().modelFromDictionary(t));\n              })), this;\n            }, e.prototype.setStartRange = function (e) {\n              this.startRangeVariation = e;\n            }, e.prototype.setEndRange = function (e) {\n              this.endRangeVariation = e;\n            }, e.prototype.setWeight = function (e) {\n              this.weight = e;\n            }, e.prototype.getId = function () {\n              return this.id;\n            }, e.prototype.getKey = function () {\n              return this.key;\n            }, e.prototype.getWeight = function () {\n              return this.weight;\n            }, e.prototype.getSegments = function () {\n              return this.segments;\n            }, e.prototype.getStartRangeVariation = function () {\n              return this.startRangeVariation;\n            }, e.prototype.getEndRangeVariation = function () {\n              return this.endRangeVariation;\n            }, e.prototype.getVariables = function () {\n              return this.variables;\n            }, e.prototype.getVariations = function () {\n              return this.variations;\n            }, e;\n          }();\n        t.VariationModel = o;\n      },\n      9846: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SettingsSchema = void 0;\n        var r = n(3185),\n          o = function () {\n            function e() {\n              this.initializeSchemas();\n            }\n            return e.prototype.initializeSchemas = function () {\n              this.campaignMetricSchema = (0, r.object)({\n                id: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                type: (0, r.string)(),\n                identifier: (0, r.string)(),\n                mca: (0, r.optional)((0, r.union)([(0, r.number)(), (0, r.string)()])),\n                hasProps: (0, r.optional)((0, r.boolean)()),\n                revenueProp: (0, r.optional)((0, r.string)())\n              }), this.variableObjectSchema = (0, r.object)({\n                id: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                type: (0, r.string)(),\n                key: (0, r.string)(),\n                value: (0, r.union)([(0, r.number)(), (0, r.string)(), (0, r.boolean)(), (0, r.object)()])\n              }), this.campaignVariationSchema = (0, r.object)({\n                id: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                name: (0, r.string)(),\n                weight: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                segments: (0, r.optional)((0, r.object)()),\n                variables: (0, r.optional)((0, r.array)(this.variableObjectSchema)),\n                startRangeVariation: (0, r.optional)((0, r.number)()),\n                endRangeVariation: (0, r.optional)((0, r.number)())\n              }), this.campaignObjectSchema = (0, r.object)({\n                id: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                type: (0, r.string)(),\n                key: (0, r.string)(),\n                percentTraffic: (0, r.optional)((0, r.number)()),\n                status: (0, r.string)(),\n                variations: (0, r.array)(this.campaignVariationSchema),\n                segments: (0, r.object)(),\n                isForcedVariationEnabled: (0, r.optional)((0, r.boolean)()),\n                isAlwaysCheckSegment: (0, r.optional)((0, r.boolean)()),\n                name: (0, r.string)()\n              }), this.ruleSchema = (0, r.object)({\n                type: (0, r.string)(),\n                ruleKey: (0, r.string)(),\n                campaignId: (0, r.number)(),\n                variationId: (0, r.optional)((0, r.number)())\n              }), this.featureSchema = (0, r.object)({\n                id: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                key: (0, r.string)(),\n                status: (0, r.string)(),\n                name: (0, r.string)(),\n                type: (0, r.string)(),\n                metrics: (0, r.array)(this.campaignMetricSchema),\n                impactCampaign: (0, r.optional)((0, r.object)()),\n                rules: (0, r.optional)((0, r.array)(this.ruleSchema)),\n                variables: (0, r.optional)((0, r.array)(this.variableObjectSchema))\n              }), this.settingsSchema = (0, r.object)({\n                sdkKey: (0, r.optional)((0, r.string)()),\n                version: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                accountId: (0, r.union)([(0, r.number)(), (0, r.string)()]),\n                features: (0, r.optional)((0, r.array)(this.featureSchema)),\n                campaigns: (0, r.array)(this.campaignObjectSchema),\n                groups: (0, r.optional)((0, r.object)()),\n                campaignGroups: (0, r.optional)((0, r.object)()),\n                collectionPrefix: (0, r.optional)((0, r.string)())\n              });\n            }, e.prototype.isSettingsValid = function (e) {\n              return !!e && !(0, r.validate)(e, this.settingsSchema)[0];\n            }, e;\n          }();\n        t.SettingsSchema = o;\n      },\n      6130: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SettingsModel = void 0;\n        var r = n(2144),\n          o = n(3836),\n          i = function () {\n            function e(e) {\n              var t = this;\n              return this.f = [], this.features = [], this.c = [], this.campaigns = [], this.campaignGroups = {}, this.cG = {}, this.groups = {}, this.g = {}, this.sdkKey = e.sK || e.sdkKey, this.accountId = e.a || e.accountId, this.version = e.v || e.version, this.collectionPrefix = e.collectionPrefix, (e.f && e.f.constructor !== {}.constructor || e.features && e.features.constructor !== {}.constructor) && (e.f || e.features).forEach(function (e) {\n                t.features.push(new o.FeatureModel().modelFromDictionary(e));\n              }), (e.c && e.c.constructor !== {}.constructor || e.campaigns && e.campaigns.constructor !== {}.constructor) && (e.c || e.campaigns).forEach(function (e) {\n                t.campaigns.push(new r.CampaignModel().modelFromDictionary(e));\n              }), (e.cG || e.campaignGroups) && (this.campaignGroups = e.cG || e.campaignGroups), (e.g || e.groups) && (this.groups = e.g || e.groups), this;\n            }\n            return e.prototype.getFeatures = function () {\n              return this.features;\n            }, e.prototype.getCampaigns = function () {\n              return this.campaigns;\n            }, e.prototype.getSdkkey = function () {\n              return this.sdkKey;\n            }, e.prototype.getAccountId = function () {\n              return this.accountId;\n            }, e.prototype.getVersion = function () {\n              return this.version;\n            }, e.prototype.getCollectionPrefix = function () {\n              return this.collectionPrefix;\n            }, e.prototype.getCampaignGroups = function () {\n              return this.campaignGroups;\n            }, e.prototype.getGroups = function () {\n              return this.groups;\n            }, e;\n          }();\n        t.SettingsModel = i;\n      },\n      9752: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ContextModel = void 0;\n        var r = n(1880),\n          o = function () {\n            function e() {}\n            return e.prototype.modelFromDictionary = function (e) {\n              return this.id = e.id, this.userAgent = e.userAgent, this.ipAddress = e.ipAddress, (null == e ? void 0 : e.customVariables) && (this.customVariables = e.customVariables), (null == e ? void 0 : e.variationTargetingVariables) && (this.variationTargetingVariables = e.variationTargetingVariables), (null == e ? void 0 : e._vwo) && (this._vwo = new r.ContextVWOModel().modelFromDictionary(e._vwo)), this;\n            }, e.prototype.getId = function () {\n              var e;\n              return null === (e = this.id) || void 0 === e ? void 0 : e.toString();\n            }, e.prototype.getUserAgent = function () {\n              return this.userAgent;\n            }, e.prototype.getIpAddress = function () {\n              return this.ipAddress;\n            }, e.prototype.getCustomVariables = function () {\n              return this.customVariables;\n            }, e.prototype.setCustomVariables = function (e) {\n              this.customVariables = e;\n            }, e.prototype.getVariationTargetingVariables = function () {\n              return this.variationTargetingVariables;\n            }, e.prototype.setVariationTargetingVariables = function (e) {\n              this.variationTargetingVariables = e;\n            }, e.prototype.getVwo = function () {\n              return this._vwo;\n            }, e.prototype.setVwo = function (e) {\n              this._vwo = e;\n            }, e;\n          }();\n        t.ContextModel = o;\n      },\n      1880: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ContextVWOModel = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.modelFromDictionary = function (e) {\n            return (null == e ? void 0 : e.location) && (this.location = e.location), (null == e ? void 0 : e.userAgent) && (this.userAgent = e.userAgent), this;\n          }, e.prototype.getLocation = function () {\n            return this.location;\n          }, e.prototype.getUaInfo = function () {\n            return this.userAgent;\n          }, e;\n        }();\n        t.ContextVWOModel = n;\n      },\n      6775: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.DecisionMaker = void 0;\n        var r = n(8005),\n          o = function () {\n            function e() {}\n            return e.prototype.generateBucketValue = function (e, t, n) {\n              void 0 === n && (n = 1);\n              var r = (t * (e / Math.pow(2, 32)) + 1) * n;\n              return Math.floor(r);\n            }, e.prototype.getBucketValueForUser = function (e, t) {\n              void 0 === t && (t = 100);\n              var n = r.v3(e, 1);\n              return this.generateBucketValue(n, t);\n            }, e.prototype.calculateBucketValue = function (e, t, n) {\n              void 0 === t && (t = 1), void 0 === n && (n = 1e4);\n              var r = this.generateHashValue(e);\n              return this.generateBucketValue(r, n, t);\n            }, e.prototype.generateHashValue = function (e) {\n              return r.v3(e, 1);\n            }, e;\n          }();\n        t.DecisionMaker = o;\n      },\n      2752: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LogMessageBuilder = void 0;\n        var r = n(4940),\n          o = \"\u001b[1m\",\n          i = \"\u001b[0m\",\n          a = function () {\n            function e(e, t) {\n              this.loggerConfig = e, this.transportConfig = t, this.prefix = this.transportConfig.prefix || this.loggerConfig.prefix || \"\", this.dateTimeFormat = this.transportConfig.dateTimeFormat || this.loggerConfig.dateTimeFormat;\n            }\n            return e.prototype.formatMessage = function (e, t) {\n              return \"[\".concat(this.getFormattedLevel(e), \"]: \").concat(this.getFormattedPrefix(this.prefix), \" \").concat(this.getFormattedDateTime(), \" \").concat(t);\n            }, e.prototype.getFormattedPrefix = function (e) {\n              return this.loggerConfig.isAnsiColorEnabled ? \"\".concat(o).concat(\"\u001b[32m\").concat(e).concat(i) : \"\".concat(e);\n            }, e.prototype.getFormattedLevel = function (e) {\n              var t,\n                n,\n                a,\n                s = e.toUpperCase();\n              return this.loggerConfig.isAnsiColorEnabled ? ((t = {})[r.LogLevelEnum.TRACE] = \"\".concat(o).concat(\"\u001b[30m\").concat(s).concat(i), t[r.LogLevelEnum.DEBUG] = \"\".concat(o).concat(\"\u001b[94m\").concat(s).concat(i), t[r.LogLevelEnum.INFO] = \"\".concat(o).concat(\"\u001b[36m\").concat(s).concat(i), t[r.LogLevelEnum.WARN] = \"\".concat(o).concat(\"\u001b[33m\").concat(s).concat(i), t[r.LogLevelEnum.ERROR] = \"\".concat(o).concat(\"\u001b[31m\").concat(s).concat(i), a = t) : ((n = {})[r.LogLevelEnum.TRACE] = s, n[r.LogLevelEnum.DEBUG] = s, n[r.LogLevelEnum.INFO] = s, n[r.LogLevelEnum.WARN] = s, n[r.LogLevelEnum.ERROR] = s, a = n), a[e];\n            }, e.prototype.getFormattedDateTime = function () {\n              return this.dateTimeFormat();\n            }, e;\n          }();\n        t.LogMessageBuilder = a;\n      },\n      5374: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Logger = void 0;\n        t.Logger = function () {};\n      },\n      3293: function (e, t, n) {\n        \"use strict\";\n\n        var r,\n          o = this && this.__extends || (r = function (e, t) {\n            return r = Object.setPrototypeOf || {\n              __proto__: []\n            } instanceof Array && function (e, t) {\n              e.__proto__ = t;\n            } || function (e, t) {\n              for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n            }, r(e, t);\n          }, function (e, t) {\n            if (\"function\" != typeof t && null !== t) throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n            function n() {\n              this.constructor = e;\n            }\n            r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n          });\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LogManager = void 0;\n        var i = n(2831),\n          a = n(5374),\n          s = n(6325),\n          u = n(4820),\n          c = n(1359),\n          l = n(4940),\n          g = function (e) {\n            function t(n) {\n              var r = e.call(this) || this;\n              return r.name = \"VWO Logger\", r.requestId = (0, i.v4)(), r.level = l.LogLevelEnum.ERROR, r.prefix = \"VWO-SDK\", r.config = n, !n.isAlwaysNewInstance && t.instance || (t.instance = r, r.config.name = n.name || r.name, r.config.requestId = n.requestId || r.requestId, r.config.level = n.level || r.level, r.config.prefix = n.prefix || r.prefix, r.config.dateTimeFormat = n.dateTimeFormat || r.dateTimeFormat, r.transportManager = new u.LogTransportManager(r.config), r.handleTransports()), t.instance;\n            }\n            return o(t, e), t.prototype.dateTimeFormat = function () {\n              return new Date().toISOString();\n            }, Object.defineProperty(t, \"Instance\", {\n              get: function () {\n                return t.instance;\n              },\n              enumerable: !1,\n              configurable: !0\n            }), t.prototype.handleTransports = function () {\n              var e = this.config.transports;\n              (null == e ? void 0 : e.length) ? this.addTransports(this.config.transports) : this.config.transport && (0, c.isObject)(this.config.transport) ? this.addTransport(this.config.transport) : this.addTransport(new s.ConsoleTransport({\n                level: this.config.level\n              }));\n            }, t.prototype.addTransport = function (e) {\n              this.transportManager.addTransport(e);\n            }, t.prototype.addTransports = function (e) {\n              for (var t = 0; t < e.length; t++) this.addTransport(e[t]);\n            }, t.prototype.trace = function (e) {\n              this.transportManager.log(l.LogLevelEnum.TRACE, e);\n            }, t.prototype.debug = function (e) {\n              this.transportManager.log(l.LogLevelEnum.DEBUG, e);\n            }, t.prototype.info = function (e) {\n              this.transportManager.log(l.LogLevelEnum.INFO, e);\n            }, t.prototype.warn = function (e) {\n              this.transportManager.log(l.LogLevelEnum.WARN, e);\n            }, t.prototype.error = function (e) {\n              this.transportManager.log(l.LogLevelEnum.ERROR, e);\n            }, t;\n          }(a.Logger);\n        t.LogManager = g;\n      },\n      4820: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LogTransportManager = void 0;\n        var r,\n          o = n(4940),\n          i = n(2752),\n          a = n(1359);\n        !function (e) {\n          e[e.TRACE = 0] = \"TRACE\", e[e.DEBUG = 1] = \"DEBUG\", e[e.INFO = 2] = \"INFO\", e[e.WARN = 3] = \"WARN\", e[e.ERROR = 4] = \"ERROR\";\n        }(r || (r = {}));\n        var s = function () {\n          function e(e) {\n            this.transports = [], this.config = e;\n          }\n          return e.prototype.addTransport = function (e) {\n            this.transports.push(e);\n          }, e.prototype.shouldLog = function (e, t) {\n            return r[e.toUpperCase()] >= r[(t || this.config.level).toUpperCase()];\n          }, e.prototype.trace = function (e) {\n            this.log(o.LogLevelEnum.TRACE, e);\n          }, e.prototype.debug = function (e) {\n            this.log(o.LogLevelEnum.DEBUG, e);\n          }, e.prototype.info = function (e) {\n            this.log(o.LogLevelEnum.INFO, e);\n          }, e.prototype.warn = function (e) {\n            this.log(o.LogLevelEnum.WARN, e);\n          }, e.prototype.error = function (e) {\n            this.log(o.LogLevelEnum.ERROR, e);\n          }, e.prototype.log = function (e, t) {\n            for (var n = 0; n < this.transports.length; n++) {\n              var r = new i.LogMessageBuilder(this.config, this.transports[n]).formatMessage(e, t);\n              this.shouldLog(e, this.transports[n].level) && (this.transports[n].log && (0, a.isFunction)(this.transports[n].log) ? this.transports[n].log(e, t) : this.transports[n][e](r));\n            }\n          }, e;\n        }();\n        t.LogTransportManager = s;\n      },\n      4940: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LogLevelEnum = void 0, function (e) {\n          e.TRACE = \"trace\", e.DEBUG = \"debug\", e.INFO = \"info\", e.WARN = \"warn\", e.ERROR = \"error\";\n        }(n || (t.LogLevelEnum = n = {}));\n      },\n      4580: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LogLevelEnum = t.LogManager = void 0;\n        var r = n(3293);\n        Object.defineProperty(t, \"LogManager\", {\n          enumerable: !0,\n          get: function () {\n            return r.LogManager;\n          }\n        });\n        var o = n(4940);\n        Object.defineProperty(t, \"LogLevelEnum\", {\n          enumerable: !0,\n          get: function () {\n            return o.LogLevelEnum;\n          }\n        });\n      },\n      6325: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ConsoleTransport = void 0;\n        var r = n(4940),\n          o = function () {\n            function e(e) {\n              void 0 === e && (e = {}), this.config = e, this.level = this.config.level;\n            }\n            return e.prototype.trace = function (e) {\n              this.consoleLog(r.LogLevelEnum.TRACE, e);\n            }, e.prototype.debug = function (e) {\n              this.consoleLog(r.LogLevelEnum.DEBUG, e);\n            }, e.prototype.info = function (e) {\n              this.consoleLog(r.LogLevelEnum.INFO, e);\n            }, e.prototype.warn = function (e) {\n              this.consoleLog(r.LogLevelEnum.WARN, e);\n            }, e.prototype.error = function (e) {\n              this.consoleLog(r.LogLevelEnum.ERROR, e);\n            }, e.prototype.consoleLog = function (e, t) {\n              console[e](t);\n            }, e;\n          }();\n        t.ConsoleTransport = o;\n      },\n      1703: (e, t, n) => {\n        \"use strict\";\n\n        t.o = void 0;\n        var r = n(3890),\n          o = n(4782),\n          i = n(5573),\n          a = function () {\n            function e() {}\n            return e.prototype.GET = function (e) {\n              var t = new o.Deferred(),\n                n = e.getOptions(),\n                a = new i.ResponseModel();\n              return (0, r.sendGetCall)({\n                networkOptions: n,\n                successCallback: function (e) {\n                  a.setData(e), t.resolve(a);\n                },\n                errorCallback: function (e) {\n                  a.setError(e), t.reject(a);\n                }\n              }), t.promise;\n            }, e.prototype.POST = function (e) {\n              var t = new o.Deferred(),\n                n = e.getOptions(),\n                a = new i.ResponseModel();\n              return (0, r.sendPostCall)({\n                networkOptions: n,\n                successCallback: function (e) {\n                  a.setData(e), t.resolve(a);\n                },\n                errorCallback: function (e) {\n                  a.setError(e), t.reject(a);\n                }\n              }), t.promise;\n            }, e;\n          }();\n        t.o = a;\n      },\n      415: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RequestHandler = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.createRequest = function (e, t) {\n            if (!(null !== t.getBaseUrl() && void 0 !== t.getBaseUrl() || null !== e.getUrl() && void 0 !== e.getUrl())) return null;\n            e.setUrl(e.getUrl() || t.getBaseUrl()), e.setTimeout(e.getTimeout() || t.getTimeout()), e.setBody(e.getBody() || t.getBody()), e.setHeaders(e.getHeaders() || t.getHeaders());\n            var n = e.getQuery() || {},\n              r = t.getQuery() || {};\n            for (var o in r) Object.prototype.hasOwnProperty.call(n, o) || (n[o] = r[o]);\n            return e.setQuery(n), e;\n          }, e;\n        }();\n        t.RequestHandler = n;\n      },\n      6710: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ResponseModel = t.RequestModel = t.GlobalRequestModel = t.NetworkManager = t.NetworkClient = void 0, t.NetworkClient = n(1703).o;\n        var r = n(7885);\n        Object.defineProperty(t, \"NetworkManager\", {\n          enumerable: !0,\n          get: function () {\n            return r.NetworkManager;\n          }\n        });\n        var o = n(4036);\n        Object.defineProperty(t, \"GlobalRequestModel\", {\n          enumerable: !0,\n          get: function () {\n            return o.GlobalRequestModel;\n          }\n        });\n        var i = n(2887);\n        Object.defineProperty(t, \"RequestModel\", {\n          enumerable: !0,\n          get: function () {\n            return i.RequestModel;\n          }\n        });\n        var a = n(5573);\n        Object.defineProperty(t, \"ResponseModel\", {\n          enumerable: !0,\n          get: function () {\n            return a.ResponseModel;\n          }\n        });\n      },\n      7885: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.NetworkManager = void 0;\n        var r = n(4782),\n          o = n(415),\n          i = n(4036),\n          a = function () {\n            function e() {}\n            return e.prototype.attachClient = function (e) {\n              var t = n(1703).o;\n              this.client = e || new t(), this.config = new i.GlobalRequestModel(null, null, null, null);\n            }, Object.defineProperty(e, \"Instance\", {\n              get: function () {\n                return this.instance = this.instance || new e(), this.instance;\n              },\n              enumerable: !1,\n              configurable: !0\n            }), e.prototype.setConfig = function (e) {\n              this.config = e;\n            }, e.prototype.getConfig = function () {\n              return this.config;\n            }, e.prototype.createRequest = function (e) {\n              return new o.RequestHandler().createRequest(e, this.config);\n            }, e.prototype.get = function (e) {\n              var t = new r.Deferred(),\n                n = this.createRequest(e);\n              return n.getUrl() ? this.client.GET(n).then(function (e) {\n                t.resolve(e);\n              }).catch(function (e) {\n                t.reject(e);\n              }) : t.reject(new Error(\"no url found\")), t.promise;\n            }, e.prototype.post = function (e) {\n              var t = new r.Deferred(),\n                n = this.createRequest(e);\n              return n.getUrl() ? this.client.POST(n).then(function (e) {\n                t.resolve(e);\n              }).catch(function (e) {\n                t.reject(e);\n              }) : t.reject(new Error(\"no url found\")), t.promise;\n            }, e;\n          }();\n        t.NetworkManager = a;\n      },\n      4036: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.GlobalRequestModel = void 0;\n        var n = function () {\n          function e(e, t, n, r) {\n            this.timeout = 3e3, this.url = e, this.query = t, this.body = n, this.headers = r;\n          }\n          return e.prototype.setQuery = function (e) {\n            this.query = e;\n          }, e.prototype.getQuery = function () {\n            return this.query;\n          }, e.prototype.setBody = function (e) {\n            this.body = e;\n          }, e.prototype.getBody = function () {\n            return this.body;\n          }, e.prototype.setBaseUrl = function (e) {\n            this.url = e;\n          }, e.prototype.getBaseUrl = function () {\n            return this.url;\n          }, e.prototype.setTimeout = function (e) {\n            this.timeout = e;\n          }, e.prototype.getTimeout = function () {\n            return this.timeout;\n          }, e.prototype.setHeaders = function (e) {\n            this.headers = e;\n          }, e.prototype.getHeaders = function () {\n            return this.headers;\n          }, e.prototype.setDevelopmentMode = function (e) {\n            this.isDevelopmentMode = e;\n          }, e.prototype.getDevelopmentMode = function () {\n            return this.isDevelopmentMode;\n          }, e;\n        }();\n        t.GlobalRequestModel = n;\n      },\n      2887: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RequestModel = void 0;\n        var r = n(8202),\n          o = n(2346),\n          i = function () {\n            function e(e, t, n, i, a, s, u, c) {\n              void 0 === t && (t = r.HttpMethodEnum.GET), void 0 === u && (u = o.HTTPS), this.url = e, this.method = t, this.path = n, this.query = i, this.body = a, this.headers = s, this.scheme = u, this.port = c;\n            }\n            return e.prototype.getMethod = function () {\n              return this.method;\n            }, e.prototype.setMethod = function (e) {\n              this.method = e;\n            }, e.prototype.getBody = function () {\n              return this.body;\n            }, e.prototype.setBody = function (e) {\n              this.body = e;\n            }, e.prototype.setQuery = function (e) {\n              this.query = e;\n            }, e.prototype.getQuery = function () {\n              return this.query;\n            }, e.prototype.setHeaders = function (e) {\n              return this.headers = e, this;\n            }, e.prototype.getHeaders = function () {\n              return this.headers;\n            }, e.prototype.setTimeout = function (e) {\n              return this.timeout = e, this;\n            }, e.prototype.getTimeout = function () {\n              return this.timeout;\n            }, e.prototype.getUrl = function () {\n              return this.url;\n            }, e.prototype.setUrl = function (e) {\n              return this.url = e, this;\n            }, e.prototype.getScheme = function () {\n              return this.scheme;\n            }, e.prototype.setScheme = function (e) {\n              return this.scheme = e, this;\n            }, e.prototype.getPort = function () {\n              return this.port;\n            }, e.prototype.setPort = function (e) {\n              return this.port = e, this;\n            }, e.prototype.getPath = function () {\n              return this.path;\n            }, e.prototype.setPath = function (e) {\n              return this.path = e, this;\n            }, e.prototype.getOptions = function () {\n              var e = \"\";\n              for (var t in this.query) e += \"\".concat(t, \"=\").concat(this.query[t], \"&\");\n              var n = this.url.split(\"/\"),\n                r = n[0],\n                o = n[1],\n                i = {\n                  hostname: r,\n                  agent: !1\n                };\n              if (this.scheme && (i.scheme = this.scheme), this.port && (i.port = this.port), this.headers && (i.headers = this.headers), this.method && (i.method = this.method), this.body) {\n                var a = JSON.stringify(this.body);\n                i.headers = i.headers || {}, i.headers[\"Content-Type\"] = \"application/json\", \"undefined\" == typeof Buffer ? i.headers[\"Content-Length\"] = new TextEncoder().encode(a).length : i.headers[\"Content-Length\"] = Buffer.byteLength(a), i.body = this.body;\n              }\n              return this.path && (i.path = \"\" !== e ? this.path + \"?\" + e || \"\" : this.path), o && (i.path = \"/\".concat(o) + i.path), this.timeout && (i.timeout = this.timeout), \"&\" === i.path.charAt(i.path.length - 1) && (i.path = i.path.substring(0, i.path.length - 1)), i;\n            }, e;\n          }();\n        t.RequestModel = i;\n      },\n      5573: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ResponseModel = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.setStatusCode = function (e) {\n            this.statusCode = e;\n          }, e.prototype.setHeaders = function (e) {\n            this.headers = e;\n          }, e.prototype.setData = function (e) {\n            this.data = e;\n          }, e.prototype.setError = function (e) {\n            this.error = e;\n          }, e.prototype.getHeaders = function () {\n            return this.headers;\n          }, e.prototype.getData = function () {\n            return this.data;\n          }, e.prototype.getStatusCode = function () {\n            return this.statusCode;\n          }, e.prototype.getError = function () {\n            return this.error;\n          }, e;\n        }();\n        t.ResponseModel = n;\n      },\n      6373: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SegmentationManager = void 0;\n        var i = n(8011),\n          a = n(2898),\n          s = n(9528),\n          u = n(4580),\n          c = n(1880),\n          l = n(470),\n          g = n(1359),\n          d = function () {\n            function e() {}\n            return Object.defineProperty(e, \"Instance\", {\n              get: function () {\n                return this.instance = this.instance || new e(), this.instance;\n              },\n              enumerable: !1,\n              configurable: !0\n            }), e.prototype.attachEvaluator = function (e) {\n              this.evaluator = e || new i.SegmentEvaluator();\n            }, e.prototype.setContextualData = function (e, t, n) {\n              return r(this, void 0, void 0, function () {\n                var r, i, d, p;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      if (this.attachEvaluator(), this.evaluator.settings = e, this.evaluator.context = n, this.evaluator.feature = t, null === (null == n ? void 0 : n.getUserAgent()) && null === (null == n ? void 0 : n.getIpAddress())) return [2];\n                      if (!0 !== t.getIsGatewayServiceRequired()) return [3, 4];\n                      if (!l.SettingsService.Instance.isGatewayServiceProvided || !(0, g.isUndefined)(n.getVwo()) && null !== n.getVwo()) return [3, 4];\n                      r = {}, (null == n ? void 0 : n.getUserAgent()) && (r.userAgent = n.getUserAgent()), (null == n ? void 0 : n.getIpAddress()) && (r.ipAddress = n.getIpAddress()), o.label = 1;\n                    case 1:\n                      return o.trys.push([1, 3,, 4]), i = (0, a.getQueryParams)(r), [4, (0, a.getFromGatewayService)(i, s.UrlEnum.GET_USER_DATA)];\n                    case 2:\n                      return d = o.sent(), n.setVwo(new c.ContextVWOModel().modelFromDictionary(d)), [3, 4];\n                    case 3:\n                      return p = o.sent(), u.LogManager.Instance.error(\"Error in setting contextual data for segmentation. Got error: \".concat(p.error)), [3, 4];\n                    case 4:\n                      return [2];\n                  }\n                });\n              });\n            }, e.prototype.validateSegmentation = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                return o(this, function (n) {\n                  switch (n.label) {\n                    case 0:\n                      return [4, this.evaluator.isSegmentationValid(e, t)];\n                    case 1:\n                      return [2, n.sent()];\n                  }\n                });\n              });\n            }, e;\n          }();\n        t.SegmentationManager = d;\n      },\n      6947: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SegmentOperandRegexEnum = void 0, function (e) {\n          e.LOWER = \"^lower\", e.LOWER_MATCH = \"^lower\\\\((.*)\\\\)\", e.WILDCARD = \"^wildcard\", e.WILDCARD_MATCH = \"^wildcard\\\\((.*)\\\\)\", e.REGEX = \"^regex\", e.REGEX_MATCH = \"^regex\\\\((.*)\\\\)\", e.STARTING_STAR = \"^\\\\*\", e.ENDING_STAR = \"\\\\*$\", e.GREATER_THAN_MATCH = \"^gt\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)\", e.GREATER_THAN_EQUAL_TO_MATCH = \"^gte\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)\", e.LESS_THAN_MATCH = \"^lt\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)\", e.LESS_THAN_EQUAL_TO_MATCH = \"^lte\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)\";\n        }(n || (t.SegmentOperandRegexEnum = n = {}));\n      },\n      6905: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SegmentOperandValueEnum = void 0, function (e) {\n          e[e.LOWER_VALUE = 1] = \"LOWER_VALUE\", e[e.STARTING_ENDING_STAR_VALUE = 2] = \"STARTING_ENDING_STAR_VALUE\", e[e.STARTING_STAR_VALUE = 3] = \"STARTING_STAR_VALUE\", e[e.ENDING_STAR_VALUE = 4] = \"ENDING_STAR_VALUE\", e[e.REGEX_VALUE = 5] = \"REGEX_VALUE\", e[e.EQUAL_VALUE = 6] = \"EQUAL_VALUE\", e[e.GREATER_THAN_VALUE = 7] = \"GREATER_THAN_VALUE\", e[e.GREATER_THAN_EQUAL_TO_VALUE = 8] = \"GREATER_THAN_EQUAL_TO_VALUE\", e[e.LESS_THAN_VALUE = 9] = \"LESS_THAN_VALUE\", e[e.LESS_THAN_EQUAL_TO_VALUE = 10] = \"LESS_THAN_EQUAL_TO_VALUE\";\n        }(n || (t.SegmentOperandValueEnum = n = {}));\n      },\n      4076: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SegmentOperatorValueEnum = void 0, function (e) {\n          e.AND = \"and\", e.NOT = \"not\", e.OR = \"or\", e.CUSTOM_VARIABLE = \"custom_variable\", e.USER = \"user\", e.COUNTRY = \"country\", e.REGION = \"region\", e.CITY = \"city\", e.OPERATING_SYSTEM = \"os\", e.DEVICE_TYPE = \"device_type\", e.DEVICE = \"device\", e.BROWSER_AGENT = \"browser_string\", e.UA = \"ua\", e.FEATURE_ID = \"featureId\";\n        }(n || (t.SegmentOperatorValueEnum = n = {}));\n      },\n      8011: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SegmentEvaluator = void 0;\n        var i = n(3780),\n          a = n(4580),\n          s = n(8792),\n          u = n(1359),\n          c = n(4076),\n          l = n(3769),\n          g = n(9750),\n          d = function () {\n            function e() {}\n            return e.prototype.isSegmentationValid = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r, i, a;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      switch (n = (0, l.getKeyValue)(e), r = n.key, i = n.value, a = i, r) {\n                        case c.SegmentOperatorValueEnum.NOT:\n                          return [3, 1];\n                        case c.SegmentOperatorValueEnum.AND:\n                          return [3, 3];\n                        case c.SegmentOperatorValueEnum.OR:\n                          return [3, 5];\n                        case c.SegmentOperatorValueEnum.CUSTOM_VARIABLE:\n                          return [3, 7];\n                        case c.SegmentOperatorValueEnum.USER:\n                          return [3, 9];\n                        case c.SegmentOperatorValueEnum.UA:\n                          return [3, 10];\n                      }\n                      return [3, 11];\n                    case 1:\n                      return [4, this.isSegmentationValid(a, t)];\n                    case 2:\n                      return [2, !o.sent()];\n                    case 3:\n                      return [4, this.every(a, t)];\n                    case 4:\n                    case 6:\n                    case 8:\n                      return [2, o.sent()];\n                    case 5:\n                      return [4, this.some(a, t)];\n                    case 7:\n                      return [4, new g.SegmentOperandEvaluator().evaluateCustomVariableDSL(a, t)];\n                    case 9:\n                      return [2, new g.SegmentOperandEvaluator().evaluateUserDSL(a, t)];\n                    case 10:\n                      return [2, new g.SegmentOperandEvaluator().evaluateUserAgentDSL(a, this.context)];\n                    case 11:\n                      return [2, !1];\n                  }\n                });\n              });\n            }, e.prototype.some = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r, i, s, u, l, g, d, p, f, h, v, y, m;\n                return o(this, function (E) {\n                  switch (E.label) {\n                    case 0:\n                      n = {}, r = 0, i = !1, s = 0, u = e, E.label = 1;\n                    case 1:\n                      if (!(s < u.length)) return [3, 12];\n                      for (h in l = u[s], g = function (e) {\n                        var t, s, u, g, p, f, h, v;\n                        return o(this, function (o) {\n                          switch (o.label) {\n                            case 0:\n                              return e !== c.SegmentOperatorValueEnum.OPERATING_SYSTEM && e !== c.SegmentOperatorValueEnum.BROWSER_AGENT && e !== c.SegmentOperatorValueEnum.DEVICE_TYPE && e !== c.SegmentOperatorValueEnum.DEVICE || (i = !0, t = l[e], n[e] || (n[e] = []), (Array.isArray(t) ? t : [t]).forEach(function (t) {\n                                \"string\" == typeof t && n[e].push(t);\n                              }), r++), e !== c.SegmentOperatorValueEnum.FEATURE_ID ? [3, 3] : (s = l[e], u = Object.keys(s)[0], \"on\" !== (g = s[u]) && \"off\" !== g ? [3, 3] : (p = d.settings.getFeatures(), (f = p.find(function (e) {\n                                return e.getId() === parseInt(u);\n                              })) ? (h = f.getKey(), [4, d.checkInUserStorage(d.settings, h, d.context)]) : [3, 2]));\n                            case 1:\n                              return v = o.sent(), \"off\" === g ? [2, {\n                                value: !v\n                              }] : [2, {\n                                value: v\n                              }];\n                            case 2:\n                              return a.LogManager.Instance.error(\"Feature not found with featureIdKey: \" + u), [2, {\n                                value: null\n                              }];\n                            case 3:\n                              return [2];\n                          }\n                        });\n                      }, d = this, f = [], p = l) f.push(h);\n                      v = 0, E.label = 2;\n                    case 2:\n                      return v < f.length ? (h = f[v]) in p ? [5, g(h)] : [3, 4] : [3, 5];\n                    case 3:\n                      if (\"object\" == typeof (y = E.sent())) return [2, y.value];\n                      E.label = 4;\n                    case 4:\n                      return v++, [3, 2];\n                    case 5:\n                      if (!i || r !== e.length) return [3, 9];\n                      E.label = 6;\n                    case 6:\n                      return E.trys.push([6, 8,, 9]), [4, this.checkUserAgentParser(n)];\n                    case 7:\n                      return [2, E.sent()];\n                    case 8:\n                      return m = E.sent(), a.LogManager.Instance.error(\"Failed to validate User Agent. Erro: \" + m), [3, 9];\n                    case 9:\n                      return [4, this.isSegmentationValid(l, t)];\n                    case 10:\n                      if (E.sent()) return [2, !0];\n                      E.label = 11;\n                    case 11:\n                      return s++, [3, 1];\n                    case 12:\n                      return [2, !1];\n                  }\n                });\n              });\n            }, e.prototype.every = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r, i, a;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      n = {}, r = 0, i = e, o.label = 1;\n                    case 1:\n                      return r < i.length ? (a = i[r], c.SegmentOperatorValueEnum.COUNTRY in a || c.SegmentOperatorValueEnum.REGION in a || c.SegmentOperatorValueEnum.CITY in a ? (this.addLocationValuesToMap(a, n), Object.keys(n).length !== e.length ? [3, 3] : [4, this.checkLocationPreSegmentation(n)]) : [3, 4]) : [3, 7];\n                    case 2:\n                      return [2, o.sent()];\n                    case 3:\n                      return [3, 6];\n                    case 4:\n                      return [4, this.isSegmentationValid(a, t)];\n                    case 5:\n                      if (!o.sent()) return [2, !1];\n                      o.label = 6;\n                    case 6:\n                      return r++, [3, 1];\n                    case 7:\n                      return [2, !0];\n                  }\n                });\n              });\n            }, e.prototype.addLocationValuesToMap = function (e, t) {\n              c.SegmentOperatorValueEnum.COUNTRY in e && (t[c.SegmentOperatorValueEnum.COUNTRY] = e[c.SegmentOperatorValueEnum.COUNTRY]), c.SegmentOperatorValueEnum.REGION in e && (t[c.SegmentOperatorValueEnum.REGION] = e[c.SegmentOperatorValueEnum.REGION]), c.SegmentOperatorValueEnum.CITY in e && (t[c.SegmentOperatorValueEnum.CITY] = e[c.SegmentOperatorValueEnum.CITY]);\n            }, e.prototype.checkLocationPreSegmentation = function (e) {\n              return r(this, void 0, void 0, function () {\n                var t, n, r, i, s, u, c, l, g;\n                return o(this, function (o) {\n                  return void 0 === (null === (t = this.context) || void 0 === t ? void 0 : t.getIpAddress()) ? (a.LogManager.Instance.error(\"To evaluate location pre Segment, please pass ipAddress in context object\"), [2, !1]) : (null === (r = null === (n = this.context) || void 0 === n ? void 0 : n.getVwo()) || void 0 === r ? void 0 : r.getLocation()) && void 0 !== (null === (s = null === (i = this.context) || void 0 === i ? void 0 : i.getVwo()) || void 0 === s ? void 0 : s.getLocation()) && null !== (null === (c = null === (u = this.context) || void 0 === u ? void 0 : u.getVwo()) || void 0 === c ? void 0 : c.getLocation()) ? [2, this.valuesMatch(e, null === (g = null === (l = this.context) || void 0 === l ? void 0 : l.getVwo()) || void 0 === g ? void 0 : g.getLocation())] : [2, !1];\n                });\n              });\n            }, e.prototype.checkUserAgentParser = function (e) {\n              return r(this, void 0, void 0, function () {\n                var t, n, r, i, s, u, c, l;\n                return o(this, function (o) {\n                  return (null === (t = this.context) || void 0 === t ? void 0 : t.getUserAgent()) && void 0 !== (null === (n = this.context) || void 0 === n ? void 0 : n.getUserAgent()) ? (null === (i = null === (r = this.context) || void 0 === r ? void 0 : r.getVwo()) || void 0 === i ? void 0 : i.getUaInfo()) && void 0 !== (null === (u = null === (s = this.context) || void 0 === s ? void 0 : s.getVwo()) || void 0 === u ? void 0 : u.getUaInfo()) ? [2, this.checkValuePresent(e, null === (l = null === (c = this.context) || void 0 === c ? void 0 : c.getVwo()) || void 0 === l ? void 0 : l.getUaInfo())] : [2, !1] : (a.LogManager.Instance.error(\"To evaluate user agent related segments, please pass userAgent in context object\"), [2, !1]);\n                });\n              });\n            }, e.prototype.checkInUserStorage = function (e, t, n) {\n              return r(this, void 0, void 0, function () {\n                var e, r;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      return e = new s.StorageService(), [4, new i.StorageDecorator().getFeatureFromStorage(t, n, e)];\n                    case 1:\n                      return r = o.sent(), (0, u.isObject)(r) && Object.keys(r).length > 0 ? [2, !0] : [2, !1];\n                  }\n                });\n              });\n            }, e.prototype.checkValuePresent = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r, i;\n                return o(this, function (o) {\n                  for (r in n = function (n) {\n                    if (Object.prototype.hasOwnProperty.call(e, n)) {\n                      var r = e[n];\n                      r.forEach(function (e, t) {\n                        r[t] = e.toLowerCase();\n                      });\n                      for (var o = t[n], i = 0, a = r; i < a.length; i++) {\n                        var s = a[i];\n                        if (s.startsWith(\"wildcard(\") && s.endsWith(\")\")) {\n                          var u = s.slice(9, -1);\n                          if (new RegExp(u.replace(/\\*/g, \".*\"), \"i\").test(o)) return {\n                            value: !0\n                          };\n                        }\n                      }\n                      if (r.includes(null == o ? void 0 : o.toLowerCase())) return {\n                        value: !0\n                      };\n                    }\n                  }, t) if (\"object\" == typeof (i = n(r))) return [2, i.value];\n                  return [2, !1];\n                });\n              });\n            }, e.prototype.valuesMatch = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r, i, a, s, u, c;\n                return o(this, function (o) {\n                  for (n = 0, r = Object.entries(e); n < r.length; n++) {\n                    if (i = r[n], a = i[0], s = i[1], !(a in t)) return [2, !1];\n                    if (u = this.normalizeValue(s), c = this.normalizeValue(t[a]), u !== c) return [2, !1];\n                  }\n                  return [2, !0];\n                });\n              });\n            }, e.prototype.normalizeValue = function (e) {\n              return null == e ? null : e.toString().replace(/^\"|\"$/g, \"\").trim();\n            }, e;\n          }();\n        t.SegmentEvaluator = d;\n      },\n      9750: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SegmentOperandEvaluator = void 0;\n        var i = n(3769),\n          a = n(6905),\n          s = n(6947),\n          u = n(1359),\n          c = n(2898),\n          l = n(9528),\n          g = n(4580),\n          d = function () {\n            function e() {}\n            return e.prototype.evaluateCustomVariableDSL = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r, a, s, u, d, p, f, h, v, y, m, E, I, b, _, S;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      if (n = (0, i.getKeyValue)(e), r = n.key, a = n.value, s = r, u = a, !Object.prototype.hasOwnProperty.call(t, s)) return [2, !1];\n                      if (!u.includes(\"inlist\")) return [3, 5];\n                      if (d = /inlist\\(([^:]+)\\)/, !(p = u.match(d)) || p.length < 2) return g.LogManager.Instance.error(\"Invalid 'inList' operand format\"), [2, !1];\n                      E = t[s], f = this.preProcessTagValue(E), h = p[1], v = {\n                        attribute: f,\n                        listId: h\n                      }, o.label = 1;\n                    case 1:\n                      return o.trys.push([1, 3,, 4]), [4, (0, c.getFromGatewayService)(v, l.UrlEnum.ATTRIBUTE_CHECK)];\n                    case 2:\n                      return (y = o.sent()) && void 0 !== y && \"false\" !== y && 0 !== y.status ? [2, y] : [2, !1];\n                    case 3:\n                      return m = o.sent(), g.LogManager.Instance.error(\"Error while fetching data: \" + m), [2, !1];\n                    case 4:\n                      return [3, 6];\n                    case 5:\n                      return E = t[s], E = this.preProcessTagValue(E), I = this.preProcessOperandValue(u), b = I.operandType, _ = I.operandValue, S = this.processValues(_, E), E = S.tagValue, [2, this.extractResult(b, S.operandValue, E)];\n                    case 6:\n                      return [2];\n                  }\n                });\n              });\n            }, e.prototype.evaluateUserDSL = function (e, t) {\n              for (var n = e.split(\",\"), r = 0; r < n.length; r++) if (n[r].trim() == t._vwoUserId) return !0;\n              return !1;\n            }, e.prototype.evaluateUserAgentDSL = function (e, t) {\n              var n = e;\n              if (!t.getUserAgent() || void 0 === t.getUserAgent()) return g.LogManager.Instance.info(\"To Evaluate UserAgent segmentation, please provide userAgent in context\"), !1;\n              var r = decodeURIComponent(t.getUserAgent()),\n                o = this.preProcessOperandValue(n),\n                i = o.operandType,\n                a = o.operandValue,\n                s = this.processValues(a, r);\n              return r = s.tagValue, this.extractResult(i, s.operandValue, r);\n            }, e.prototype.preProcessTagValue = function (e) {\n              return void 0 === e && (e = \"\"), (0, u.isBoolean)(e) && (e = !!e), null !== e && (e = e.toString()), e;\n            }, e.prototype.preProcessOperandValue = function (e) {\n              var t, n;\n              if ((0, i.matchWithRegex)(e, s.SegmentOperandRegexEnum.LOWER_MATCH)) t = a.SegmentOperandValueEnum.LOWER_VALUE, n = this.extractOperandValue(e, s.SegmentOperandRegexEnum.LOWER_MATCH);else if ((0, i.matchWithRegex)(e, s.SegmentOperandRegexEnum.WILDCARD_MATCH)) {\n                n = this.extractOperandValue(e, s.SegmentOperandRegexEnum.WILDCARD_MATCH);\n                var r = (0, i.matchWithRegex)(n, s.SegmentOperandRegexEnum.STARTING_STAR),\n                  o = (0, i.matchWithRegex)(n, s.SegmentOperandRegexEnum.ENDING_STAR);\n                r && o ? t = a.SegmentOperandValueEnum.STARTING_ENDING_STAR_VALUE : r ? t = a.SegmentOperandValueEnum.STARTING_STAR_VALUE : o && (t = a.SegmentOperandValueEnum.ENDING_STAR_VALUE), n = n.replace(new RegExp(s.SegmentOperandRegexEnum.STARTING_STAR), \"\").replace(new RegExp(s.SegmentOperandRegexEnum.ENDING_STAR), \"\");\n              } else (0, i.matchWithRegex)(e, s.SegmentOperandRegexEnum.REGEX_MATCH) ? (t = a.SegmentOperandValueEnum.REGEX_VALUE, n = this.extractOperandValue(e, s.SegmentOperandRegexEnum.REGEX_MATCH)) : (0, i.matchWithRegex)(e, s.SegmentOperandRegexEnum.GREATER_THAN_MATCH) ? (t = a.SegmentOperandValueEnum.GREATER_THAN_VALUE, n = this.extractOperandValue(e, s.SegmentOperandRegexEnum.GREATER_THAN_MATCH)) : (0, i.matchWithRegex)(e, s.SegmentOperandRegexEnum.GREATER_THAN_EQUAL_TO_MATCH) ? (t = a.SegmentOperandValueEnum.GREATER_THAN_EQUAL_TO_VALUE, n = this.extractOperandValue(e, s.SegmentOperandRegexEnum.GREATER_THAN_EQUAL_TO_MATCH)) : (0, i.matchWithRegex)(e, s.SegmentOperandRegexEnum.LESS_THAN_MATCH) ? (t = a.SegmentOperandValueEnum.LESS_THAN_VALUE, n = this.extractOperandValue(e, s.SegmentOperandRegexEnum.LESS_THAN_MATCH)) : (0, i.matchWithRegex)(e, s.SegmentOperandRegexEnum.LESS_THAN_EQUAL_TO_MATCH) ? (t = a.SegmentOperandValueEnum.LESS_THAN_EQUAL_TO_VALUE, n = this.extractOperandValue(e, s.SegmentOperandRegexEnum.LESS_THAN_EQUAL_TO_MATCH)) : (t = a.SegmentOperandValueEnum.EQUAL_VALUE, n = e);\n              return {\n                operandType: t,\n                operandValue: n\n              };\n            }, e.prototype.extractOperandValue = function (e, t) {\n              return (0, i.matchWithRegex)(e, t) && (0, i.matchWithRegex)(e, t)[1];\n            }, e.prototype.processValues = function (e, t) {\n              var n = parseFloat(e),\n                r = parseFloat(t);\n              return n && r ? {\n                operandValue: n.toString(),\n                tagValue: r.toString()\n              } : {\n                operandValue: e,\n                tagValue: t\n              };\n            }, e.prototype.extractResult = function (e, t, n) {\n              var r;\n              switch (e) {\n                case a.SegmentOperandValueEnum.LOWER_VALUE:\n                  null !== n && (r = t.toLowerCase() === n.toLowerCase());\n                  break;\n                case a.SegmentOperandValueEnum.STARTING_ENDING_STAR_VALUE:\n                  null !== n && (r = n.indexOf(t) > -1);\n                  break;\n                case a.SegmentOperandValueEnum.STARTING_STAR_VALUE:\n                  null !== n && (r = n.endsWith(t));\n                  break;\n                case a.SegmentOperandValueEnum.ENDING_STAR_VALUE:\n                  null !== n && (r = n.startsWith(t));\n                  break;\n                case a.SegmentOperandValueEnum.REGEX_VALUE:\n                  try {\n                    r = !!new RegExp(t, \"g\").test(n);\n                  } catch (e) {\n                    r = !1;\n                  }\n                  break;\n                case a.SegmentOperandValueEnum.GREATER_THAN_VALUE:\n                  if (null !== n) try {\n                    r = parseFloat(t) < parseFloat(n);\n                  } catch (e) {\n                    r = !1;\n                  }\n                  break;\n                case a.SegmentOperandValueEnum.GREATER_THAN_EQUAL_TO_VALUE:\n                  if (null !== n) try {\n                    r = parseFloat(t) <= parseFloat(n);\n                  } catch (e) {\n                    r = !1;\n                  }\n                  break;\n                case a.SegmentOperandValueEnum.LESS_THAN_VALUE:\n                  if (null !== n) try {\n                    r = parseFloat(t) > parseFloat(n);\n                  } catch (e) {\n                    r = !1;\n                  }\n                  break;\n                case a.SegmentOperandValueEnum.LESS_THAN_EQUAL_TO_VALUE:\n                  if (null !== n) try {\n                    r = parseFloat(t) >= parseFloat(n);\n                  } catch (e) {\n                    r = !1;\n                  }\n                  break;\n                default:\n                  r = n === t;\n              }\n              return r;\n            }, e;\n          }();\n        t.SegmentOperandEvaluator = d;\n      },\n      4986: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SegmentEvaluator = t.SegmentationManager = void 0;\n        var r = n(6373);\n        Object.defineProperty(t, \"SegmentationManager\", {\n          enumerable: !0,\n          get: function () {\n            return r.SegmentationManager;\n          }\n        });\n        var o = n(8011);\n        Object.defineProperty(t, \"SegmentEvaluator\", {\n          enumerable: !0,\n          get: function () {\n            return o.SegmentEvaluator;\n          }\n        });\n      },\n      3769: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.matchWithRegex = t.getKeyValue = void 0;\n        var r = n(1359);\n        t.getKeyValue = function (e) {\n          if ((0, r.isObject)(e)) {\n            var t = Object.keys(e)[0];\n            return {\n              key: t,\n              value: e[t]\n            };\n          }\n        }, t.matchWithRegex = function (e, t) {\n          try {\n            return e.match(new RegExp(t));\n          } catch (e) {\n            return null;\n          }\n        };\n      },\n      5030: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Connector = void 0;\n        t.Connector = function () {};\n      },\n      2780: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Storage = void 0;\n        var n = function () {\n          function e() {}\n          return e.prototype.attachConnector = function (e) {\n            var t, n, r, o;\n            return \"class\" === (null === (o = null === (r = null === (n = null === (t = null == e ? void 0 : e.prototype) || void 0 === t ? void 0 : t.constructor) || void 0 === n ? void 0 : n.toString()) || void 0 === r ? void 0 : r.trim()) || void 0 === o ? void 0 : o.substring(0, 5)) ? this.connector = new e() : this.connector = e, this.connector;\n          }, Object.defineProperty(e, \"Instance\", {\n            get: function () {\n              return this.instance = this.instance || new e(), this.instance;\n            },\n            enumerable: !1,\n            configurable: !0\n          }), e.prototype.getConnector = function () {\n            return this.connector;\n          }, e;\n        }();\n        t.Storage = n;\n      },\n      9401: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Storage = void 0;\n        var r = n(2780);\n        Object.defineProperty(t, \"Storage\", {\n          enumerable: !0,\n          get: function () {\n            return r.Storage;\n          }\n        });\n      },\n      973: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.CampaignDecisionService = void 0;\n        var i = n(6775),\n          a = n(4580),\n          s = n(4986),\n          u = n(5399),\n          c = n(4273),\n          l = n(7128),\n          g = n(1359),\n          d = n(8754),\n          p = function () {\n            function e() {}\n            return e.prototype.isUserPartOfCampaign = function (e, t) {\n              if (!t || !e) return !1;\n              var n;\n              n = t.getType() === c.CampaignTypeEnum.ROLLOUT || t.getType() === c.CampaignTypeEnum.PERSONALIZE ? t.getVariations()[0].getWeight() : t.getTraffic();\n              var r = new i.DecisionMaker().getBucketValueForUser(\"\".concat(t.getId(), \"_\").concat(e)),\n                o = 0 !== r && r <= n;\n              return a.LogManager.Instance.info((0, d.buildMessage)(l.InfoLogMessagesEnum.USER_PART_OF_CAMPAIGN, {\n                userId: e,\n                notPart: o ? \"\" : \"not\",\n                campaignKey: t.getKey()\n              })), o;\n            }, e.prototype.getVariation = function (e, t) {\n              for (var n = 0; n < e.length; n++) {\n                var r = e[n];\n                if (t >= r.getStartRangeVariation() && t <= r.getEndRangeVariation()) return r;\n              }\n              return null;\n            }, e.prototype.checkInRange = function (e, t) {\n              if (t >= e.getStartRangeVariation() && t <= e.getEndRangeVariation()) return e;\n            }, e.prototype.bucketUserToVariation = function (e, t, n) {\n              var r;\n              if (!n || !e) return null;\n              n.getTraffic() && (r = 1);\n              var o = n.getTraffic(),\n                s = new i.DecisionMaker().generateHashValue(\"\".concat(n.getId(), \"_\").concat(t, \"_\").concat(e)),\n                c = new i.DecisionMaker().generateBucketValue(s, u.Constants.MAX_TRAFFIC_VALUE, r);\n              return a.LogManager.Instance.debug((0, d.buildMessage)(l.DebugLogMessagesEnum.USER_BUCKET_TO_VARIATION, {\n                userId: e,\n                campaignKey: n.getKey(),\n                percentTraffic: o,\n                bucketValue: c,\n                hashValue: s\n              })), this.getVariation(n.getVariations(), c);\n            }, e.prototype.getPreSegmentationDecision = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r;\n                return o(this, function (o) {\n                  switch (o.label) {\n                    case 0:\n                      return n = e.getType(), r = {}, n === c.CampaignTypeEnum.ROLLOUT || n === c.CampaignTypeEnum.PERSONALIZE ? r = e.getVariations()[0].getSegments() : n === c.CampaignTypeEnum.AB && (r = e.getSegments()), !(0, g.isObject)(r) || Object.keys(r).length ? [3, 1] : (a.LogManager.Instance.info((0, d.buildMessage)(l.InfoLogMessagesEnum.SEGMENTATION_SKIP, {\n                        userId: t.getId(),\n                        campaignKey: e.getRuleKey()\n                      })), [2, !0]);\n                    case 1:\n                      return [4, s.SegmentationManager.Instance.validateSegmentation(r, t.getCustomVariables())];\n                    case 2:\n                      return o.sent() ? (a.LogManager.Instance.info((0, d.buildMessage)(l.InfoLogMessagesEnum.SEGMENTATION_STATUS, {\n                        userId: t.getId(),\n                        campaignKey: e.getRuleKey(),\n                        status: \"passed\"\n                      })), [2, !0]) : (a.LogManager.Instance.info((0, d.buildMessage)(l.InfoLogMessagesEnum.SEGMENTATION_STATUS, {\n                        userId: t.getId(),\n                        campaignKey: e.getRuleKey(),\n                        status: \"failed\"\n                      })), [2, !1]);\n                  }\n                });\n              });\n            }, e.prototype.getVariationAlloted = function (e, t, n) {\n              var r = this.isUserPartOfCampaign(e, n);\n              return n.getType() === c.CampaignTypeEnum.ROLLOUT || n.getType() === c.CampaignTypeEnum.PERSONALIZE ? r ? n.getVariations()[0] : null : r ? this.bucketUserToVariation(e, t, n) : null;\n            }, e;\n          }();\n        t.CampaignDecisionService = p;\n      },\n      7675: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        var r = n(1359),\n          o = function () {\n            function e(e) {\n              var t;\n              this.callback = null === (t = e.integrations) || void 0 === t ? void 0 : t.callback, this.isCallBackFunction = (0, r.isFunction)(this.callback), this.decision = {};\n            }\n            return e.prototype.execute = function (e) {\n              this.isCallBackFunction && this.callback(e);\n            }, e.prototype.set = function (e) {\n              this.isCallBackFunction && (this.decision = e);\n            }, e.prototype.get = function () {\n              return this.decision;\n            }, e;\n          }();\n        t.default = o;\n      },\n      470: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SettingsService = void 0;\n        var i = n(4580),\n          a = n(6710),\n          s = n(4782),\n          u = n(5399),\n          c = n(2346),\n          l = n(8202),\n          g = n(7128),\n          d = n(9846),\n          p = n(8754),\n          f = n(8925),\n          h = function () {\n            function e(t) {\n              var n, r, o, a, s;\n              if (this.isGatewayServiceProvided = !1, this.sdkKey = t.sdkKey, this.accountId = t.accountId, this.expiry = (null === (n = null == t ? void 0 : t.settings) || void 0 === n ? void 0 : n.expiry) || u.Constants.SETTINGS_EXPIRY, this.networkTimeout = (null === (r = null == t ? void 0 : t.settings) || void 0 === r ? void 0 : r.timeout) || u.Constants.SETTINGS_TIMEOUT, null === (o = null == t ? void 0 : t.gatewayService) || void 0 === o ? void 0 : o.url) {\n                var l = void 0;\n                this.isGatewayServiceProvided = !0, l = t.gatewayService.url.startsWith(c.HTTP_PROTOCOL) || t.gatewayService.url.startsWith(c.HTTPS_PROTOCOL) ? new URL(\"\".concat(t.gatewayService.url)) : (null === (a = t.gatewayService) || void 0 === a ? void 0 : a.protocol) ? new URL(\"\".concat(t.gatewayService.protocol, \"://\").concat(t.gatewayService.url)) : new URL(\"\".concat(c.HTTPS_PROTOCOL).concat(t.gatewayService.url)), this.hostname = l.hostname, this.protocol = l.protocol.replace(\":\", \"\"), l.port ? this.port = parseInt(l.port) : (null === (s = t.gatewayService) || void 0 === s ? void 0 : s.port) && (this.port = t.gatewayService.port);\n              } else this.hostname = u.Constants.HOST_NAME;\n              i.LogManager.Instance.debug((0, p.buildMessage)(g.DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n                service: \"Settings Manager\"\n              })), e.instance = this;\n            }\n            return Object.defineProperty(e, \"Instance\", {\n              get: function () {\n                return e.instance;\n              },\n              enumerable: !1,\n              configurable: !0\n            }), e.prototype.setSettingsExpiry = function () {\n              var e = this,\n                t = setTimeout(function () {\n                  e.fetchSettingsAndCacheInStorage().then(function () {\n                    clearTimeout(t), e.setSettingsExpiry();\n                  });\n                }, this.expiry);\n            }, e.prototype.fetchSettingsAndCacheInStorage = function () {\n              var e = this,\n                t = new s.Deferred();\n              return this.fetchSettings().then(function (n) {\n                return r(e, void 0, void 0, function () {\n                  return o(this, function (e) {\n                    return t.resolve(n), [2];\n                  });\n                });\n              }).catch(function (e) {\n                i.LogManager.Instance.error((0, p.buildMessage)(g.ErrorLogMessagesEnum.SETTINGS_FETCH_ERROR, {\n                  err: JSON.stringify(e)\n                })), t.resolve(null);\n              }), t.promise;\n            }, e.prototype.fetchSettings = function () {\n              var e = new s.Deferred();\n              this.sdkKey && this.accountId || e.reject(new Error(\"sdkKey is required for fetching account settings. Aborting!\"));\n              var t = a.NetworkManager.Instance,\n                n = (0, f.getSettingsPath)(this.sdkKey, this.accountId);\n              n.platform = u.Constants.PLATFORM, n[\"api-version\"] = u.Constants.API_VERSION, t.getConfig().getDevelopmentMode() || (n.s = \"prod\");\n              try {\n                var r = new a.RequestModel(this.hostname, l.HttpMethodEnum.GET, u.Constants.SETTINTS_ENDPOINT, n, null, null, this.protocol, this.port);\n                return r.setTimeout(this.networkTimeout), t.get(r).then(function (t) {\n                  e.resolve(t.getData());\n                }).catch(function (t) {\n                  e.reject(t);\n                }), e.promise;\n              } catch (t) {\n                return i.LogManager.Instance.error((0, p.buildMessage)(g.ErrorLogMessagesEnum.SETTINGS_FETCH_ERROR, {\n                  err: JSON.stringify(t)\n                })), e.reject(t), e.promise;\n              }\n            }, e.prototype.getSettings = function (e) {\n              void 0 === e && (e = !1);\n              var t = new s.Deferred();\n              return e ? this.fetchSettingsAndCacheInStorage().then(function (e) {\n                t.resolve(e);\n              }) : this.fetchSettingsAndCacheInStorage().then(function (e) {\n                new d.SettingsSchema().isSettingsValid(e) ? (i.LogManager.Instance.info(g.InfoLogMessagesEnum.SETTINGS_FETCH_SUCCESS), t.resolve(e)) : (i.LogManager.Instance.error(g.ErrorLogMessagesEnum.SETTINGS_SCHEMA_INVALID), t.resolve({}));\n              }), t.promise;\n            }, e;\n          }();\n        t.SettingsService = h;\n      },\n      8792: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.StorageService = void 0;\n        var i = n(1172),\n          a = n(9401),\n          s = n(7128),\n          u = n(4580),\n          c = n(1359),\n          l = n(8754),\n          g = n(4782),\n          d = function () {\n            function e() {\n              this.storageData = {};\n            }\n            return e.prototype.getDataInStorage = function (e, t) {\n              return r(this, void 0, void 0, function () {\n                var n, r;\n                return o(this, function (o) {\n                  return n = new g.Deferred(), r = a.Storage.Instance.getConnector(), (0, c.isNull)(r) || (0, c.isUndefined)(r) ? n.resolve(i.StorageEnum.STORAGE_UNDEFINED) : r.get(e, t.getId()).then(function (e) {\n                    n.resolve(e);\n                  }).catch(function (e) {\n                    u.LogManager.Instance.error((0, l.buildMessage)(s.ErrorLogMessagesEnum.STORED_DATA_ERROR, {\n                      err: e\n                    })), n.resolve(i.StorageEnum.NO_DATA_FOUND);\n                  }), [2, n.promise];\n                });\n              });\n            }, e.prototype.setDataInStorage = function (e) {\n              return r(this, void 0, void 0, function () {\n                var t, n;\n                return o(this, function (r) {\n                  return t = new g.Deferred(), null == (n = a.Storage.Instance.getConnector()) ? t.resolve(!1) : n.set(e).then(function () {\n                    t.resolve(!0);\n                  }).catch(function () {\n                    t.resolve(!1);\n                  }), [2, t.promise];\n                });\n              });\n            }, e;\n          }();\n        t.StorageService = d;\n      },\n      9181: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getRuleTypeUsingCampaignIdFromFeature = t.assignRangeValuesMEG = t.getCampaignIdsFromFeatureKey = t.getFeatureKeysFromCampaignIds = t.getCampaignsByGroupId = t.findGroupsFeaturePartOf = t.getGroupDetailsIfCampaignPartOfIt = t.setCampaignAllocation = t.getVariationFromCampaignKey = t.getBucketingSeed = t.scaleVariationWeights = t.assignRangeValues = t.setVariationAllocation = void 0;\n        var r = n(5399),\n          o = n(4273),\n          i = n(7128),\n          a = n(2365),\n          s = n(4580),\n          u = n(8754);\n        function c(e, t) {\n          var n = d(e.getWeight());\n          return n ? (e.setStartRange(t + 1), e.setEndRange(t + n)) : (e.setStartRange(-1), e.setEndRange(-1)), n;\n        }\n        function l(e, t) {\n          return t in e.getCampaignGroups() && e.getCampaignGroups() ? {\n            groupId: e.getCampaignGroups()[t],\n            groupName: e.getGroups()[e.getCampaignGroups()[t]].name\n          } : {};\n        }\n        function g(e, t) {\n          var n = d(e.weight);\n          return n ? (e.startRangeVariation = t + 1, e.endRangeVariation = t + n) : (e.startRangeVariation = -1, e.endRangeVariation = -1), n;\n        }\n        function d(e) {\n          if (!e || 0 === e) return 0;\n          var t = Math.ceil(100 * e);\n          return Math.min(t, r.Constants.MAX_TRAFFIC_VALUE);\n        }\n        t.setVariationAllocation = function (e) {\n          if (e.getType() === o.CampaignTypeEnum.ROLLOUT || e.getType() === o.CampaignTypeEnum.PERSONALIZE) !function (e) {\n            for (var t = 0; t < e.getVariations().length; t++) {\n              var n = e.getVariations()[t],\n                r = 100 * e.getVariations()[t].getWeight();\n              n.setStartRange(1), n.setEndRange(r), s.LogManager.Instance.info((0, u.buildMessage)(i.InfoLogMessagesEnum.VARIATION_RANGE_ALLOCATION, {\n                variationKey: n.getKey(),\n                campaignKey: e.getKey(),\n                variationWeight: n.getWeight(),\n                startRange: 1,\n                endRange: r\n              }));\n            }\n          }(e);else {\n            var t = 0;\n            e.getVariations().forEach(function (n) {\n              var r = c(n, t);\n              t += r, s.LogManager.Instance.info((0, u.buildMessage)(i.InfoLogMessagesEnum.VARIATION_RANGE_ALLOCATION, {\n                variationKey: n.getKey(),\n                campaignKey: e.getKey(),\n                variationWeight: n.getWeight(),\n                startRange: n.getStartRangeVariation(),\n                endRange: n.getEndRangeVariation()\n              }));\n            });\n          }\n        }, t.assignRangeValues = c, t.scaleVariationWeights = function (e) {\n          var t = e.reduce(function (e, t) {\n            return e + t.weight;\n          }, 0);\n          if (t) e.forEach(function (e) {\n            return e.weight = e.weight / t * 100;\n          });else {\n            var n = 100 / e.length;\n            e.forEach(function (e) {\n              return e.weight = n;\n            });\n          }\n        }, t.getBucketingSeed = function (e, t, n) {\n          return n ? \"\".concat(n, \"_\").concat(e) : \"\".concat(t.getId(), \"_\").concat(e);\n        }, t.getVariationFromCampaignKey = function (e, t, n) {\n          var r = e.getCampaigns().find(function (e) {\n            return e.getKey() === t;\n          });\n          if (r) {\n            var o = r.getVariations().find(function (e) {\n              return e.getId() === n;\n            });\n            if (o) return new a.VariationModel().modelFromDictionary(o);\n          }\n          return null;\n        }, t.setCampaignAllocation = function (e) {\n          for (var t = 0, n = 0; t < e.length; t++) n += g(e[t], n);\n        }, t.getGroupDetailsIfCampaignPartOfIt = l, t.findGroupsFeaturePartOf = function (e, t) {\n          var n = [];\n          e.getFeatures().forEach(function (e) {\n            e.getKey() === t && e.getRules().forEach(function (e) {\n              -1 === n.indexOf(e.getCampaignId()) && n.push(e.getCampaignId());\n            });\n          });\n          var r = [];\n          return n.forEach(function (t) {\n            var n = l(e, t);\n            n.groupId && -1 === r.findIndex(function (e) {\n              return e.groupId === n.groupId;\n            }) && r.push(n);\n          }), r;\n        }, t.getCampaignsByGroupId = function (e, t) {\n          var n = e.getGroups()[t];\n          return n ? n.campaigns : [];\n        }, t.getFeatureKeysFromCampaignIds = function (e, t) {\n          for (var n = [], r = function (t) {\n              e.getFeatures().forEach(function (e) {\n                e.getRules().forEach(function (r) {\n                  r.getCampaignId() === t && n.push(e.getKey());\n                });\n              });\n            }, o = 0, i = t; o < i.length; o++) r(i[o]);\n          return n;\n        }, t.getCampaignIdsFromFeatureKey = function (e, t) {\n          var n = [];\n          return e.getFeatures().forEach(function (e) {\n            e.getKey() === t && e.getRules().forEach(function (e) {\n              n.push(e.getCampaignId());\n            });\n          }), n;\n        }, t.assignRangeValuesMEG = g, t.getRuleTypeUsingCampaignIdFromFeature = function (e, t) {\n          var n = e.getRules().find(function (e) {\n            return e.getCampaignId() === t;\n          });\n          return n ? n.getType() : \"\";\n        };\n      },\n      1359: (e, t) => {\n        \"use strict\";\n\n        function n(e) {\n          return \"[object Object]\" === Object.prototype.toString.call(e);\n        }\n        function r(e) {\n          return \"[object Array]\" === Object.prototype.toString.call(e);\n        }\n        function o(e) {\n          return \"[object Null]\" === Object.prototype.toString.call(e);\n        }\n        function i(e) {\n          return \"[object Undefined]\" === Object.prototype.toString.call(e);\n        }\n        function a(e) {\n          return \"[object Number]\" === Object.prototype.toString.call(e);\n        }\n        function s(e) {\n          return \"[object String]\" === Object.prototype.toString.call(e);\n        }\n        function u(e) {\n          return \"[object Boolean]\" === Object.prototype.toString.call(e);\n        }\n        function c(e) {\n          return e != e;\n        }\n        function l(e) {\n          return \"[object Date]\" === Object.prototype.toString.call(e);\n        }\n        function g(e) {\n          return \"[object Function]\" === Object.prototype.toString.call(e);\n        }\n        function d(e) {\n          return \"[object RegExp]\" === Object.prototype.toString.call(e);\n        }\n        function p(e) {\n          return \"[object Promise]\" === Object.prototype.toString.call(e);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getType = t.isPromise = t.isRegex = t.isFunction = t.isDate = t.isNaN = t.isBoolean = t.isString = t.isNumber = t.isDefined = t.isUndefined = t.isNull = t.isArray = t.isObject = void 0, t.isObject = n, t.isArray = r, t.isNull = o, t.isUndefined = i, t.isDefined = function (e) {\n          return !i(e) && !o(e);\n        }, t.isNumber = a, t.isString = s, t.isBoolean = u, t.isNaN = c, t.isDate = l, t.isFunction = g, t.isRegex = d, t.isPromise = p, t.getType = function (e) {\n          return n(e) ? \"Object\" : r(e) ? \"Array\" : o(e) ? \"Null\" : i(e) ? \"Undefined\" : c(e) ? \"NaN\" : a(e) ? \"Number\" : s(e) ? \"String\" : u(e) ? \"Boolean\" : l(e) ? \"Date\" : d(e) ? \"Regex\" : g(e) ? \"Function\" : p(e) ? \"Promise\" : \"Unknown Type\";\n        };\n      },\n      2245: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.evaluateTrafficAndGetVariation = t.checkWhitelistingAndPreSeg = void 0;\n        var i = n(1359),\n          a = n(4273),\n          s = n(9217),\n          u = n(7128),\n          c = n(6775),\n          l = n(4580),\n          g = n(4986),\n          d = n(973),\n          p = n(1359),\n          f = n(9181),\n          h = n(8667),\n          v = n(8754),\n          y = n(7928),\n          m = n(1720);\n        t.checkWhitelistingAndPreSeg = function (e, t, n, i, s, c, g, p) {\n          return r(void 0, void 0, void 0, function () {\n            var r, h, I, b, _, S, T;\n            return o(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  return r = (0, m.getUUID)(i.getId(), e.getAccountId()), h = n.getId(), n.getType() !== a.CampaignTypeEnum.AB ? [3, 3] : (i.setVariationTargetingVariables(Object.assign({}, i.getVariationTargetingVariables(), {\n                    _vwoUserId: n.getIsUserListEnabled() ? r : i.getId()\n                  })), Object.assign(p, {\n                    variationTargetingVariables: i.getVariationTargetingVariables()\n                  }), n.getIsForcedVariationEnabled() ? [4, E(n, i)] : [3, 2]);\n                case 1:\n                  return (I = o.sent()) && Object.keys(I).length > 0 ? [2, [!0, I]] : [3, 3];\n                case 2:\n                  l.LogManager.Instance.info((0, v.buildMessage)(u.InfoLogMessagesEnum.WHITELISTING_SKIP, {\n                    campaignKey: n.getRuleKey(),\n                    userId: i.getId()\n                  })), o.label = 3;\n                case 3:\n                  return i.setCustomVariables(Object.assign({}, i.getCustomVariables(), {\n                    _vwoUserId: n.getIsUserListEnabled() ? r : i.getId()\n                  })), Object.assign(p, {\n                    customVariables: i.getCustomVariables()\n                  }), b = (0, f.getGroupDetailsIfCampaignPartOfIt)(e, h).groupId, (_ = null == c ? void 0 : c.get(b)) ? _ === h ? [2, [!0, null]] : [2, [!1, null]] : [4, new d.CampaignDecisionService().getPreSegmentationDecision(n, i)];\n                case 4:\n                  return (S = o.sent()) && b ? [4, (0, y.evaluateGroups)(e, t, b, s, i, g)] : [3, 6];\n                case 5:\n                  return (T = o.sent()) && T.id === h ? [2, [!0, null]] : (c.set(b, (null == T ? void 0 : T.id) || 0), [2, [!1, null]]);\n                case 6:\n                  return [2, [S, null]];\n              }\n            });\n          });\n        }, t.evaluateTrafficAndGetVariation = function (e, t, n) {\n          var r = new d.CampaignDecisionService().getVariationAlloted(n, e.getAccountId(), t);\n          return r ? (l.LogManager.Instance.info((0, v.buildMessage)(u.InfoLogMessagesEnum.USER_CAMPAIGN_BUCKET_INFO, {\n            campaignKey: t.getKey(),\n            userId: n,\n            status: \"got variation:\".concat(r.getKey())\n          })), r) : (l.LogManager.Instance.info((0, v.buildMessage)(u.InfoLogMessagesEnum.USER_CAMPAIGN_BUCKET_INFO, {\n            campaignKey: t.getKey(),\n            userId: n,\n            status: \"did not get any variation\"\n          })), null);\n        };\n        var E = function (e, t) {\n            return r(void 0, void 0, void 0, function () {\n              var n, r, i;\n              return o(this, function (o) {\n                switch (o.label) {\n                  case 0:\n                    return [4, I(e, t)];\n                  case 1:\n                    return n = o.sent(), r = n ? s.StatusEnum.PASSED : s.StatusEnum.FAILED, i = n ? n.variation.key : \"\", l.LogManager.Instance.info((0, v.buildMessage)(u.InfoLogMessagesEnum.WHITELISTING_STATUS, {\n                      userId: t.getId(),\n                      campaignKey: e.getRuleKey(),\n                      status: r,\n                      variationString: i\n                    })), [2, n];\n                }\n              });\n            });\n          },\n          I = function (e, t) {\n            return r(void 0, void 0, void 0, function () {\n              var n, r, a, s, y, m;\n              return o(this, function (o) {\n                switch (o.label) {\n                  case 0:\n                    return n = [], r = [], e.getVariations().forEach(function (o) {\n                      if (!(0, p.isObject)(o.getSegments()) || Object.keys(o.getSegments()).length) {\n                        if ((0, p.isObject)(o.getSegments())) {\n                          var a = g.SegmentationManager.Instance.validateSegmentation(o.getSegments(), t.getVariationTargetingVariables());\n                          (a = (0, i.isPromise)(a) ? a : Promise.resolve(a)).then(function (e) {\n                            e && n.push((0, h.cloneObject)(o));\n                          }), r.push(a);\n                        }\n                      } else l.LogManager.Instance.info((0, v.buildMessage)(u.InfoLogMessagesEnum.WHITELISTING_SKIP, {\n                        campaignKey: e.getRuleKey(),\n                        userId: t.getId(),\n                        variation: o.getKey() ? \"for variation: \".concat(o.getKey()) : \"\"\n                      }));\n                    }), [4, Promise.all(r)];\n                  case 1:\n                    if (o.sent(), n.length > 1) {\n                      for ((0, f.scaleVariationWeights)(n), s = 0, y = 0, m = 0; s < n.length; s++) m = (0, f.assignRangeValues)(n[s], y), y += m;\n                      a = new d.CampaignDecisionService().getVariation(n, new c.DecisionMaker().calculateBucketValue((0, f.getBucketingSeed)(t.getId(), e, null)));\n                    } else a = n[0];\n                    return a ? [2, {\n                      variation: a,\n                      variationName: a.name,\n                      variationId: a.id\n                    }] : [2];\n                }\n              });\n            });\n          };\n      },\n      8667: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__assign || function () {\n          return r = Object.assign || function (e) {\n            for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n            return e;\n          }, r.apply(this, arguments);\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.addLinkedCampaignsToSettings = t.doesEventBelongToAnyFeature = t.getFeatureFromKey = t.getAllExperimentRules = t.getSpecificRulesBasedOnType = t.getRandomNumber = t.getCurrentUnixTimestampInMillis = t.getCurrentUnixTimestamp = t.cloneObject = void 0;\n        var o = n(4273),\n          i = n(2144),\n          a = n(1359);\n        t.cloneObject = function (e) {\n          return e ? JSON.parse(JSON.stringify(e)) : e;\n        }, t.getCurrentUnixTimestamp = function () {\n          return Math.ceil(+new Date() / 1e3);\n        }, t.getCurrentUnixTimestampInMillis = function () {\n          return +new Date();\n        }, t.getRandomNumber = function () {\n          return Math.random();\n        }, t.getSpecificRulesBasedOnType = function (e, t) {\n          return void 0 === t && (t = null), e && !(null == e ? void 0 : e.getRulesLinkedCampaign()) ? [] : e && e.getRulesLinkedCampaign() && t && (0, a.isString)(t) ? e.getRulesLinkedCampaign().filter(function (e) {\n            return new i.CampaignModel().modelFromDictionary(e).getType() === t;\n          }) : e.getRulesLinkedCampaign();\n        }, t.getAllExperimentRules = function (e) {\n          return (null == e ? void 0 : e.getRulesLinkedCampaign().filter(function (e) {\n            return e.getType() === o.CampaignTypeEnum.AB || e.getType() === o.CampaignTypeEnum.PERSONALIZE;\n          })) || [];\n        }, t.getFeatureFromKey = function (e, t) {\n          var n;\n          return null === (n = null == e ? void 0 : e.getFeatures()) || void 0 === n ? void 0 : n.find(function (e) {\n            return e.getKey() === t;\n          });\n        }, t.doesEventBelongToAnyFeature = function (e, t) {\n          return t.getFeatures().some(function (t) {\n            return t.getMetrics().some(function (t) {\n              return t.getIdentifier() === e;\n            });\n          });\n        }, t.addLinkedCampaignsToSettings = function (e) {\n          for (var t = new Map(e.getCampaigns().map(function (e) {\n              return [e.getId(), e];\n            })), n = 0, o = e.getFeatures(); n < o.length; n++) {\n            var a = o[n],\n              s = a.getRules().map(function (e) {\n                var n = t.get(e.getCampaignId());\n                if (!n) return null;\n                var o = r(r({\n                  key: n.getKey()\n                }, n), {\n                  ruleKey: e.getRuleKey()\n                });\n                if (e.getVariationId()) {\n                  var i = n.getVariations().find(function (t) {\n                    return t.getId() === e.getVariationId();\n                  });\n                  i && (o.variations = [i]);\n                }\n                return o;\n              }).filter(function (e) {\n                return null !== e;\n              }).map(function (e) {\n                var t = new i.CampaignModel();\n                return t.modelFromDictionary(e), t;\n              });\n            a.setRulesLinkedCampaign(s);\n          }\n        };\n      },\n      2898: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.addIsGatewayServiceRequiredFlag = t.getQueryParams = t.getFromGatewayService = void 0;\n        var i = n(4273),\n          a = n(8202),\n          s = n(7128),\n          u = n(4580),\n          c = n(6710),\n          l = n(470),\n          g = n(4782),\n          d = n(8694);\n        t.getFromGatewayService = function (e, t) {\n          return r(this, void 0, void 0, function () {\n            var n, r, i;\n            return o(this, function (o) {\n              if (n = new g.Deferred(), r = c.NetworkManager.Instance, !l.SettingsService.Instance.isGatewayServiceProvided) return u.LogManager.Instance.error(s.ErrorLogMessagesEnum.GATEWAY_URL_ERROR), n.resolve(!1), [2, n.promise];\n              try {\n                return i = new c.RequestModel(d.UrlUtil.getBaseUrl(), a.HttpMethodEnum.GET, t, e, null, null, l.SettingsService.Instance.protocol, l.SettingsService.Instance.port), r.get(i).then(function (e) {\n                  n.resolve(e.getData());\n                }).catch(function (e) {\n                  n.reject(e);\n                }), [2, n.promise];\n              } catch (e) {\n                return n.resolve(!1), [2, n.promise];\n              }\n              return [2];\n            });\n          });\n        }, t.getQueryParams = function (e) {\n          for (var t = {}, n = 0, r = Object.entries(e); n < r.length; n++) {\n            var o = r[n],\n              i = o[0],\n              a = o[1],\n              s = encodeURIComponent(String(a));\n            t[i] = s;\n          }\n          return t;\n        }, t.addIsGatewayServiceRequiredFlag = function (e) {\n          for (var t = /\\b(?<!\"custom_variable\"[^}]*)(country|region|city|os|device_type|browser_string|ua)\\b|(?<=\"custom_variable\"\\s*:\\s*{\\s*\"name\"\\s*:\\s*\")inlist\\([^)]*\\)(?=\")/g, n = 0, r = e.getFeatures(); n < r.length; n++) for (var o = r[n], a = 0, s = o.getRulesLinkedCampaign(); a < s.length; a++) {\n            var u,\n              c = s[a];\n            if (u = c.getType() === i.CampaignTypeEnum.PERSONALIZE || c.getType() === i.CampaignTypeEnum.ROLLOUT ? c.getVariations()[0].getSegments() : c.getSegments()) {\n              var l = JSON.stringify(u).match(t);\n              if (l && l.length > 0) {\n                o.setIsGatewayServiceRequired(!0);\n                break;\n              }\n            }\n          }\n        };\n      },\n      162: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createAndSendImpressionForVariationShown = void 0;\n        var i = n(8925),\n          a = n(9693);\n        t.createAndSendImpressionForVariationShown = function (e, t, n, s) {\n          return r(void 0, void 0, void 0, function () {\n            var r, u;\n            return o(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  return r = (0, i.getEventsBaseProperties)(e, a.EventEnum.VWO_VARIATION_SHOWN, encodeURIComponent(s.getUserAgent()), s.getIpAddress()), u = (0, i.getTrackUserPayloadData)(e, s.getId(), a.EventEnum.VWO_VARIATION_SHOWN, t, n, s.getUserAgent(), s.getIpAddress()), [4, (0, i.sendPostApiRequest)(r, u)];\n                case 1:\n                  return o.sent(), [2];\n              }\n            });\n          });\n        };\n      },\n      8754: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.buildMessage = void 0;\n        var r = n(1359),\n          o = /\\{([0-9a-zA-Z_]+)\\}/g;\n        t.buildMessage = function (e, t) {\n          void 0 === t && (t = {});\n          try {\n            return e.replace(o, function (n, o, i) {\n              if (\"{\" === e[i - 1] && \"}\" === e[i + n.length]) return o;\n              var a = t[o];\n              return null == a ? \"\" : (0, r.isFunction)(a) ? a() : a;\n            });\n          } catch (t) {\n            return e;\n          }\n        };\n      },\n      7928: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getFeatureKeysFromGroup = t.evaluateGroups = void 0;\n        var i = n(5399),\n          a = n(3780),\n          s = n(4273),\n          u = n(7128),\n          c = n(2144),\n          l = n(2365),\n          g = n(6775),\n          d = n(4580),\n          p = n(973),\n          f = n(6195),\n          h = n(9181),\n          v = n(1359),\n          y = n(2245),\n          m = n(8667),\n          E = n(8754);\n        function I(e, t) {\n          var n = (0, h.getCampaignsByGroupId)(e, t);\n          return {\n            featureKeys: (0, h.getFeatureKeysFromCampaignIds)(e, n),\n            groupCampaignIds: n\n          };\n        }\n        t.evaluateGroups = function (e, t, n, i, a, s) {\n          return r(void 0, void 0, void 0, function () {\n            var r, u, c, l, g, d, p, f, v, y, E, T;\n            return o(this, function (O) {\n              switch (O.label) {\n                case 0:\n                  r = [], u = new Map(), c = I(e, n), l = c.featureKeys, g = c.groupCampaignIds, d = function (t) {\n                    var n, c;\n                    return o(this, function (o) {\n                      switch (o.label) {\n                        case 0:\n                          return n = (0, m.getFeatureFromKey)(e, t), c = (0, h.getCampaignIdsFromFeatureKey)(e, t), r.includes(t) ? [2, \"continue\"] : [4, b(e, n, i, r, s, a)];\n                        case 1:\n                          return o.sent() && e.getCampaigns().forEach(function (e) {\n                            g.includes(e.getId()) && c.includes(e.getId()) && (u.has(t) || u.set(t, []), -1 === u.get(t).findIndex(function (t) {\n                              return t.key === e.getKey();\n                            }) && u.get(t).push(e));\n                          }), [2];\n                      }\n                    });\n                  }, p = 0, f = l, O.label = 1;\n                case 1:\n                  return p < f.length ? (v = f[p], [5, d(v)]) : [3, 4];\n                case 2:\n                  O.sent(), O.label = 3;\n                case 3:\n                  return p++, [3, 1];\n                case 4:\n                  return [4, _(e, u, a, s)];\n                case 5:\n                  return y = O.sent(), E = y.eligibleCampaigns, T = y.eligibleCampaignsWithStorage, [4, S(e, t.getKey(), E, T, n, a)];\n                case 6:\n                  return [2, O.sent()];\n              }\n            });\n          });\n        }, t.getFeatureKeysFromGroup = I;\n        var b = function (e, t, n, i, a, l) {\n            return r(void 0, void 0, void 0, function () {\n              var r, g, p, h, I, b, _;\n              return o(this, function (o) {\n                switch (o.label) {\n                  case 0:\n                    if (n.has(t.getKey()) && \"rolloutId\" in n.get(t.getKey())) return [2, !0];\n                    if (!((r = (0, m.getSpecificRulesBasedOnType)(t, s.CampaignTypeEnum.ROLLOUT)).length > 0)) return [3, 5];\n                    g = null, p = 0, h = r, o.label = 1;\n                  case 1:\n                    return p < h.length ? (I = h[p], [4, (0, f.evaluateRule)(e, t, I, l, n, null, a, {})]) : [3, 4];\n                  case 2:\n                    return o.sent().preSegmentationResult ? (g = I, [3, 4]) : [3, 3];\n                  case 3:\n                    return p++, [3, 1];\n                  case 4:\n                    return null !== g && (b = new c.CampaignModel().modelFromDictionary(g), _ = (0, y.evaluateTrafficAndGetVariation)(e, b, l.getId()), (0, v.isObject)(_) && Object.keys(_).length > 0) ? (n.set(t.getKey(), {\n                      rolloutId: g.id,\n                      rolloutKey: g.key,\n                      rolloutVariationId: g.variations[0].id\n                    }), [2, !0]) : (i.push(t.getKey()), [2, !1]);\n                  case 5:\n                    return d.LogManager.Instance.info((0, E.buildMessage)(u.InfoLogMessagesEnum.MEG_SKIP_ROLLOUT_EVALUATE_EXPERIMENTS, {\n                      featureKey: t.getKey()\n                    })), [2, !0];\n                }\n              });\n            });\n          },\n          _ = function (e, t, n, i) {\n            return r(void 0, void 0, void 0, function () {\n              var r, s, l, g, f, v, y, m, I, b, _, S, T;\n              return o(this, function (O) {\n                switch (O.label) {\n                  case 0:\n                    r = [], s = [], l = [], g = Array.from(t), f = 0, v = g, O.label = 1;\n                  case 1:\n                    if (!(f < v.length)) return [3, 6];\n                    y = v[f], m = y[0], I = y[1], b = function (t) {\n                      var g;\n                      return o(this, function (o) {\n                        switch (o.label) {\n                          case 0:\n                            return [4, new a.StorageDecorator().getFeatureFromStorage(m, n, i)];\n                          case 1:\n                            return (null == (g = o.sent()) ? void 0 : g.experimentVariationId) && g.experimentKey && g.experimentKey === t.getKey() && (0, h.getVariationFromCampaignKey)(e, g.experimentKey, g.experimentVariationId) ? (d.LogManager.Instance.info((0, E.buildMessage)(u.InfoLogMessagesEnum.MEG_CAMPAIGN_FOUND_IN_STORAGE, {\n                              campaignKey: g.experimentKey,\n                              userId: n.getId()\n                            })), -1 === s.findIndex(function (e) {\n                              return e.key === t.getKey();\n                            }) && s.push(t), [2, \"continue\"]) : [4, new p.CampaignDecisionService().getPreSegmentationDecision(new c.CampaignModel().modelFromDictionary(t), n)];\n                          case 2:\n                            return o.sent() && new p.CampaignDecisionService().isUserPartOfCampaign(n.getId(), t) ? (d.LogManager.Instance.info((0, E.buildMessage)(u.InfoLogMessagesEnum.MEG_CAMPAIGN_FOUND_IN_STORAGE, {\n                              campaignKey: t.getKey(),\n                              userId: n.getId()\n                            })), r.push(t), [2, \"continue\"]) : (l.push(t), [2]);\n                        }\n                      });\n                    }, _ = 0, S = I, O.label = 2;\n                  case 2:\n                    return _ < S.length ? (T = S[_], [5, b(T)]) : [3, 5];\n                  case 3:\n                    O.sent(), O.label = 4;\n                  case 4:\n                    return _++, [3, 2];\n                  case 5:\n                    return f++, [3, 1];\n                  case 6:\n                    return [2, Promise.resolve({\n                      eligibleCampaigns: r,\n                      eligibleCampaignsWithStorage: s,\n                      inEligibleCampaigns: l\n                    })];\n                }\n              });\n            });\n          },\n          S = function (e, t, n, a, s, c) {\n            return r(void 0, void 0, void 0, function () {\n              var r, l, g, p;\n              return o(this, function (o) {\n                return r = null, l = (0, h.getCampaignIdsFromFeatureKey)(e, t), g = (0, v.isUndefined)(null === (p = null == e ? void 0 : e.getGroups()[s]) || void 0 === p ? void 0 : p.et) ? i.Constants.RANDOM_ALGO : e.getGroups()[s].et, 1 === a.length ? (r = a[0], d.LogManager.Instance.info((0, E.buildMessage)(u.InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n                  campaignKey: a[0].getKey(),\n                  groupId: s,\n                  userId: c.getId(),\n                  algo: \"\"\n                }))) : a.length > 1 && g === i.Constants.RANDOM_ALGO ? r = T(a, c, l, s) : a.length > 1 && (r = O(e, a, c, l, s)), 0 === a.length && (1 === n.length ? (r = n[0], d.LogManager.Instance.info((0, E.buildMessage)(u.InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n                  campaignKey: n[0].getKey(),\n                  groupId: s,\n                  userId: c.getId(),\n                  algo: \"\"\n                }))) : n.length > 1 && g === i.Constants.RANDOM_ALGO ? r = T(n, c, l, s) : n.length > 1 && (r = O(e, n, c, l, s))), [2, r];\n              });\n            });\n          },\n          T = function (e, t, n, r) {\n            e.forEach(function (t) {\n              t.weight = Math.floor(100 / e.length);\n            }), e = e.map(function (e) {\n              return new l.VariationModel().modelFromDictionary(e);\n            }), (0, h.setCampaignAllocation)(e);\n            var o = new p.CampaignDecisionService().getVariation(e, new g.DecisionMaker().calculateBucketValue((0, h.getBucketingSeed)(t.getId(), void 0, r)));\n            return d.LogManager.Instance.info((0, E.buildMessage)(u.InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n              campaignKey: o.getKey(),\n              groupId: r,\n              userId: t.getId(),\n              algo: \"using random algorithm\"\n            })), o && n.includes(o.getId()) ? o : null;\n          },\n          O = function (e, t, n, r, o) {\n            for (var i = null, a = !1, s = (0, v.isUndefined)(e.getGroups()[o].p) ? {} : e.getGroups()[o].p, c = (0, v.isUndefined)(e.getGroups()[o].wt) ? {} : e.getGroups()[o].wt, f = 0; f < s.length; f++) {\n              for (var y = 0; y < t.length; y++) if (t[y].id === s[f]) {\n                i = (0, m.cloneObject)(t[y]), a = !0;\n                break;\n              }\n              if (!0 === a) break;\n            }\n            if (null === i) {\n              var I = [];\n              for (f = 0; f < t.length; f++) {\n                var b = t[f].id;\n                if (!(0, v.isUndefined)(c[b])) {\n                  var _ = (0, m.cloneObject)(t[f]);\n                  _.weight = c[b], I.push(_);\n                }\n              }\n              I = I.map(function (e) {\n                return new l.VariationModel().modelFromDictionary(e);\n              }), (0, h.setCampaignAllocation)(I), i = new p.CampaignDecisionService().getVariation(I, new g.DecisionMaker().calculateBucketValue((0, h.getBucketingSeed)(n.getId(), void 0, o)));\n            }\n            return d.LogManager.Instance.info((0, E.buildMessage)(u.InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n              campaignKey: i.key,\n              groupId: o,\n              userId: n.getId(),\n              algo: \"using advanced algorithm\"\n            })), r.includes(i.id) ? i : null;\n          };\n      },\n      8925: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.setShouldWaitForTrackingCalls = t.getShouldWaitForTrackingCalls = t.sendGetApiRequest = t.sendPostApiRequest = t.getAttributePayloadData = t.getTrackGoalPayloadData = t.getTrackUserPayloadData = t._getEventBasePayload = t.getEventsBaseProperties = t.getEventBatchingQueryParams = t.getTrackEventPath = t.getSettingsPath = t.getBasePropertiesForBulk = void 0;\n        var i = n(8667),\n          a = n(1720),\n          s = n(5399),\n          u = n(4019),\n          c = n(8202),\n          l = n(9528),\n          g = n(7128),\n          d = n(4580),\n          p = n(6710),\n          f = n(470),\n          h = n(1359),\n          v = n(8754),\n          y = n(8694);\n        function m(e, t, n, r, o) {\n          void 0 === r && (r = \"\"), void 0 === o && (o = \"\");\n          var u = (0, a.getUUID)(t.toString(), e.getAccountId()),\n            c = e.getSdkkey(),\n            l = {\n              vwo_sdkName: s.Constants.SDK_NAME,\n              vwo_sdkVersion: s.Constants.SDK_VERSION,\n              vwo_envKey: c\n            };\n          return {\n            d: {\n              msgId: \"\".concat(u, \"-\").concat((0, i.getCurrentUnixTimestampInMillis)()),\n              visId: u,\n              sessionId: (0, i.getCurrentUnixTimestamp)(),\n              visitor_ua: r,\n              visitor_ip: o,\n              event: {\n                props: l,\n                name: n,\n                time: (0, i.getCurrentUnixTimestampInMillis)()\n              },\n              visitor: {\n                props: {\n                  vwo_fs_environment: c\n                }\n              }\n            }\n          };\n        }\n        t.getBasePropertiesForBulk = function (e, t) {\n          return {\n            sId: (0, i.getCurrentUnixTimestamp)(),\n            u: (0, a.getUUID)(t, e)\n          };\n        }, t.getSettingsPath = function (e, t) {\n          return {\n            i: \"\".concat(e),\n            r: Math.random(),\n            a: t\n          };\n        }, t.getTrackEventPath = function (e, t, n) {\n          return {\n            event_type: e,\n            account_id: t,\n            uId: n,\n            u: (0, a.getUUID)(n, t),\n            sdk: s.Constants.SDK_NAME,\n            \"sdk-v\": s.Constants.SDK_VERSION,\n            random: (0, i.getRandomNumber)(),\n            ap: s.Constants.PLATFORM,\n            sId: (0, i.getCurrentUnixTimestamp)(),\n            ed: JSON.stringify({\n              p: \"server\"\n            })\n          };\n        }, t.getEventBatchingQueryParams = function (e) {\n          return {\n            a: e,\n            sd: s.Constants.SDK_NAME,\n            sv: s.Constants.SDK_VERSION\n          };\n        }, t.getEventsBaseProperties = function (e, t, n, r) {\n          void 0 === n && (n = \"\"), void 0 === r && (r = \"\");\n          var o = e.getSdkkey(),\n            a = Object.assign({\n              en: t,\n              a: e.getAccountId(),\n              env: o,\n              eTime: (0, i.getCurrentUnixTimestampInMillis)(),\n              random: (0, i.getRandomNumber)(),\n              p: \"FS\",\n              visitor_ua: n,\n              visitor_ip: r\n            });\n          return a.url = s.Constants.HTTPS_PROTOCOL + y.UrlUtil.getBaseUrl() + l.UrlEnum.EVENTS, a;\n        }, t._getEventBasePayload = m, t.getTrackUserPayloadData = function (e, t, n, r, o, i, a) {\n          void 0 === i && (i = \"\"), void 0 === a && (a = \"\");\n          var s = m(e, t, n, i, a);\n          return s.d.event.props.id = r, s.d.event.props.variation = o, s.d.event.props.isFirst = 1, d.LogManager.Instance.debug((0, v.buildMessage)(g.DebugLogMessagesEnum.IMPRESSION_FOR_TRACK_USER, {\n            accountId: e.getAccountId(),\n            userId: t,\n            campaignId: r\n          })), s;\n        }, t.getTrackGoalPayloadData = function (e, t, n, r, o, i) {\n          void 0 === o && (o = \"\"), void 0 === i && (i = \"\");\n          var a = m(e, t, n, o, i);\n          if (a.d.event.props.isCustomEvent = !0, a.d.event.props.variation = 1, a.d.event.props.id = 1, r && (0, h.isObject)(r) && Object.keys(r).length > 0) for (var s in r) a.d.event.props[s] = r[s];\n          return d.LogManager.Instance.debug((0, v.buildMessage)(g.DebugLogMessagesEnum.IMPRESSION_FOR_TRACK_USER, {\n            eventName: n,\n            accountId: e.getAccountId(),\n            userId: t\n          })), a;\n        }, t.getAttributePayloadData = function (e, t, n, r, o, i, a) {\n          void 0 === i && (i = \"\"), void 0 === a && (a = \"\");\n          var u = m(e, t, n, i, a);\n          return u.d.event.props.isCustomEvent = !0, u.d.event.props[s.Constants.VWO_FS_ENVIRONMENT] = e.getSdkkey(), u.d.visitor.props[r] = o, d.LogManager.Instance.debug((0, v.buildMessage)(g.DebugLogMessagesEnum.IMPRESSION_FOR_TRACK_USER, {\n            eventName: n,\n            accountId: e.getAccountId(),\n            userId: t\n          })), u;\n        }, t.sendPostApiRequest = function (e, t) {\n          return r(this, void 0, void 0, function () {\n            var n, r, i, a;\n            return o(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  return p.NetworkManager.Instance.attachClient(), n = {}, r = t.d.visitor_ua, i = t.d.visitor_ip, r && (n[u.HeadersEnum.USER_AGENT] = r), i && (n[u.HeadersEnum.IP] = i), a = new p.RequestModel(y.UrlUtil.getBaseUrl(), c.HttpMethodEnum.POST, l.UrlEnum.EVENTS, e, t, n, f.SettingsService.Instance.protocol, f.SettingsService.Instance.port), [4, p.NetworkManager.Instance.post(a).catch(function (e) {\n                    d.LogManager.Instance.error((0, v.buildMessage)(g.ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n                      method: c.HttpMethodEnum.POST,\n                      err: (0, h.isObject)(e) ? JSON.stringify(e) : e\n                    }));\n                  })];\n                case 1:\n                  return o.sent(), [2];\n              }\n            });\n          });\n        }, t.sendGetApiRequest = function (e, t) {\n          return r(this, void 0, void 0, function () {\n            var n, r;\n            return o(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  p.NetworkManager.Instance.attachClient(), n = new p.RequestModel(y.UrlUtil.getBaseUrl(), c.HttpMethodEnum.GET, t, e, null, null, f.SettingsService.Instance.protocol, f.SettingsService.Instance.port), o.label = 1;\n                case 1:\n                  return o.trys.push([1, 3,, 4]), [4, p.NetworkManager.Instance.get(n)];\n                case 2:\n                  return [2, o.sent()];\n                case 3:\n                  return r = o.sent(), d.LogManager.Instance.error((0, v.buildMessage)(g.ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n                    method: c.HttpMethodEnum.GET,\n                    err: (0, h.isObject)(r) ? JSON.stringify(r) : r\n                  })), [2, null];\n                case 4:\n                  return [2];\n              }\n            });\n          });\n        };\n        var E = !1;\n        t.getShouldWaitForTrackingCalls = function () {\n          return E;\n        }, t.setShouldWaitForTrackingCalls = function (e) {\n          E = e;\n        };\n      },\n      4782: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Deferred = void 0, t.Deferred = function () {\n          var e = this;\n          return this.promise = new Promise(function (t, n) {\n            e.resolve = t, e.reject = n;\n          }), this;\n        };\n      },\n      6195: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, n, r) {\n            return new (n || (n = Promise))(function (o, i) {\n              function a(e) {\n                try {\n                  u(r.next(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function s(e) {\n                try {\n                  u(r.throw(e));\n                } catch (e) {\n                  i(e);\n                }\n              }\n              function u(e) {\n                var t;\n                e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) {\n                  e(t);\n                })).then(a, s);\n              }\n              u((r = r.apply(e, t || [])).next());\n            });\n          },\n          o = this && this.__generator || function (e, t) {\n            var n,\n              r,\n              o,\n              i,\n              a = {\n                label: 0,\n                sent: function () {\n                  if (1 & o[0]) throw o[1];\n                  return o[1];\n                },\n                trys: [],\n                ops: []\n              };\n            return i = {\n              next: s(0),\n              throw: s(1),\n              return: s(2)\n            }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n              return this;\n            }), i;\n            function s(s) {\n              return function (u) {\n                return function (s) {\n                  if (n) throw new TypeError(\"Generator is already executing.\");\n                  for (; i && (i = 0, s[0] && (a = 0)), a;) try {\n                    if (n = 1, r && (o = 2 & s[0] ? r.return : s[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, s[1])).done) return o;\n                    switch (r = 0, o && (s = [2 & s[0], o.value]), s[0]) {\n                      case 0:\n                      case 1:\n                        o = s;\n                        break;\n                      case 4:\n                        return a.label++, {\n                          value: s[1],\n                          done: !1\n                        };\n                      case 5:\n                        a.label++, r = s[1], s = [0];\n                        continue;\n                      case 7:\n                        s = a.ops.pop(), a.trys.pop();\n                        continue;\n                      default:\n                        if (!((o = (o = a.trys).length > 0 && o[o.length - 1]) || 6 !== s[0] && 2 !== s[0])) {\n                          a = 0;\n                          continue;\n                        }\n                        if (3 === s[0] && (!o || s[1] > o[0] && s[1] < o[3])) {\n                          a.label = s[1];\n                          break;\n                        }\n                        if (6 === s[0] && a.label < o[1]) {\n                          a.label = o[1], o = s;\n                          break;\n                        }\n                        if (o && a.label < o[2]) {\n                          a.label = o[2], a.ops.push(s);\n                          break;\n                        }\n                        o[2] && a.ops.pop(), a.trys.pop();\n                        continue;\n                    }\n                    s = t.call(e, a);\n                  } catch (e) {\n                    s = [6, e], r = 0;\n                  } finally {\n                    n = o = 0;\n                  }\n                  if (5 & s[0]) throw s[1];\n                  return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                  };\n                }([s, u]);\n              };\n            }\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.evaluateRule = void 0;\n        var i = n(1359),\n          a = n(2245),\n          s = n(8925),\n          u = n(162);\n        t.evaluateRule = function (e, t, n, c, l, g, d, p) {\n          return r(void 0, void 0, void 0, function () {\n            var r, f, h;\n            return o(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  return [4, (0, a.checkWhitelistingAndPreSeg)(e, t, n, c, l, g, d, p)];\n                case 1:\n                  return r = o.sent(), f = r[0], h = r[1], f && (0, i.isObject)(h) && Object.keys(h).length > 0 ? (Object.assign(p, {\n                    experimentId: n.getId(),\n                    experimentKey: n.getKey(),\n                    experimentVariationId: h.variationId\n                  }), (0, s.getShouldWaitForTrackingCalls)() ? [4, (0, u.createAndSendImpressionForVariationShown)(e, n.getId(), h.variation.id, c)] : [3, 3]) : [3, 4];\n                case 2:\n                  return o.sent(), [3, 4];\n                case 3:\n                  (0, u.createAndSendImpressionForVariationShown)(e, n.getId(), h.variation.id, c), o.label = 4;\n                case 4:\n                  return [2, {\n                    preSegmentationResult: f,\n                    whitelistedObject: h,\n                    updatedDecision: p\n                  }];\n              }\n            });\n          });\n        };\n      },\n      362: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.setSettingsAndAddCampaignsToRules = void 0;\n        var r = n(6130),\n          o = n(9181),\n          i = n(8667),\n          a = n(2898);\n        t.setSettingsAndAddCampaignsToRules = function (e, t) {\n          t.settings = new r.SettingsModel(e), t.originalSettings = e;\n          var n = t.settings.getCampaigns();\n          n.forEach(function (e, t) {\n            (0, o.setVariationAllocation)(e), n[t] = e;\n          }), (0, i.addLinkedCampaignsToSettings)(t.settings), (0, a.addIsGatewayServiceRequiredFlag)(t.settings);\n        };\n      },\n      8694: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.UrlUtil = void 0;\n        var r = n(470),\n          o = n(1359);\n        t.UrlUtil = {\n          init: function (e) {\n            var n = (void 0 === e ? {} : e).collectionPrefix;\n            return n && (0, o.isString)(n) && (t.UrlUtil.collectionPrefix = n), t.UrlUtil;\n          },\n          getBaseUrl: function () {\n            var e = r.SettingsService.Instance.hostname;\n            return r.SettingsService.Instance.isGatewayServiceProvided ? e : t.UrlUtil.collectionPrefix ? \"\".concat(e, \"/\").concat(t.UrlUtil.collectionPrefix) : e;\n          }\n        };\n      },\n      1720: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.generateUUID = t.getUUID = t.getRandomUUID = void 0;\n        var r = n(2346),\n          o = n(2831),\n          i = n(2831);\n        function a(e, t) {\n          if (e && t) return (0, i.v5)(e, t);\n        }\n        t.getRandomUUID = function (e) {\n          var t = (0, i.v5)(e, i.v5.DNS);\n          return (0, i.v5)((0, o.v4)(), t);\n        }, t.getUUID = function (e, t) {\n          var n = (0, i.v5)(r.SEED_URL, i.v5.URL);\n          e = String(e);\n          var o = a(t = String(t), n),\n            s = a(e, o);\n          return null == s ? void 0 : s.replace(/-/gi, \"\").toUpperCase();\n        }, t.generateUUID = a;\n      },\n      3890: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sendPostCall = t.sendGetCall = void 0;\n        var r = n(8202),\n          o = n(4580),\n          i = n(8754),\n          a = n(7128),\n          s = function () {};\n        function u(e, t) {\n          var n = t.networkOptions,\n            u = t.successCallback,\n            c = void 0 === u ? s : u,\n            l = t.errorCallback,\n            g = void 0 === l ? s : l,\n            d = \"\".concat(n.scheme, \"://\").concat(n.hostname).concat(n.path);\n          n.port && (d = \"\".concat(n.scheme, \"://\").concat(n.hostname, \":\").concat(n.port).concat(n.path));\n          var p = n.body,\n            f = n.headers || {},\n            h = n.timeout,\n            v = new XMLHttpRequest();\n          for (var y in h && (v.timeout = h), v.onload = function () {\n            if (v.status >= 200 && v.status < 300) {\n              var t = v.responseText;\n              if (e === r.HttpMethodEnum.GET) {\n                var n = JSON.parse(t);\n                c(n);\n              } else c(t);\n            } else g(v.statusText);\n          }, v.onerror = function () {\n            o.LogManager.Instance.error((0, i.buildMessage)(a.ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n              method: r.HttpMethodEnum.POST,\n              err: \"\".concat(v.statusText, \", status: \").concat(v.status)\n            })), g(v.statusText);\n          }, h && (v.ontimeout = function () {\n            o.LogManager.Instance.error((0, i.buildMessage)(a.ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n              method: r.HttpMethodEnum.POST,\n              err: \"Request timed out\"\n            }));\n          }), v.open(e, d, !0), f) y in f && \"Content-Type\" !== y && \"Content-Length\" !== y && v.setRequestHeader(y, f[y]);\n          e === r.HttpMethodEnum.POST ? v.send(JSON.stringify(p)) : e === r.HttpMethodEnum.GET && v.send();\n        }\n        t.sendGetCall = function (e) {\n          u(r.HttpMethodEnum.GET, e);\n        }, t.sendPostCall = function (e) {\n          u(r.HttpMethodEnum.POST, e);\n        };\n      },\n      2831: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), Object.defineProperty(t, \"NIL\", {\n          enumerable: !0,\n          get: function () {\n            return s.default;\n          }\n        }), Object.defineProperty(t, \"parse\", {\n          enumerable: !0,\n          get: function () {\n            return g.default;\n          }\n        }), Object.defineProperty(t, \"stringify\", {\n          enumerable: !0,\n          get: function () {\n            return l.default;\n          }\n        }), Object.defineProperty(t, \"v1\", {\n          enumerable: !0,\n          get: function () {\n            return r.default;\n          }\n        }), Object.defineProperty(t, \"v3\", {\n          enumerable: !0,\n          get: function () {\n            return o.default;\n          }\n        }), Object.defineProperty(t, \"v4\", {\n          enumerable: !0,\n          get: function () {\n            return i.default;\n          }\n        }), Object.defineProperty(t, \"v5\", {\n          enumerable: !0,\n          get: function () {\n            return a.default;\n          }\n        }), Object.defineProperty(t, \"validate\", {\n          enumerable: !0,\n          get: function () {\n            return c.default;\n          }\n        }), Object.defineProperty(t, \"version\", {\n          enumerable: !0,\n          get: function () {\n            return u.default;\n          }\n        });\n        var r = d(n(3518)),\n          o = d(n(4948)),\n          i = d(n(5073)),\n          a = d(n(7186)),\n          s = d(n(4808)),\n          u = d(n(7775)),\n          c = d(n(7037)),\n          l = d(n(9910)),\n          g = d(n(6792));\n        function d(e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        }\n      },\n      2311: (e, t) => {\n        \"use strict\";\n\n        function n(e) {\n          return 14 + (e + 64 >>> 9 << 4) + 1;\n        }\n        function r(e, t) {\n          const n = (65535 & e) + (65535 & t);\n          return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;\n        }\n        function o(e, t, n, o, i, a) {\n          return r((s = r(r(t, e), r(o, a))) << (u = i) | s >>> 32 - u, n);\n          var s, u;\n        }\n        function i(e, t, n, r, i, a, s) {\n          return o(t & n | ~t & r, e, t, i, a, s);\n        }\n        function a(e, t, n, r, i, a, s) {\n          return o(t & r | n & ~r, e, t, i, a, s);\n        }\n        function s(e, t, n, r, i, a, s) {\n          return o(t ^ n ^ r, e, t, i, a, s);\n        }\n        function u(e, t, n, r, i, a, s) {\n          return o(n ^ (t | ~r), e, t, i, a, s);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        t.default = function (e) {\n          if (\"string\" == typeof e) {\n            const t = unescape(encodeURIComponent(e));\n            e = new Uint8Array(t.length);\n            for (let n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n);\n          }\n          return function (e) {\n            const t = [],\n              n = 32 * e.length,\n              r = \"0123456789abcdef\";\n            for (let o = 0; o < n; o += 8) {\n              const n = e[o >> 5] >>> o % 32 & 255,\n                i = parseInt(r.charAt(n >>> 4 & 15) + r.charAt(15 & n), 16);\n              t.push(i);\n            }\n            return t;\n          }(function (e, t) {\n            e[t >> 5] |= 128 << t % 32, e[n(t) - 1] = t;\n            let o = 1732584193,\n              c = -271733879,\n              l = -1732584194,\n              g = 271733878;\n            for (let t = 0; t < e.length; t += 16) {\n              const n = o,\n                d = c,\n                p = l,\n                f = g;\n              o = i(o, c, l, g, e[t], 7, -680876936), g = i(g, o, c, l, e[t + 1], 12, -389564586), l = i(l, g, o, c, e[t + 2], 17, 606105819), c = i(c, l, g, o, e[t + 3], 22, -1044525330), o = i(o, c, l, g, e[t + 4], 7, -176418897), g = i(g, o, c, l, e[t + 5], 12, 1200080426), l = i(l, g, o, c, e[t + 6], 17, -1473231341), c = i(c, l, g, o, e[t + 7], 22, -45705983), o = i(o, c, l, g, e[t + 8], 7, 1770035416), g = i(g, o, c, l, e[t + 9], 12, -1958414417), l = i(l, g, o, c, e[t + 10], 17, -42063), c = i(c, l, g, o, e[t + 11], 22, -1990404162), o = i(o, c, l, g, e[t + 12], 7, 1804603682), g = i(g, o, c, l, e[t + 13], 12, -40341101), l = i(l, g, o, c, e[t + 14], 17, -1502002290), c = i(c, l, g, o, e[t + 15], 22, 1236535329), o = a(o, c, l, g, e[t + 1], 5, -165796510), g = a(g, o, c, l, e[t + 6], 9, -1069501632), l = a(l, g, o, c, e[t + 11], 14, 643717713), c = a(c, l, g, o, e[t], 20, -373897302), o = a(o, c, l, g, e[t + 5], 5, -701558691), g = a(g, o, c, l, e[t + 10], 9, 38016083), l = a(l, g, o, c, e[t + 15], 14, -660478335), c = a(c, l, g, o, e[t + 4], 20, -405537848), o = a(o, c, l, g, e[t + 9], 5, 568446438), g = a(g, o, c, l, e[t + 14], 9, -1019803690), l = a(l, g, o, c, e[t + 3], 14, -187363961), c = a(c, l, g, o, e[t + 8], 20, 1163531501), o = a(o, c, l, g, e[t + 13], 5, -1444681467), g = a(g, o, c, l, e[t + 2], 9, -51403784), l = a(l, g, o, c, e[t + 7], 14, 1735328473), c = a(c, l, g, o, e[t + 12], 20, -1926607734), o = s(o, c, l, g, e[t + 5], 4, -378558), g = s(g, o, c, l, e[t + 8], 11, -2022574463), l = s(l, g, o, c, e[t + 11], 16, 1839030562), c = s(c, l, g, o, e[t + 14], 23, -35309556), o = s(o, c, l, g, e[t + 1], 4, -1530992060), g = s(g, o, c, l, e[t + 4], 11, 1272893353), l = s(l, g, o, c, e[t + 7], 16, -155497632), c = s(c, l, g, o, e[t + 10], 23, -1094730640), o = s(o, c, l, g, e[t + 13], 4, 681279174), g = s(g, o, c, l, e[t], 11, -358537222), l = s(l, g, o, c, e[t + 3], 16, -722521979), c = s(c, l, g, o, e[t + 6], 23, 76029189), o = s(o, c, l, g, e[t + 9], 4, -640364487), g = s(g, o, c, l, e[t + 12], 11, -421815835), l = s(l, g, o, c, e[t + 15], 16, 530742520), c = s(c, l, g, o, e[t + 2], 23, -995338651), o = u(o, c, l, g, e[t], 6, -198630844), g = u(g, o, c, l, e[t + 7], 10, 1126891415), l = u(l, g, o, c, e[t + 14], 15, -1416354905), c = u(c, l, g, o, e[t + 5], 21, -57434055), o = u(o, c, l, g, e[t + 12], 6, 1700485571), g = u(g, o, c, l, e[t + 3], 10, -1894986606), l = u(l, g, o, c, e[t + 10], 15, -1051523), c = u(c, l, g, o, e[t + 1], 21, -2054922799), o = u(o, c, l, g, e[t + 8], 6, 1873313359), g = u(g, o, c, l, e[t + 15], 10, -30611744), l = u(l, g, o, c, e[t + 6], 15, -1560198380), c = u(c, l, g, o, e[t + 13], 21, 1309151649), o = u(o, c, l, g, e[t + 4], 6, -145523070), g = u(g, o, c, l, e[t + 11], 10, -1120210379), l = u(l, g, o, c, e[t + 2], 15, 718787259), c = u(c, l, g, o, e[t + 9], 21, -343485551), o = r(o, n), c = r(c, d), l = r(l, p), g = r(g, f);\n            }\n            return [o, c, l, g];\n          }(function (e) {\n            if (0 === e.length) return [];\n            const t = 8 * e.length,\n              r = new Uint32Array(n(t));\n            for (let n = 0; n < t; n += 8) r[n >> 5] |= (255 & e[n / 8]) << n % 32;\n            return r;\n          }(e), 8 * e.length));\n        };\n      },\n      6140: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var n = {\n          randomUUID: \"undefined\" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto)\n        };\n        t.default = n;\n      },\n      4808: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0, t.default = \"00000000-0000-0000-0000-000000000000\";\n      },\n      6792: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var r,\n          o = (r = n(7037)) && r.__esModule ? r : {\n            default: r\n          };\n        t.default = function (e) {\n          if (!(0, o.default)(e)) throw TypeError(\"Invalid UUID\");\n          let t;\n          const n = new Uint8Array(16);\n          return n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, n[1] = t >>> 16 & 255, n[2] = t >>> 8 & 255, n[3] = 255 & t, n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, n[5] = 255 & t, n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, n[7] = 255 & t, n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, n[9] = 255 & t, n[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = t / 4294967296 & 255, n[12] = t >>> 24 & 255, n[13] = t >>> 16 & 255, n[14] = t >>> 8 & 255, n[15] = 255 & t, n;\n        };\n      },\n      7656: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0, t.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n      },\n      2858: (e, t) => {\n        \"use strict\";\n\n        let n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = function () {\n          if (!n && (n = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !n)) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n          return n(r);\n        };\n        const r = new Uint8Array(16);\n      },\n      9042: (e, t) => {\n        \"use strict\";\n\n        function n(e, t, n, r) {\n          switch (e) {\n            case 0:\n              return t & n ^ ~t & r;\n            case 1:\n            case 3:\n              return t ^ n ^ r;\n            case 2:\n              return t & n ^ t & r ^ n & r;\n          }\n        }\n        function r(e, t) {\n          return e << t | e >>> 32 - t;\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        t.default = function (e) {\n          const t = [1518500249, 1859775393, 2400959708, 3395469782],\n            o = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n          if (\"string\" == typeof e) {\n            const t = unescape(encodeURIComponent(e));\n            e = [];\n            for (let n = 0; n < t.length; ++n) e.push(t.charCodeAt(n));\n          } else Array.isArray(e) || (e = Array.prototype.slice.call(e));\n          e.push(128);\n          const i = e.length / 4 + 2,\n            a = Math.ceil(i / 16),\n            s = new Array(a);\n          for (let t = 0; t < a; ++t) {\n            const n = new Uint32Array(16);\n            for (let r = 0; r < 16; ++r) n[r] = e[64 * t + 4 * r] << 24 | e[64 * t + 4 * r + 1] << 16 | e[64 * t + 4 * r + 2] << 8 | e[64 * t + 4 * r + 3];\n            s[t] = n;\n          }\n          s[a - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), s[a - 1][14] = Math.floor(s[a - 1][14]), s[a - 1][15] = 8 * (e.length - 1) & 4294967295;\n          for (let e = 0; e < a; ++e) {\n            const i = new Uint32Array(80);\n            for (let t = 0; t < 16; ++t) i[t] = s[e][t];\n            for (let e = 16; e < 80; ++e) i[e] = r(i[e - 3] ^ i[e - 8] ^ i[e - 14] ^ i[e - 16], 1);\n            let a = o[0],\n              u = o[1],\n              c = o[2],\n              l = o[3],\n              g = o[4];\n            for (let e = 0; e < 80; ++e) {\n              const o = Math.floor(e / 20),\n                s = r(a, 5) + n(o, u, c, l) + g + t[o] + i[e] >>> 0;\n              g = l, l = c, c = r(u, 30) >>> 0, u = a, a = s;\n            }\n            o[0] = o[0] + a >>> 0, o[1] = o[1] + u >>> 0, o[2] = o[2] + c >>> 0, o[3] = o[3] + l >>> 0, o[4] = o[4] + g >>> 0;\n          }\n          return [o[0] >> 24 & 255, o[0] >> 16 & 255, o[0] >> 8 & 255, 255 & o[0], o[1] >> 24 & 255, o[1] >> 16 & 255, o[1] >> 8 & 255, 255 & o[1], o[2] >> 24 & 255, o[2] >> 16 & 255, o[2] >> 8 & 255, 255 & o[2], o[3] >> 24 & 255, o[3] >> 16 & 255, o[3] >> 8 & 255, 255 & o[3], o[4] >> 24 & 255, o[4] >> 16 & 255, o[4] >> 8 & 255, 255 & o[4]];\n        };\n      },\n      9910: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0, t.unsafeStringify = a;\n        var r,\n          o = (r = n(7037)) && r.__esModule ? r : {\n            default: r\n          };\n        const i = [];\n        for (let e = 0; e < 256; ++e) i.push((e + 256).toString(16).slice(1));\n        function a(e, t = 0) {\n          return i[e[t + 0]] + i[e[t + 1]] + i[e[t + 2]] + i[e[t + 3]] + \"-\" + i[e[t + 4]] + i[e[t + 5]] + \"-\" + i[e[t + 6]] + i[e[t + 7]] + \"-\" + i[e[t + 8]] + i[e[t + 9]] + \"-\" + i[e[t + 10]] + i[e[t + 11]] + i[e[t + 12]] + i[e[t + 13]] + i[e[t + 14]] + i[e[t + 15]];\n        }\n        t.default = function (e, t = 0) {\n          const n = a(e, t);\n          if (!(0, o.default)(n)) throw TypeError(\"Stringified UUID is invalid\");\n          return n;\n        };\n      },\n      3518: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var r,\n          o = (r = n(2858)) && r.__esModule ? r : {\n            default: r\n          },\n          i = n(9910);\n        let a,\n          s,\n          u = 0,\n          c = 0;\n        t.default = function (e, t, n) {\n          let r = t && n || 0;\n          const l = t || new Array(16);\n          let g = (e = e || {}).node || a,\n            d = void 0 !== e.clockseq ? e.clockseq : s;\n          if (null == g || null == d) {\n            const t = e.random || (e.rng || o.default)();\n            null == g && (g = a = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]), null == d && (d = s = 16383 & (t[6] << 8 | t[7]));\n          }\n          let p = void 0 !== e.msecs ? e.msecs : Date.now(),\n            f = void 0 !== e.nsecs ? e.nsecs : c + 1;\n          const h = p - u + (f - c) / 1e4;\n          if (h < 0 && void 0 === e.clockseq && (d = d + 1 & 16383), (h < 0 || p > u) && void 0 === e.nsecs && (f = 0), f >= 1e4) throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n          u = p, c = f, s = d, p += 122192928e5;\n          const v = (1e4 * (268435455 & p) + f) % 4294967296;\n          l[r++] = v >>> 24 & 255, l[r++] = v >>> 16 & 255, l[r++] = v >>> 8 & 255, l[r++] = 255 & v;\n          const y = p / 4294967296 * 1e4 & 268435455;\n          l[r++] = y >>> 8 & 255, l[r++] = 255 & y, l[r++] = y >>> 24 & 15 | 16, l[r++] = y >>> 16 & 255, l[r++] = d >>> 8 | 128, l[r++] = 255 & d;\n          for (let e = 0; e < 6; ++e) l[r + e] = g[e];\n          return t || (0, i.unsafeStringify)(l);\n        };\n      },\n      4948: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var r = i(n(9025)),\n          o = i(n(2311));\n        function i(e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        }\n        var a = (0, r.default)(\"v3\", 48, o.default);\n        t.default = a;\n      },\n      9025: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.URL = t.DNS = void 0, t.default = function (e, t, n) {\n          function r(e, r, a, s) {\n            var u;\n            if (\"string\" == typeof e && (e = function (e) {\n              e = unescape(encodeURIComponent(e));\n              const t = [];\n              for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));\n              return t;\n            }(e)), \"string\" == typeof r && (r = (0, i.default)(r)), 16 !== (null === (u = r) || void 0 === u ? void 0 : u.length)) throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n            let c = new Uint8Array(16 + e.length);\n            if (c.set(r), c.set(e, r.length), c = n(c), c[6] = 15 & c[6] | t, c[8] = 63 & c[8] | 128, a) {\n              s = s || 0;\n              for (let e = 0; e < 16; ++e) a[s + e] = c[e];\n              return a;\n            }\n            return (0, o.unsafeStringify)(c);\n          }\n          try {\n            r.name = e;\n          } catch (e) {}\n          return r.DNS = a, r.URL = s, r;\n        };\n        var r,\n          o = n(9910),\n          i = (r = n(6792)) && r.__esModule ? r : {\n            default: r\n          };\n        const a = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n        t.DNS = a;\n        const s = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n        t.URL = s;\n      },\n      5073: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var r = a(n(6140)),\n          o = a(n(2858)),\n          i = n(9910);\n        function a(e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        }\n        t.default = function (e, t, n) {\n          if (r.default.randomUUID && !t && !e) return r.default.randomUUID();\n          const a = (e = e || {}).random || (e.rng || o.default)();\n          if (a[6] = 15 & a[6] | 64, a[8] = 63 & a[8] | 128, t) {\n            n = n || 0;\n            for (let e = 0; e < 16; ++e) t[n + e] = a[e];\n            return t;\n          }\n          return (0, i.unsafeStringify)(a);\n        };\n      },\n      7186: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var r = i(n(9025)),\n          o = i(n(9042));\n        function i(e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        }\n        var a = (0, r.default)(\"v5\", 80, o.default);\n        t.default = a;\n      },\n      7037: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var r,\n          o = (r = n(7656)) && r.__esModule ? r : {\n            default: r\n          };\n        t.default = function (e) {\n          return \"string\" == typeof e && o.default.test(e);\n        };\n      },\n      7775: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n        var r,\n          o = (r = n(7037)) && r.__esModule ? r : {\n            default: r\n          };\n        t.default = function (e) {\n          if (!(0, o.default)(e)) throw TypeError(\"Invalid UUID\");\n          return parseInt(e.slice(14, 15), 16);\n        };\n      },\n      3095: (e, t, n) => {\n        e.exports = {\n          debugMessages: n(805),\n          infoMessages: n(7778),\n          warnMessages: n(8854),\n          errorMessages: n(1198),\n          traceMessages: n(6611)\n        };\n      },\n      3185: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        class n extends TypeError {\n          constructor(e, t) {\n            let n;\n            const {\n                message: r,\n                ...o\n              } = e,\n              {\n                path: i\n              } = e;\n            super(0 === i.length ? r : \"At path: \" + i.join(\".\") + \" -- \" + r), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => {\n              var r;\n              return null != (r = n) ? r : n = [e, ...t()];\n            };\n          }\n        }\n        function r(e) {\n          return \"object\" == typeof e && null != e;\n        }\n        function o(e) {\n          if (\"[object Object]\" !== Object.prototype.toString.call(e)) return !1;\n          const t = Object.getPrototypeOf(e);\n          return null === t || t === Object.prototype;\n        }\n        function i(e) {\n          return \"string\" == typeof e ? JSON.stringify(e) : \"\" + e;\n        }\n        function a(e, t, n, r) {\n          if (!0 === e) return;\n          !1 === e ? e = {} : \"string\" == typeof e && (e = {\n            message: e\n          });\n          const {\n              path: o,\n              branch: a\n            } = t,\n            {\n              type: s\n            } = n,\n            {\n              refinement: u,\n              message: c = \"Expected a value of type `\" + s + \"`\" + (u ? \" with refinement `\" + u + \"`\" : \"\") + \", but received: `\" + i(r) + \"`\"\n            } = e;\n          return {\n            value: r,\n            type: s,\n            refinement: u,\n            key: o[o.length - 1],\n            path: o,\n            branch: a,\n            ...e,\n            message: c\n          };\n        }\n        function* s(e, t, n, o) {\n          var i;\n          r(i = e) && \"function\" == typeof i[Symbol.iterator] || (e = [e]);\n          for (const r of e) {\n            const e = a(r, t, n, o);\n            e && (yield e);\n          }\n        }\n        function* u(e, t, n = {}) {\n          const {\n              path: o = [],\n              branch: i = [e],\n              coerce: a = !1,\n              mask: s = !1\n            } = n,\n            c = {\n              path: o,\n              branch: i\n            };\n          if (a && (e = t.coercer(e, c), s && \"type\" !== t.type && r(t.schema) && r(e) && !Array.isArray(e))) for (const n in e) void 0 === t.schema[n] && delete e[n];\n          let l = !0;\n          for (const n of t.validator(e, c)) l = !1, yield [n, void 0];\n          for (let [n, g, d] of t.entries(e, c)) {\n            const t = u(g, d, {\n              path: void 0 === n ? o : [...o, n],\n              branch: void 0 === n ? i : [...i, g],\n              coerce: a,\n              mask: s\n            });\n            for (const o of t) o[0] ? (l = !1, yield [o[0], void 0]) : a && (g = o[1], void 0 === n ? e = g : e instanceof Map ? e.set(n, g) : e instanceof Set ? e.add(g) : r(e) && (e[n] = g));\n          }\n          if (l) for (const n of t.refiner(e, c)) l = !1, yield [n, void 0];\n          l && (yield [void 0, e]);\n        }\n        class c {\n          constructor(e) {\n            const {\n              type: t,\n              schema: n,\n              validator: r,\n              refiner: o,\n              coercer: i = e => e,\n              entries: a = function* () {}\n            } = e;\n            this.type = t, this.schema = n, this.entries = a, this.coercer = i, this.validator = r ? (e, t) => s(r(e, t), t, this, e) : () => [], this.refiner = o ? (e, t) => s(o(e, t), t, this, e) : () => [];\n          }\n          assert(e) {\n            return l(e, this);\n          }\n          create(e) {\n            return g(e, this);\n          }\n          is(e) {\n            return p(e, this);\n          }\n          mask(e) {\n            return d(e, this);\n          }\n          validate(e, t = {}) {\n            return f(e, this, t);\n          }\n        }\n        function l(e, t) {\n          const n = f(e, t);\n          if (n[0]) throw n[0];\n        }\n        function g(e, t) {\n          const n = f(e, t, {\n            coerce: !0\n          });\n          if (n[0]) throw n[0];\n          return n[1];\n        }\n        function d(e, t) {\n          const n = f(e, t, {\n            coerce: !0,\n            mask: !0\n          });\n          if (n[0]) throw n[0];\n          return n[1];\n        }\n        function p(e, t) {\n          return !f(e, t)[0];\n        }\n        function f(e, t, r = {}) {\n          const o = u(e, t, r),\n            i = function (e) {\n              const {\n                done: t,\n                value: n\n              } = e.next();\n              return t ? void 0 : n;\n            }(o);\n          return i[0] ? [new n(i[0], function* () {\n            for (const e of o) e[0] && (yield e[0]);\n          }), void 0] : [void 0, i[1]];\n        }\n        function h(e, t) {\n          return new c({\n            type: e,\n            schema: null,\n            validator: t\n          });\n        }\n        function v() {\n          return h(\"never\", () => !1);\n        }\n        function y(e) {\n          const t = e ? Object.keys(e) : [],\n            n = v();\n          return new c({\n            type: \"object\",\n            schema: e || null,\n            *entries(o) {\n              if (e && r(o)) {\n                const r = new Set(Object.keys(o));\n                for (const n of t) r.delete(n), yield [n, o[n], e[n]];\n                for (const e of r) yield [e, o[e], n];\n              }\n            },\n            validator: e => r(e) || \"Expected an object, but received: \" + i(e),\n            coercer: e => r(e) ? {\n              ...e\n            } : e\n          });\n        }\n        function m(e) {\n          return new c({\n            ...e,\n            validator: (t, n) => void 0 === t || e.validator(t, n),\n            refiner: (t, n) => void 0 === t || e.refiner(t, n)\n          });\n        }\n        function E() {\n          return h(\"string\", e => \"string\" == typeof e || \"Expected a string, but received: \" + i(e));\n        }\n        function I() {\n          return h(\"unknown\", () => !0);\n        }\n        function b(e, t, n) {\n          return new c({\n            ...e,\n            coercer: (r, o) => p(r, t) ? e.coercer(n(r, o), o) : e.coercer(r, o)\n          });\n        }\n        function _(e, t, n) {\n          return new c({\n            ...e,\n            *refiner(r, o) {\n              yield* e.refiner(r, o);\n              const i = s(n(r, o), o, e, r);\n              for (const e of i) yield {\n                ...e,\n                refinement: t\n              };\n            }\n          });\n        }\n        t.Struct = c, t.StructError = n, t.any = function () {\n          return h(\"any\", () => !0);\n        }, t.array = function (e) {\n          return new c({\n            type: \"array\",\n            schema: e,\n            *entries(t) {\n              if (e && Array.isArray(t)) for (const [n, r] of t.entries()) yield [n, r, e];\n            },\n            coercer: e => Array.isArray(e) ? e.slice() : e,\n            validator: e => Array.isArray(e) || \"Expected an array value, but received: \" + i(e)\n          });\n        }, t.assert = l, t.assign = function (...e) {\n          const t = e.map(e => e.schema);\n          return y(Object.assign({}, ...t));\n        }, t.boolean = function () {\n          return h(\"boolean\", e => \"boolean\" == typeof e);\n        }, t.coerce = b, t.create = g, t.date = function () {\n          return h(\"date\", e => e instanceof Date && !isNaN(e.getTime()) || \"Expected a valid `Date` object, but received: \" + i(e));\n        }, t.defaulted = function (e, t, n = {}) {\n          return b(e, I(), e => {\n            const r = \"function\" == typeof t ? t() : t;\n            if (void 0 === e) return r;\n            if (!n.strict && o(e) && o(r)) {\n              const t = {\n                ...e\n              };\n              let n = !1;\n              for (const e in r) void 0 === t[e] && (t[e] = r[e], n = !0);\n              if (n) return t;\n            }\n            return e;\n          });\n        }, t.define = h, t.deprecated = function (e, t) {\n          return new c({\n            ...e,\n            refiner: (t, n) => void 0 === t || e.refiner(t, n),\n            validator: (n, r) => void 0 === n || (t(n, r), e.validator(n, r))\n          });\n        }, t.dynamic = function (e) {\n          return new c({\n            type: \"dynamic\",\n            schema: null,\n            *entries(t, n) {\n              const r = e(t, n);\n              yield* r.entries(t, n);\n            },\n            validator: (t, n) => e(t, n).validator(t, n),\n            coercer: (t, n) => e(t, n).coercer(t, n)\n          });\n        }, t.empty = function (e) {\n          const t = \"Expected an empty \" + e.type;\n          return _(e, \"empty\", e => {\n            if (e instanceof Map || e instanceof Set) {\n              const {\n                size: n\n              } = e;\n              return 0 === n || t + \" but received one with a size of `\" + n + \"`\";\n            }\n            {\n              const {\n                length: n\n              } = e;\n              return 0 === n || t + \" but received one with a length of `\" + n + \"`\";\n            }\n          });\n        }, t.enums = function (e) {\n          const t = {},\n            n = e.map(e => i(e)).join();\n          for (const n of e) t[n] = n;\n          return new c({\n            type: \"enums\",\n            schema: t,\n            validator: t => e.includes(t) || \"Expected one of `\" + n + \"`, but received: \" + i(t)\n          });\n        }, t.func = function () {\n          return h(\"func\", e => \"function\" == typeof e || \"Expected a function, but received: \" + i(e));\n        }, t.instance = function (e) {\n          return h(\"instance\", t => t instanceof e || \"Expected a `\" + e.name + \"` instance, but received: \" + i(t));\n        }, t.integer = function () {\n          return h(\"integer\", e => \"number\" == typeof e && !isNaN(e) && Number.isInteger(e) || \"Expected an integer, but received: \" + i(e));\n        }, t.intersection = function (e) {\n          return new c({\n            type: \"intersection\",\n            schema: null,\n            *entries(t, n) {\n              for (const r of e) yield* r.entries(t, n);\n            },\n            *validator(t, n) {\n              for (const r of e) yield* r.validator(t, n);\n            },\n            *refiner(t, n) {\n              for (const r of e) yield* r.refiner(t, n);\n            }\n          });\n        }, t.is = p, t.lazy = function (e) {\n          let t;\n          return new c({\n            type: \"lazy\",\n            schema: null,\n            *entries(n, r) {\n              null != t || (t = e()), yield* t.entries(n, r);\n            },\n            validator: (n, r) => (null != t || (t = e()), t.validator(n, r)),\n            coercer: (n, r) => (null != t || (t = e()), t.coercer(n, r))\n          });\n        }, t.literal = function (e) {\n          const t = i(e),\n            n = typeof e;\n          return new c({\n            type: \"literal\",\n            schema: \"string\" === n || \"number\" === n || \"boolean\" === n ? e : null,\n            validator: n => n === e || \"Expected the literal `\" + t + \"`, but received: \" + i(n)\n          });\n        }, t.map = function (e, t) {\n          return new c({\n            type: \"map\",\n            schema: null,\n            *entries(n) {\n              if (e && t && n instanceof Map) for (const [r, o] of n.entries()) yield [r, r, e], yield [r, o, t];\n            },\n            coercer: e => e instanceof Map ? new Map(e) : e,\n            validator: e => e instanceof Map || \"Expected a `Map` object, but received: \" + i(e)\n          });\n        }, t.mask = d, t.max = function (e, t, n = {}) {\n          const {\n            exclusive: r\n          } = n;\n          return _(e, \"max\", n => r ? n < t : n <= t || \"Expected a \" + e.type + \" greater than \" + (r ? \"\" : \"or equal to \") + t + \" but received `\" + n + \"`\");\n        }, t.min = function (e, t, n = {}) {\n          const {\n            exclusive: r\n          } = n;\n          return _(e, \"min\", n => r ? n > t : n >= t || \"Expected a \" + e.type + \" greater than \" + (r ? \"\" : \"or equal to \") + t + \" but received `\" + n + \"`\");\n        }, t.never = v, t.nullable = function (e) {\n          return new c({\n            ...e,\n            validator: (t, n) => null === t || e.validator(t, n),\n            refiner: (t, n) => null === t || e.refiner(t, n)\n          });\n        }, t.number = function () {\n          return h(\"number\", e => \"number\" == typeof e && !isNaN(e) || \"Expected a number, but received: \" + i(e));\n        }, t.object = y, t.omit = function (e, t) {\n          const {\n              schema: n\n            } = e,\n            r = {\n              ...n\n            };\n          for (const e of t) delete r[e];\n          return y(r);\n        }, t.optional = m, t.partial = function (e) {\n          const t = e instanceof c ? {\n            ...e.schema\n          } : {\n            ...e\n          };\n          for (const e in t) t[e] = m(t[e]);\n          return y(t);\n        }, t.pattern = function (e, t) {\n          return _(e, \"pattern\", n => t.test(n) || \"Expected a \" + e.type + \" matching `/\" + t.source + '/` but received \"' + n + '\"');\n        }, t.pick = function (e, t) {\n          const {\n              schema: n\n            } = e,\n            r = {};\n          for (const e of t) r[e] = n[e];\n          return y(r);\n        }, t.record = function (e, t) {\n          return new c({\n            type: \"record\",\n            schema: null,\n            *entries(n) {\n              if (r(n)) for (const r in n) {\n                const o = n[r];\n                yield [r, r, e], yield [r, o, t];\n              }\n            },\n            validator: e => r(e) || \"Expected an object, but received: \" + i(e)\n          });\n        }, t.refine = _, t.regexp = function () {\n          return h(\"regexp\", e => e instanceof RegExp);\n        }, t.set = function (e) {\n          return new c({\n            type: \"set\",\n            schema: null,\n            *entries(t) {\n              if (e && t instanceof Set) for (const n of t) yield [n, n, e];\n            },\n            coercer: e => e instanceof Set ? new Set(e) : e,\n            validator: e => e instanceof Set || \"Expected a `Set` object, but received: \" + i(e)\n          });\n        }, t.size = function (e, t, n = t) {\n          const r = \"Expected a \" + e.type,\n            o = t === n ? \"of `\" + t + \"`\" : \"between `\" + t + \"` and `\" + n + \"`\";\n          return _(e, \"size\", e => {\n            if (\"number\" == typeof e || e instanceof Date) return t <= e && e <= n || r + \" \" + o + \" but received `\" + e + \"`\";\n            if (e instanceof Map || e instanceof Set) {\n              const {\n                size: i\n              } = e;\n              return t <= i && i <= n || r + \" with a size \" + o + \" but received one with a size of `\" + i + \"`\";\n            }\n            {\n              const {\n                length: i\n              } = e;\n              return t <= i && i <= n || r + \" with a length \" + o + \" but received one with a length of `\" + i + \"`\";\n            }\n          });\n        }, t.string = E, t.struct = function (e, t) {\n          return console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\"), h(e, t);\n        }, t.trimmed = function (e) {\n          return b(e, E(), e => e.trim());\n        }, t.tuple = function (e) {\n          const t = v();\n          return new c({\n            type: \"tuple\",\n            schema: null,\n            *entries(n) {\n              if (Array.isArray(n)) {\n                const r = Math.max(e.length, n.length);\n                for (let o = 0; o < r; o++) yield [o, n[o], e[o] || t];\n              }\n            },\n            validator: e => Array.isArray(e) || \"Expected an array, but received: \" + i(e)\n          });\n        }, t.type = function (e) {\n          const t = Object.keys(e);\n          return new c({\n            type: \"type\",\n            schema: e,\n            *entries(n) {\n              if (r(n)) for (const r of t) yield [r, n[r], e[r]];\n            },\n            validator: e => r(e) || \"Expected an object, but received: \" + i(e)\n          });\n        }, t.union = function (e) {\n          const t = e.map(e => e.type).join(\" | \");\n          return new c({\n            type: \"union\",\n            schema: null,\n            validator(n, r) {\n              const o = [];\n              for (const t of e) {\n                const [...e] = u(n, t, r),\n                  [i] = e;\n                if (!i[0]) return [];\n                for (const [t] of e) t && o.push(t);\n              }\n              return [\"Expected the value to satisfy a union of `\" + t + \"`, but received: \" + i(n), ...o];\n            }\n          });\n        }, t.unknown = I, t.validate = f;\n      },\n      805: e => {\n        \"use strict\";\n\n        e.exports = JSON.parse('{\"API_CALLED\":\"API - {apiName} called\",\"SERVICE_INITIALIZED\":\"VWO {service} initialized while creating an instance of SDK\",\"EXPERIMENTS_EVALUATION_WHEN_ROLLOUT_PASSED\":\"Rollout rule got passed for user {userId}. Hence, evaluating experiments\",\"EXPERIMENTS_EVALUATION_WHEN_NO_ROLLOUT_PRESENT\":\"No Rollout rules present for the feature. Hence, checking experiment rules\",\"USER_BUCKET_TO_VARIATION\":\"User ID:{userId} for experiment:{campaignKey} having percent traffic:{percentTraffic} got bucket-value:{bucketValue} and hash-value:{hashValue}\",\"IMPRESSION_FOR_TRACK_USER\":\"Impression built for vwo_variationShown(VWO standard event for tracking user) event haivng Account ID:{accountId}, User ID:{userId}, and experiment ID:{campaignId}\",\"IMPRESSION_FOR_TRACK_GOAL\":\"Impression built for event:{eventName} event having Account ID:{accountId}, and user ID:{userId}\",\"IMPRESSION_FOR_SYNC_VISITOR_PROP\":\"Impression built for {eventName}(VWO internal event) event for Account ID:{accountId}, and user ID:{userId}\"}');\n      },\n      1198: e => {\n        \"use strict\";\n\n        e.exports = JSON.parse('{\"INIT_OPTIONS_ERROR\":\"[ERROR]: VWO-SDK {date} Options should be of type object\",\"INIT_OPTIONS_SDK_KEY_ERROR\":\"[ERROR]: VWO-SDK {date} Please provide the sdkKey in the options and should be a of type string\",\"INIT_OPTIONS_ACCOUNT_ID_ERROR\":\"[ERROR]: VWO-SDK {date} Please provide VWO account ID in the options and should be a of type string|number\",\"INIT_OPTIONS_INVALID\":\"Invalid key:{key} passed in options. Should be of type:{correctType} and greater than equal to 1000\",\"SETTINGS_FETCH_ERROR\":\"Settings could not be fetched. Error:{err}\",\"SETTINGS_SCHEMA_INVALID\":\"Settings are not valid. Failed schema validation\",\"POLLING_FETCH_SETTINGS_FAILED\":\"Error while fetching VWO settings with polling\",\"API_THROW_ERROR\":\"API - {apiName} failed to execute. Trace:{err}\",\"API_INVALID_PARAM\":\"Key:{key} passed to API:{apiName} is not of valid type. Got type:{type}, should be:{correctType}\",\"API_SETTING_INVALID\":\"Settings are not valid. Contact VWO Support\",\"API_CONTEXT_INVALID\":\"Context should be an object and must contain a mandatory key - id, which is User ID\",\"FEATURE_NOT_FOUND\":\"Feature not found for the key:{featureKey}\",\"EVENT_NOT_FOUND\":\"Event:{eventName} not found in any of the features\\' metrics\",\"STORED_DATA_ERROR\":\"Error in getting data from storage. Error:{err}\",\"STORING_DATA_ERROR\":\"Key:{featureKey} is not valid. Not able to store data into storage\",\"GATEWAY_URL_ERROR\":\"Please provide a valid URL for VWO Gateway Service while initializing the SDK\",\"NETWORK_CALL_FAILED\":\"Error occurred while sending {method} request. Error:{err}\"}');\n      },\n      7778: e => {\n        \"use strict\";\n\n        e.exports = JSON.parse('{\"ON_INIT_ALREADY_RESOLVED\":\"[INFO]: VWO-SDK {date} {apiName} already resolved\",\"ON_INIT_SETTINGS_FAILED\":\"[INFO]: VWO-SDK {date} VWO settings could not be fetched\",\"POLLING_SET_SETTINGS\":\"There\\'s a change in settings from the last settings fetched. Hence, instantiating a new VWO client internally\",\"POLLING_NO_CHANGE_IN_SETTINGS\":\"No change in settings with the last settings fetched. Hence, not instantiating new VWO client\",\"SETTINGS_FETCH_SUCCESS\":\"Settings fetched successfully\",\"CLIENT_INITIALIZED\":\"VWO Client initialized\",\"STORED_VARIATION_FOUND\":\"Variation {variationKey} found in storage for the user {userId} for the {experimentType} experiment:{experimentKey}\",\"USER_PART_OF_CAMPAIGN\":\"User ID:{userId} is {notPart} part of experiment:{campaignKey}\",\"SEGMENTATION_SKIP\":\"For userId:{userId} of experiment:{campaignKey}, segments was missing. Hence, skipping segmentation\",\"SEGMENTATION_STATUS\":\"Segmentation {status} for userId:{userId} of experiment:{campaignKey}\",\"USER_CAMPAIGN_BUCKET_INFO\":\"User ID:{userId} for experiment:{campaignKey} {status}\",\"WHITELISTING_SKIP\":\"Whitelisting is not used for experiment:{campaignKey}, hence skipping evaluating whitelisting {variation} for User ID:{userId}\",\"WHITELISTING_STATUS\":\"User ID:{userId} for experiment:{campaignKey} {status} whitelisting {variationString}\",\"VARIATION_RANGE_ALLOCATION\":\"Variation:{variationKey} of experiment:{campaignKey} having weight:{variationWeight} got bucketing range: ({startRange} - {endRange})\",\"IMPACT_ANALYSIS\":\"Tracking feature:{featureKey} being {status} for Impact Analysis Campaign for the user {userId}\",\"MEG_SKIP_ROLLOUT_EVALUATE_EXPERIMENTS\":\"No rollout rule found for feature:{featureKey}. Hence, evaluating experiments\",\"MEG_CAMPAIGN_FOUND_IN_STORAGE\":\"Campaign {campaignKey} found in storage for user ID:{userId}\",\"MEG_CAMPAIGN_ELIGIBLE\":\"Campaign {campaignKey} is eligible for user ID:{userId}\",\"MEG_WINNER_CAMPAIGN\":\"MEG: Campaign {campaignKey} is the winner for group {groupId} for user ID:{userId} {algo}\"}');\n      },\n      6611: e => {\n        \"use strict\";\n\n        e.exports = {};\n      },\n      8854: e => {\n        \"use strict\";\n\n        e.exports = {};\n      }\n    },\n    t = {};\n  function n(r) {\n    var o = t[r];\n    if (void 0 !== o) return o.exports;\n    var i = t[r] = {\n      exports: {}\n    };\n    return e[r].call(i.exports, i, i.exports, n), i.exports;\n  }\n  var r = {};\n  return (() => {\n    \"use strict\";\n\n    var e = r;\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.onInit = e.init = e.StorageConnector = e.LogLevelEnum = void 0;\n    var t = n(4940);\n    Object.defineProperty(e, \"LogLevelEnum\", {\n      enumerable: !0,\n      get: function () {\n        return t.LogLevelEnum;\n      }\n    });\n    var o = n(5030);\n    Object.defineProperty(e, \"StorageConnector\", {\n      enumerable: !0,\n      get: function () {\n        return o.Connector;\n      }\n    });\n    var i = n(9709);\n    Object.defineProperty(e, \"init\", {\n      enumerable: !0,\n      get: function () {\n        return i.init;\n      }\n    }), Object.defineProperty(e, \"onInit\", {\n      enumerable: !0,\n      get: function () {\n        return i.onInit;\n      }\n    });\n  })(), r;\n})());","map":{"version":3,"names":[],"sources":["webpack://vwoSdk/webpack/universalModuleDefinition","webpack://vwoSdk/node_modules/murmurhash/murmurhash.js","webpack://vwoSdk/lib/VWO.ts","webpack://vwoSdk/lib/VWOBuilder.ts","webpack://vwoSdk/lib/VWOClient.ts","webpack://vwoSdk/lib/api/GetFlag.ts","webpack://vwoSdk/lib/api/SetAttribute.ts","webpack://vwoSdk/lib/api/TrackEvent.ts","webpack://vwoSdk/lib/constants/Url.ts","webpack://vwoSdk/lib/constants/index.ts","webpack://vwoSdk/lib/decorators/StorageDecorator.ts","webpack://vwoSdk/lib/enums/ApiEnum.ts","webpack://vwoSdk/lib/enums/CampaignTypeEnum.ts","webpack://vwoSdk/lib/enums/EventEnum.ts","webpack://vwoSdk/lib/enums/HeadersEnum.ts","webpack://vwoSdk/lib/enums/HttpMethodEnum.ts","webpack://vwoSdk/lib/enums/PlatformEnum.ts","webpack://vwoSdk/lib/enums/StatusEnum.ts","webpack://vwoSdk/lib/enums/StorageEnum.ts","webpack://vwoSdk/lib/enums/UrlEnum.ts","webpack://vwoSdk/lib/enums/log-messages/index.ts","webpack://vwoSdk/lib/models/campaign/CampaignModel.ts","webpack://vwoSdk/lib/models/campaign/FeatureModel.ts","webpack://vwoSdk/lib/models/campaign/ImpactCampaignModel.ts","webpack://vwoSdk/lib/models/campaign/MetricModel.ts","webpack://vwoSdk/lib/models/campaign/RuleModel.ts","webpack://vwoSdk/lib/models/campaign/VariableModel.ts","webpack://vwoSdk/lib/models/campaign/VariationModel.ts","webpack://vwoSdk/lib/models/schemas/SettingsSchemaValidation.ts","webpack://vwoSdk/lib/models/settings/SettingsModel.ts","webpack://vwoSdk/lib/models/user/ContextModel.ts","webpack://vwoSdk/lib/models/user/ContextVWOModel.ts","webpack://vwoSdk/lib/packages/decision-maker/index.ts","webpack://vwoSdk/lib/packages/logger/LogMessageBuilder.ts","webpack://vwoSdk/lib/packages/logger/Logger.ts","webpack://vwoSdk/lib/packages/logger/core/LogManager.ts","webpack://vwoSdk/lib/packages/logger/core/TransportManager.ts","webpack://vwoSdk/lib/packages/logger/enums/LogLevelEnum.ts","webpack://vwoSdk/lib/packages/logger/index.ts","webpack://vwoSdk/lib/packages/logger/transports/ConsoleTransport.ts","webpack://vwoSdk/lib/packages/network-layer/client/NetworkBrowserClient.ts","webpack://vwoSdk/lib/packages/network-layer/handlers/RequestHandler.ts","webpack://vwoSdk/lib/packages/network-layer/index.ts","webpack://vwoSdk/lib/packages/network-layer/manager/NetworkManager.ts","webpack://vwoSdk/lib/packages/network-layer/models/GlobalRequestModel.ts","webpack://vwoSdk/lib/packages/network-layer/models/RequestModel.ts","webpack://vwoSdk/lib/packages/network-layer/models/ResponseModel.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/core/SegmentationManger.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/enums/SegmentOperandRegexEnum.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/enums/SegmentOperandValueEnum.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/enums/SegmentOperatorValueEnum.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/evaluators/SegmentEvaluator.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/evaluators/SegmentOperandEvaluator.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/index.ts","webpack://vwoSdk/lib/packages/segmentation-evaluator/utils/SegmentUtil.ts","webpack://vwoSdk/lib/packages/storage/Connector.ts","webpack://vwoSdk/lib/packages/storage/Storage.ts","webpack://vwoSdk/lib/packages/storage/index.ts","webpack://vwoSdk/lib/services/CampaignDecisionService.ts","webpack://vwoSdk/lib/services/HooksService.ts","webpack://vwoSdk/lib/services/SettingsService.ts","webpack://vwoSdk/lib/services/StorageService.ts","webpack://vwoSdk/lib/utils/CampaignUtil.ts","webpack://vwoSdk/lib/utils/DataTypeUtil.ts","webpack://vwoSdk/lib/utils/DecisionUtil.ts","webpack://vwoSdk/lib/utils/FunctionUtil.ts","webpack://vwoSdk/lib/utils/GatewayServiceUtil.ts","webpack://vwoSdk/lib/utils/ImpressionUtil.ts","webpack://vwoSdk/lib/utils/LogMessageUtil.ts","webpack://vwoSdk/lib/utils/MegUtil.ts","webpack://vwoSdk/lib/utils/NetworkUtil.ts","webpack://vwoSdk/lib/utils/PromiseUtil.ts","webpack://vwoSdk/lib/utils/RuleEvaluationUtil.ts","webpack://vwoSdk/lib/utils/SettingsUtil.ts","webpack://vwoSdk/lib/utils/UrlUtil.ts","webpack://vwoSdk/lib/utils/UuidUtil.ts","webpack://vwoSdk/lib/utils/XMLUtil.ts","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/index.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/md5.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/native.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/nil.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/parse.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/regex.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/rng.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/sha1.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/stringify.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/v1.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/v3.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/v35.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/v4.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/v5.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/validate.js","webpack://vwoSdk/node_modules/uuid/dist/commonjs-browser/version.js","webpack://vwoSdk/node_modules/vwo-fme-sdk-log-messages/index.js","webpack://vwoSdk/node_modules/superstruct/lib/index.cjs","webpack://vwoSdk/webpack/bootstrap","webpack://vwoSdk/lib/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\t// CommonJS2\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\t// AMD\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\t// CommonJS\n\telse if(typeof exports === 'object')\n\t\texports[\"vwoSdk\"] = factory();\n\t// Root\n\telse\n\t\troot[\"vwoSdk\"] = factory();\n})(this, () => {\nreturn ","(function(){\n  const _global = this;\n\n  const createBuffer = (val) => new TextEncoder().encode(val)\n\n  /**\n   * JS Implementation of MurmurHash2\n   *\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n   * @see http://github.com/garycourt/murmurhash-js\n   * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n   * @see http://sites.google.com/site/murmurhash/\n   *\n   * @param {Uint8Array | string} str ASCII only\n   * @param {number} seed Positive integer only\n   * @return {number} 32-bit positive integer hash\n   */\n  function MurmurHashV2(str, seed) {\n    if (typeof str === 'string') str = createBuffer(str);\n    let\n      l = str.length,\n      h = seed ^ l,\n      i = 0,\n      k;\n\n    while (l >= 4) {\n      k =\n        ((str[i] & 0xff)) |\n        ((str[++i] & 0xff) << 8) |\n        ((str[++i] & 0xff) << 16) |\n        ((str[++i] & 0xff) << 24);\n\n      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n      k ^= k >>> 24;\n      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n\n    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;\n\n      l -= 4;\n      ++i;\n    }\n\n    switch (l) {\n    case 3: h ^= (str[i + 2] & 0xff) << 16;\n    case 2: h ^= (str[i + 1] & 0xff) << 8;\n    case 1: h ^= (str[i] & 0xff);\n            h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n    }\n\n    h ^= h >>> 13;\n    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n    h ^= h >>> 15;\n\n    return h >>> 0;\n  };\n\n  /*\n   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n   *\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n   * @see http://github.com/garycourt/murmurhash-js\n   * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n   * @see http://sites.google.com/site/murmurhash/\n   *\n   * @param {Uint8Array | string} key ASCII only\n   * @param {number} seed Positive integer only\n   * @return {number} 32-bit positive integer hash\n   */\n  function MurmurHashV3(key, seed) {\n    if (typeof key === 'string') key = createBuffer(key);\n\n    let remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;\n\n    remainder = key.length & 3; // key.length % 4\n    bytes = key.length - remainder;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n    i = 0;\n\n    while (i < bytes) {\n        k1 =\n          ((key[i] & 0xff)) |\n          ((key[++i] & 0xff) << 8) |\n          ((key[++i] & 0xff) << 16) |\n          ((key[++i] & 0xff) << 24);\n      ++i;\n\n      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n      k1 = (k1 << 15) | (k1 >>> 17);\n      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n      h1 ^= k1;\n          h1 = (h1 << 13) | (h1 >>> 19);\n      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n      case 3: k1 ^= (key[i + 2] & 0xff) << 16;\n      case 2: k1 ^= (key[i + 1] & 0xff) << 8;\n      case 1: k1 ^= (key[i] & 0xff);\n\n      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n      k1 = (k1 << 15) | (k1 >>> 17);\n      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n      h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n  }\n\n  const murmur = MurmurHashV3;\n  murmur.v2 = MurmurHashV2;\n  murmur.v3 = MurmurHashV3;\n\n  if (typeof(module) != 'undefined') {\n    module.exports = murmur;\n  } else {\n    const _previousRoot = _global.murmur;\n    murmur.noConflict = function() {\n      _global.murmur = _previousRoot;\n      return murmur;\n    }\n    _global.murmur = murmur;\n  }\n}());\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { VWOBuilder } from './VWOBuilder';\nimport { IVWOClient } from './VWOClient';\nimport { IVWOOptions } from './models/VWOOptionsModel';\nimport { SettingsModel } from './models/settings/SettingsModel';\nimport { dynamic } from './types/Common';\nimport { isObject, isString } from './utils/DataTypeUtil';\nimport { Deferred } from './utils/PromiseUtil';\n\nimport { InfoLogMessagesEnum, ErrorLogMessagesEnum } from './enums/log-messages';\nimport { buildMessage } from './utils/LogMessageUtil';\nimport { PlatformEnum } from './enums/PlatformEnum';\n\nexport class VWO {\n  private static vwoBuilder: VWOBuilder;\n  private static instance: dynamic;\n\n  /**\n   * Constructor for the VWO class.\n   * Initializes a new instance of VWO with the provided options.\n   * @param {Record<string, dynamic>} options - Configuration options for the VWO instance.\n   * @returns The instance of VWO.\n   */\n  constructor(options: IVWOOptions) {\n    return VWO.setInstance(options);\n  }\n\n  /**\n   * Sets the singleton instance of VWO.\n   * Configures and builds the VWO instance using the provided options.\n   * @param {Record<string, dynamic>} options - Configuration options for setting up VWO.\n   * @returns A Promise resolving to the configured VWO instance.\n   */\n  private static setInstance(options: IVWOOptions): Promise<IVWOClient> {\n    const optionsVWOBuilder: any = options?.vwoBuilder;\n    this.vwoBuilder = optionsVWOBuilder || new VWOBuilder(options);\n\n    this.instance = this.vwoBuilder\n      .setLogger() // Sets up logging for debugging and monitoring.\n      .setSettingsService() // Sets the settings service for configuration management.\n      .setStorage() // Configures storage for data persistence.\n      .setNetworkManager() // Configures network management for API communication.\n      .setSegmentation() // Sets up segmentation for targeted functionality.\n      // .initBatching()        // Initializes batching for bulk data processing.\n      .initPolling(); // Starts polling mechanism for regular updates.\n    // .setAnalyticsCallback() // Sets up analytics callback for data analysis.\n\n    return this.vwoBuilder.getSettings().then((settings: SettingsModel) => {\n      return this.vwoBuilder.build(settings); // Builds the VWO instance with the fetched settings.\n    });\n  }\n\n  /**\n   * Gets the singleton instance of VWO.\n   * @returns The singleton instance of VWO.\n   */\n  static get Instance(): dynamic {\n    return this.instance;\n  }\n}\n\nlet _global: Record<string, any> = {};\n/**\n * Initializes a new instance of VWO with the provided options.\n * @param options Configuration options for the VWO instance.\n * @property {string} sdkKey - The SDK key for the VWO account.\n * @property {string} accountId - The account ID for the VWO account.\n * @property {GatewayServiceModel} gatewayService - The gateway service configuration.\n * @property {StorageService} storage - The storage configuration.\n * @returns\n */\n\nexport async function init(options: IVWOOptions): Promise<IVWOClient> {\n  const apiName = 'init';\n  const date = new Date().toISOString();\n\n  try {\n    if (!isObject(options)) {\n      const msg = buildMessage(ErrorLogMessagesEnum.INIT_OPTIONS_ERROR, {\n        date,\n      });\n      console.error(msg); // Ensures options is an object.\n    }\n\n    if (!options?.sdkKey || !isString(options?.sdkKey)) {\n      const msg = buildMessage(ErrorLogMessagesEnum.INIT_OPTIONS_SDK_KEY_ERROR, {\n        date,\n      });\n      console.error(msg); // Validates sdkKey presence and type.\n    }\n\n    if (!options.accountId) {\n      const msg = buildMessage(ErrorLogMessagesEnum.INIT_OPTIONS_ACCOUNT_ID_ERROR, {\n        date,\n      });\n      console.error(msg); // Validates accountId presence and type.\n    }\n\n    if (typeof process.env === 'undefined') {\n      options.platform = PlatformEnum.CLIENT;\n    } else {\n      options.platform = PlatformEnum.SERVER;\n    }\n\n    const instance: any = new VWO(options); // Creates a new VWO instance with the validated options.\n\n    _global = {\n      vwoInitDeferred: new Deferred(),\n      isSettingsFetched: false,\n      instance: null,\n    };\n\n    return instance.then((_vwoInstance) => {\n      _global.isSettingsFetched = true;\n      _global.instance = _vwoInstance;\n      _global.vwoInitDeferred.resolve(_vwoInstance);\n\n      return _vwoInstance;\n    });\n  } catch (err) {\n    const msg = buildMessage(ErrorLogMessagesEnum.API_THROW_ERROR, {\n      apiName,\n      err,\n    });\n\n    console.info(`[INFO]: VWO-SDK ${new Date().toISOString()} ${msg}`);\n  }\n}\n\nexport async function onInit() {\n  const apiName = 'onInit';\n\n  try {\n    _global.vwoInitDeferred = new Deferred();\n    const date = new Date().toISOString();\n\n    // If settings are already fetched, resolve the promise\n    if (_global.isSettingsFetched) {\n      const msg = buildMessage(InfoLogMessagesEnum.ON_INIT_ALREADY_RESOLVED, {\n        date,\n        apiName,\n      });\n\n      console.info(msg);\n      _global.vwoInitDeferred.resolve(_global.instance);\n    } else {\n      // wait for five seconds, else reject the promise\n      setTimeout(() => {\n        if (_global.isSettingsFetched) {\n          return;\n        }\n\n        const msg = buildMessage(InfoLogMessagesEnum.ON_INIT_SETTINGS_FAILED, {\n          date,\n        });\n\n        console.error(msg);\n        _global.vwoInitDeferred.reject(new Error('VWO settings could not be fetched'));\n      }, 5000);\n    }\n\n    return _global.vwoInitDeferred.promise;\n  } catch (err) {\n    const msg = buildMessage(ErrorLogMessagesEnum.API_THROW_ERROR, {\n      apiName,\n      err,\n    });\n\n    console.info(`[INFO]: VWO-SDK ${new Date().toISOString()} ${msg}`);\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from './types/Common';\n\nimport { ILogManager, LogManager } from './packages/logger';\nimport { NetworkManager } from './packages/network-layer';\nimport { SegmentationManager } from './packages/segmentation-evaluator';\n\nimport { Storage } from './packages/storage';\n\nimport { IVWOClient, VWOClient } from './VWOClient';\nimport { SettingsModel } from './models/settings/SettingsModel';\nimport { SettingsService } from './services/SettingsService';\n\nimport { DebugLogMessagesEnum, ErrorLogMessagesEnum, InfoLogMessagesEnum } from './enums/log-messages';\nimport { IVWOOptions } from './models/VWOOptionsModel';\nimport { isNumber } from './utils/DataTypeUtil';\nimport { cloneObject } from './utils/FunctionUtil';\nimport { buildMessage } from './utils/LogMessageUtil';\nimport { Deferred } from './utils/PromiseUtil';\nimport { setSettingsAndAddCampaignsToRules } from './utils/SettingsUtil';\nimport { getRandomUUID } from './utils/UuidUtil';\n\nexport interface IVWOBuilder {\n  settings: SettingsModel; // Holds the configuration settings for the VWO client\n  storage: Storage; // Interface for storage management\n  logManager: ILogManager; // Manages logging across the VWO SDK\n  isSettingsFetchInProgress: boolean; // Flag to check if settings fetch is in progress\n  vwoInstance: IVWOClient;\n\n  build(settings: SettingsModel): IVWOClient; // Builds and returns a new VWOClient instance\n\n  fetchSettings(): Promise<SettingsModel>; // Asynchronously fetches settings from the server\n  setSettingsService(): this; // Sets up the settings manager with provided options\n  getSettings(force: boolean): Promise<dynamic>; // Fetches settings, optionally forcing a refresh\n  setStorage(): this; // Sets up the storage connector based on provided options\n  setNetworkManager(): this; // Configures the network manager with client and mode\n  // initBatching(): this; // Initializes event batching with provided configuration\n  // setAnalyticsCallback(): this; // Configures the analytics callback based on provided options\n  initPolling(): this; // Sets up polling for settings at a specified interval\n  setLogger(): this; // Sets up the logger with specified options\n  setSegmentation(): this; // Configures the segmentation evaluator with provided options\n}\n\nexport class VWOBuilder implements IVWOBuilder {\n  readonly sdkKey: string;\n  readonly options: IVWOOptions;\n\n  private settingFileManager: SettingsService;\n\n  settings: SettingsModel;\n  storage: Storage;\n  logManager: ILogManager;\n  originalSettings: dynamic;\n  isSettingsFetchInProgress: boolean;\n  vwoInstance: IVWOClient;\n\n  constructor(options: IVWOOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Sets the network manager with the provided client and development mode options.\n   * @returns {this} The instance of this builder.\n   */\n  setNetworkManager(): this {\n    const networkInstance = NetworkManager.Instance;\n    // Attach the network client from options\n    networkInstance.attachClient(this.options?.network?.client);\n\n    LogManager.Instance.debug(\n      buildMessage(DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n        service: `Network Layer`,\n      }),\n    );\n    // Set the development mode based on options\n    networkInstance.getConfig().setDevelopmentMode(this.options?.isDevelopmentMode);\n    return this;\n  }\n\n  /**\n   * Sets the segmentation evaluator with the provided segmentation options.\n   * @returns {this} The instance of this builder.\n   */\n  setSegmentation(): this {\n    SegmentationManager.Instance.attachEvaluator(this.options?.segmentation);\n    LogManager.Instance.debug(\n      buildMessage(DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n        service: `Segmentation Evaluator`,\n      }),\n    );\n    return this;\n  }\n\n  /**\n   * Fetches settings asynchronously, ensuring no parallel fetches.\n   * @param {boolean} [force=false] - Force fetch ignoring cache.\n   * @returns {Promise<SettingsModel>} A promise that resolves to the fetched settings.\n   */\n  fetchSettings(force?: boolean): Promise<SettingsModel> {\n    const deferredObject = new Deferred();\n\n    // Check if a fetch operation is already in progress\n    if (!this.isSettingsFetchInProgress) {\n      this.isSettingsFetchInProgress = true;\n      this.settingFileManager.getSettings(force).then((settings: SettingsModel) => {\n        // if force is false, update original settings, if true the request is from polling and no need to update original settings\n        if (!force) {\n          this.originalSettings = settings;\n        }\n\n        this.isSettingsFetchInProgress = false;\n        deferredObject.resolve(settings);\n      });\n\n      return deferredObject.promise;\n    } else {\n      // Avoid parallel fetches by recursively calling fetchSettings\n      return this.fetchSettings(force);\n    }\n  }\n\n  /**\n   * Gets the settings, fetching them if not cached or if forced.\n   * @param {boolean} [force=false] - Force fetch ignoring cache.\n   * @returns {Promise<SettingsModel>} A promise that resolves to the settings.\n   */\n  getSettings(force?: boolean): Promise<SettingsModel> {\n    const deferredObject = new Deferred();\n\n    try {\n      // Use cached settings if available and not forced to fetch\n      if (!force && this.settings) {\n        LogManager.Instance.info('Using already fetched and cached settings');\n        deferredObject.resolve(this.settings);\n      } else {\n        // Fetch settings if not cached or forced\n        this.fetchSettings(force).then((settings: SettingsModel) => {\n          deferredObject.resolve(settings);\n        });\n      }\n    } catch (err) {\n      LogManager.Instance.error('Failed to fetch settings. Error: ' + err);\n      deferredObject.resolve({});\n    }\n    return deferredObject.promise;\n  }\n\n  /**\n   * Sets the storage connector based on the provided storage options.\n   * @returns {this} The instance of this builder.\n   */\n  setStorage(): this {\n    if (this.options.storage) {\n      // Attach the storage connector from options\n      this.storage = Storage.Instance.attachConnector(this.options.storage);\n    } else {\n      // Set storage to null if no storage options provided\n      this.storage = null;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the settings manager with the provided options.\n   * @returns {this} The instance of this builder.\n   */\n  setSettingsService(): this {\n    this.settingFileManager = new SettingsService(this.options);\n\n    return this;\n  }\n\n  /**\n   * Sets the logger with the provided logger options.\n   * @returns {this} The instance of this builder.\n   */\n  setLogger(): this {\n    this.logManager = new LogManager(this.options.logger || {});\n\n    LogManager.Instance.debug(\n      buildMessage(DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n        service: `Logger`,\n      }),\n    );\n    return this;\n  }\n\n  /**\n   * Sets the analytics callback with the provided analytics options.\n   * @returns {this} The instance of this builder.\n   */\n  /* setAnalyticsCallback(): this {\n    if (!isObject(this.options.analyticsEvent)) {\n      // TODO: add logging here\n      return this;\n    }\n\n    if (!isFunction(this.options.analyticsEvent.eventCallback)) {\n      // TODO: add logging here\n      return this;\n    }\n\n    if (\n      this.options.analyticsEvent.isBatchingSupported &&\n      !isBoolean(this.options.analyticsEvent.isBatchingSupported)\n    ) {\n      // TODO:- add logging here\n      return this;\n    }\n\n    // AnalyticsEvent.Instance.attachCallback(\n    //   this.options.analyticsEvent.eventCallback,\n    //   this.options.analyticsEvent.isBatchingSupported\n    // );\n    return this;\n  } */\n\n  /**\n   * Generates a random user ID based on the provided API key.\n   * @returns {string} The generated random user ID.\n   */\n  getRandomUserId(): string {\n    const apiName = 'getRandomUserId';\n    try {\n      LogManager.Instance.debug(\n        buildMessage(DebugLogMessagesEnum.API_CALLED, {\n          apiName,\n        }),\n      );\n\n      return getRandomUUID(this.options.sdkKey);\n    } catch (err) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.API_THROW_ERROR, {\n          apiName,\n          err,\n        }),\n      );\n    }\n  }\n\n  /**\n   * Initializes the batching with the provided batch events options.\n   * @returns {this} The instance of this builder.\n   */\n  /* initBatching(): this {\n    if (!isObject(this.options.batchEvents)) {\n      // TODO:- add logging here\n      return this;\n    }\n\n    if (\n      isObject(this.options.batchEvents) &&\n      (!(\n        (isNumber(this.options.batchEvents.eventsPerRequest) &&\n          this.options.batchEvents.eventsPerRequest > 0 &&\n          this.options.batchEvents.eventsPerRequest <= Constants.MAX_EVENTS_PER_REQUEST) ||\n        (isNumber(this.options.batchEvents.requestTimeInterval) && this.options.batchEvents.requestTimeInterval >= 1)\n      ) ||\n        !isFunction(this.options.batchEvents.flushCallback))\n    ) {\n      LogManager.Instance.error('Invalid batchEvents config');\n      // throw new Error('Invalid batchEvents config');\n      return this;\n    }\n\n    // BatchEventsQueue.Instance.setBatchConfig(this.options.batchEvents, this.options.sdkKey); // TODO\n\n    return this;\n  } */\n\n  /**\n   * Initializes the polling with the provided poll interval.\n   * @returns {this} The instance of this builder.\n   */\n  initPolling(): this {\n    if (!this.options.pollInterval) {\n      return this;\n    }\n\n    if (this.options.pollInterval && !isNumber(this.options.pollInterval)) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.INIT_OPTIONS_INVALID, {\n          key: 'pollInterval',\n          correctType: 'number',\n        }),\n      );\n      return this;\n    }\n\n    if (this.options.pollInterval && this.options.pollInterval < 1000) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.INIT_OPTIONS_INVALID, {\n          key: 'pollInterval',\n          correctType: 'number',\n        }),\n      );\n      return this;\n    }\n\n    this.checkAndPoll();\n\n    return this;\n  }\n\n  /**\n   * Builds a new VWOClient instance with the provided settings.\n   * @param {SettingsModel} settings - The settings for the VWOClient.\n   * @returns {VWOClient} The new VWOClient instance.\n   */\n  build(settings: SettingsModel): IVWOClient {\n    this.vwoInstance = new VWOClient(settings, this.options);\n\n    return this.vwoInstance;\n  }\n\n  /**\n   * Checks and polls for settings updates at the provided interval.\n   */\n  checkAndPoll(): void {\n    const pollingInterval = this.options.pollInterval;\n\n    setInterval(() => {\n      this.getSettings(true)\n        .then((latestSettings: SettingsModel) => {\n          const lastSettings = JSON.stringify(this.originalSettings);\n          const stringifiedLatestSettings = JSON.stringify(latestSettings);\n          if (stringifiedLatestSettings !== lastSettings) {\n            this.originalSettings = latestSettings;\n            const clonedSettings = cloneObject(latestSettings);\n\n            LogManager.Instance.info(InfoLogMessagesEnum.POLLING_SET_SETTINGS);\n            setSettingsAndAddCampaignsToRules(clonedSettings, this.vwoInstance);\n          } else {\n            LogManager.Instance.info(InfoLogMessagesEnum.POLLING_NO_CHANGE_IN_SETTINGS);\n          }\n        })\n        .catch(() => {\n          LogManager.Instance.error(ErrorLogMessagesEnum.POLLING_FETCH_SETTINGS_FAILED);\n        });\n    }, pollingInterval);\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LogManager } from './packages/logger';\nimport { Storage } from './packages/storage';\n\nimport { FlagApi } from './api/GetFlag';\nimport { SetAttributeApi } from './api/SetAttribute';\nimport { TrackApi } from './api/TrackEvent';\n\nimport { DebugLogMessagesEnum, ErrorLogMessagesEnum, InfoLogMessagesEnum } from './enums/log-messages';\nimport { SettingsModel } from './models/settings/SettingsModel';\n\nimport { dynamic } from './types/Common';\n// import { BatchEventsQueue } from './services/batchEventsQueue';\n\nimport { SettingsSchema } from './models/schemas/SettingsSchemaValidation';\nimport { ContextModel } from './models/user/ContextModel';\nimport HooksService from './services/HooksService';\nimport { UrlUtil } from './utils/UrlUtil';\n\nimport { getType, isBoolean, isNumber, isObject, isString } from './utils/DataTypeUtil';\n\nimport { buildMessage } from './utils/LogMessageUtil';\nimport { Deferred } from './utils/PromiseUtil';\n\nimport { IVWOOptions } from './models/VWOOptionsModel';\nimport { setSettingsAndAddCampaignsToRules } from './utils/SettingsUtil';\nimport { setShouldWaitForTrackingCalls } from './utils/NetworkUtil';\n\nexport interface IVWOClient {\n  readonly options?: IVWOOptions;\n  settings: SettingsModel;\n\n  getFlag(featureKey: string, context: Record<string, any>): Record<any, any>;\n  trackEvent(\n    eventName: string,\n    context: Record<string, any>,\n    eventProperties: Record<string, dynamic>,\n  ): Promise<Record<string, boolean>>;\n  setAttribute(\n    attributeKey: string,\n    attributeValue: boolean | string | number,\n    context: Record<string, any>,\n  ): Promise<void>;\n}\n\nexport class VWOClient implements IVWOClient {\n  settings: SettingsModel;\n  originalSettings: Record<any, any>;\n  storage: Storage;\n\n  constructor(settings: SettingsModel, options: IVWOOptions) {\n    this.options = options;\n\n    setSettingsAndAddCampaignsToRules(settings, this);\n\n    UrlUtil.init({\n      collectionPrefix: this.settings.getCollectionPrefix(),\n    });\n\n    setShouldWaitForTrackingCalls(this.options.shouldWaitForTrackingCalls || false);\n\n    LogManager.Instance.info(InfoLogMessagesEnum.CLIENT_INITIALIZED);\n    return this;\n  }\n  options?: IVWOOptions;\n  /**\n   * Retrieves the value of a feature flag for a given feature key and context.\n   * This method validates the feature key and context, ensures the settings are valid, and then uses the FlagApi to get the flag value.\n   *\n   * @param {string} featureKey - The key of the feature to retrieve.\n   * @param {ContextModel} context - The context in which the feature flag is being retrieved, must include a valid user ID.\n   * @returns {Promise<Record<any, any>>} - A promise that resolves to the feature flag value.\n   */\n  getFlag(featureKey: string, context: Record<string, any>): Record<any, any> {\n    const apiName = 'getFlag';\n    const deferredObject = new Deferred();\n    const errorReturnSchema = {\n      isEnabled: (): boolean => false,\n      getVariables: (): Array<Record<string, dynamic>> => [],\n      getVariable: (_key: string, defaultValue: any): dynamic => defaultValue,\n    };\n\n    try {\n      const hooksService = new HooksService(this.options);\n\n      LogManager.Instance.debug(\n        buildMessage(DebugLogMessagesEnum.API_CALLED, {\n          apiName,\n        }),\n      );\n\n      // Validate featureKey is a string\n      if (!isString(featureKey)) {\n        LogManager.Instance.error(\n          buildMessage(ErrorLogMessagesEnum.API_INVALID_PARAM, {\n            apiName,\n            key: 'featureKey',\n            type: getType(featureKey),\n            correctType: 'string',\n          }),\n        );\n\n        throw new TypeError('TypeError: featureKey should be a string');\n      }\n\n      // Validate settings are loaded and valid\n      if (!new SettingsSchema().isSettingsValid(this.originalSettings)) {\n        LogManager.Instance.error(ErrorLogMessagesEnum.API_SETTING_INVALID);\n        throw new Error('TypeError: Invalid Settings');\n      }\n\n      // Validate user ID is present in context\n      if (!context || !context.id) {\n        LogManager.Instance.error(ErrorLogMessagesEnum.API_CONTEXT_INVALID);\n        throw new TypeError('TypeError: Invalid context');\n      }\n\n      const contextModel = new ContextModel().modelFromDictionary(context);\n\n      new FlagApi()\n        .get(featureKey, this.settings, contextModel, hooksService)\n        .then((data: any) => {\n          deferredObject.resolve(data);\n        })\n        .catch(() => {\n          deferredObject.resolve(errorReturnSchema);\n        });\n    } catch (err) {\n      LogManager.Instance.info(\n        buildMessage(ErrorLogMessagesEnum.API_THROW_ERROR, {\n          apiName,\n          err,\n        }),\n      );\n\n      deferredObject.resolve(errorReturnSchema);\n    }\n\n    return deferredObject.promise;\n  }\n\n  /**\n   * Tracks an event with specified properties and context.\n   * This method validates the types of the inputs and ensures the settings and user context are valid before proceeding.\n   *\n   * @param {string} eventName - The name of the event to track.\n   * @param {ContextModel} context - The context in which the event is being tracked, must include a valid user ID.\n   * @param {Record<string, dynamic>} eventProperties - The properties associated with the event.\n   * @returns {Promise<Record<string, boolean>>} - A promise that resolves to the result of the tracking operation.\n   */\n  trackEvent(\n    eventName: string,\n    context: Record<string, any>,\n    eventProperties: Record<string, dynamic> = {},\n  ): Promise<Record<string, boolean>> {\n    const apiName = 'trackEvent';\n    const deferredObject = new Deferred();\n\n    try {\n      const hooksService = new HooksService(this.options);\n\n      // Log the API call\n      LogManager.Instance.debug(\n        buildMessage(DebugLogMessagesEnum.API_CALLED, {\n          apiName,\n        }),\n      );\n\n      // Validate eventName is a string\n      if (!isString(eventName)) {\n        LogManager.Instance.error(\n          buildMessage(ErrorLogMessagesEnum.API_INVALID_PARAM, {\n            apiName,\n            key: 'eventName',\n            type: getType(eventName),\n            correctType: 'string',\n          }),\n        );\n\n        throw new TypeError('TypeError: Event-name should be a string');\n      }\n\n      // Validate eventProperties is an object\n      if (!isObject(eventProperties)) {\n        LogManager.Instance.error(\n          buildMessage(ErrorLogMessagesEnum.API_INVALID_PARAM, {\n            apiName,\n            key: 'eventProperties',\n            type: getType(eventProperties),\n            correctType: 'object',\n          }),\n        );\n\n        throw new TypeError('TypeError: eventProperties should be an object');\n      }\n\n      // Validate settings are loaded and valid\n      if (!new SettingsSchema().isSettingsValid(this.originalSettings)) {\n        LogManager.Instance.error(ErrorLogMessagesEnum.API_SETTING_INVALID);\n        throw new Error('TypeError: Invalid Settings');\n      }\n\n      // Validate user ID is present in context\n      if (!context || !context.id) {\n        LogManager.Instance.error(ErrorLogMessagesEnum.API_CONTEXT_INVALID);\n        throw new TypeError('TypeError: Invalid context');\n      }\n\n      const contextModel = new ContextModel().modelFromDictionary(context);\n\n      // Proceed with tracking the event\n      new TrackApi()\n        .track(this.settings, eventName, contextModel, eventProperties, hooksService)\n        .then((data) => {\n          deferredObject.resolve(data);\n        })\n        .catch(() => {\n          deferredObject.resolve({ [eventName]: false });\n        });\n    } catch (err) {\n      // Log any errors encountered during the operation\n      LogManager.Instance.info(\n        buildMessage(ErrorLogMessagesEnum.API_THROW_ERROR, {\n          apiName,\n          err,\n        }),\n      );\n\n      deferredObject.resolve({ [eventName]: false });\n    }\n\n    return deferredObject.promise;\n  }\n\n  /**\n   * Sets an attribute for a user in the context provided.\n   * This method validates the types of the inputs before proceeding with the API call.\n   *\n   * @param {string} attributeKey - The key of the attribute to set.\n   * @param {string} attributeValue - The value of the attribute to set.\n   * @param {ContextModel} context - The context in which the attribute should be set, must include a valid user ID.\n   */\n  async setAttribute(\n    attributeKey: string,\n    attributeValue: boolean | string | number,\n    context: Record<string, any>,\n  ): Promise<void> {\n    const apiName = 'setAttribute';\n\n    try {\n      // Log the API call\n      LogManager.Instance.debug(\n        buildMessage(DebugLogMessagesEnum.API_CALLED, {\n          apiName,\n        }),\n      );\n\n      // Validate attributeKey is a string\n      if (!isString(attributeKey)) {\n        LogManager.Instance.error(\n          buildMessage(ErrorLogMessagesEnum.API_INVALID_PARAM, {\n            apiName,\n            key: 'attributeKey',\n            type: getType(attributeKey),\n            correctType: 'string',\n          }),\n        );\n\n        throw new TypeError('TypeError: attributeKey should be a string');\n      }\n      // Validate attributeValue is a string\n      if (!isString(attributeValue) && !isNumber(attributeValue) && !isBoolean(attributeValue)) {\n        LogManager.Instance.error(\n          buildMessage(ErrorLogMessagesEnum.API_INVALID_PARAM, {\n            apiName,\n            key: 'attributeValue',\n            type: getType(attributeValue),\n            correctType: 'boolean | string | number',\n          }),\n        );\n\n        throw new TypeError('TypeError: attributeValue should be a string');\n      }\n\n      // Validate user ID is present in context\n      if (!context || !context.id) {\n        LogManager.Instance.error(ErrorLogMessagesEnum.API_CONTEXT_INVALID);\n        throw new TypeError('TypeError: Invalid context');\n      }\n\n      const contextModel = new ContextModel().modelFromDictionary(context);\n\n      // Proceed with setting the attribute if validation is successful\n      await new SetAttributeApi().setAttribute(this.settings, attributeKey, attributeValue, contextModel);\n    } catch (err) {\n      // Log any errors encountered during the operation\n      LogManager.Instance.info(\n        buildMessage(ErrorLogMessagesEnum.API_THROW_ERROR, {\n          apiName,\n          err,\n        }),\n      );\n    }\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FeatureModel } from '../models/campaign/FeatureModel';\nimport { SettingsModel } from '../models/settings/SettingsModel';\n\nimport { StorageDecorator } from '../decorators/StorageDecorator';\nimport { ApiEnum } from '../enums/ApiEnum';\nimport { CampaignTypeEnum } from '../enums/CampaignTypeEnum';\nimport { DebugLogMessagesEnum, ErrorLogMessagesEnum, InfoLogMessagesEnum } from '../enums/log-messages';\nimport { CampaignModel } from '../models/campaign/CampaignModel';\nimport { VariableModel } from '../models/campaign/VariableModel';\nimport { VariationModel } from '../models/campaign/VariationModel';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { LogManager } from '../packages/logger';\nimport { SegmentationManager } from '../packages/segmentation-evaluator';\nimport IHooksService from '../services/HooksService';\nimport { StorageService } from '../services/StorageService';\nimport { getVariationFromCampaignKey } from '../utils/CampaignUtil';\nimport { isObject } from '../utils/DataTypeUtil';\nimport { evaluateTrafficAndGetVariation } from '../utils/DecisionUtil';\nimport { getAllExperimentRules, getFeatureFromKey, getSpecificRulesBasedOnType } from '../utils/FunctionUtil';\nimport { createAndSendImpressionForVariationShown } from '../utils/ImpressionUtil';\nimport { buildMessage } from '../utils/LogMessageUtil';\nimport { Deferred } from '../utils/PromiseUtil';\nimport { evaluateRule } from '../utils/RuleEvaluationUtil';\nimport { getShouldWaitForTrackingCalls } from '../utils/NetworkUtil';\n\ninterface IGetFlag {\n  get(\n    featureKey: string,\n    settings: SettingsModel,\n    context: ContextModel,\n    hooksService: IHooksService,\n  ): Promise<FeatureModel>;\n}\n\nexport class FlagApi implements IGetFlag {\n  async get(\n    featureKey: string,\n    settings: SettingsModel,\n    context: ContextModel,\n    hooksService: IHooksService,\n  ): Promise<FeatureModel> {\n    let isEnabled = false;\n    let rolloutVariationToReturn = null;\n    let experimentVariationToReturn = null;\n    let shouldCheckForExperimentsRules = false;\n\n    const passedRulesInformation = {}; // for storing and integration callback\n    const deferredObject = new Deferred();\n    const evaluatedFeatureMap: Map<string, any> = new Map();\n\n    // get feature object from feature key\n    const feature = getFeatureFromKey(settings, featureKey);\n    const decision = {\n      featureName: feature?.getName(),\n      featureId: feature?.getId(),\n      featureKey: feature?.getKey(),\n      userId: context?.getId(),\n      api: ApiEnum.GET_FLAG,\n    };\n\n    const storageService = new StorageService();\n    const storedData: Record<any, any> = await new StorageDecorator().getFeatureFromStorage(\n      featureKey,\n      context,\n      storageService,\n    );\n\n    if (storedData?.experimentVariationId) {\n      if (storedData.experimentKey) {\n        const variation: VariationModel = getVariationFromCampaignKey(\n          settings,\n          storedData.experimentKey,\n          storedData.experimentVariationId,\n        );\n\n        if (variation) {\n          LogManager.Instance.info(\n            buildMessage(InfoLogMessagesEnum.STORED_VARIATION_FOUND, {\n              variationKey: variation.getKey(),\n              userId: context.getId(),\n              experimentType: 'experiment',\n              experimentKey: storedData.experimentKey,\n            }),\n          );\n          deferredObject.resolve({\n            isEnabled: () => true,\n            getVariables: () => variation?.getVariables(),\n            getVariable: (\n              key: string,\n              defaultValue: string, // loop over all variables object and return the value where key is equal to given key else return given default value\n            ) =>\n              variation\n                ?.getVariables()\n                .find((variable) => new VariableModel().modelFromDictionary(variable).getKey() === key)\n                ?.getValue() || defaultValue,\n          });\n\n          return deferredObject.promise;\n        }\n      }\n    } else if (storedData?.rolloutKey && storedData?.rolloutId) {\n      const variation: VariationModel = getVariationFromCampaignKey(\n        settings,\n        storedData.rolloutKey,\n        storedData.rolloutVariationId,\n      );\n      if (variation) {\n        LogManager.Instance.info(\n          buildMessage(InfoLogMessagesEnum.STORED_VARIATION_FOUND, {\n            variationKey: variation.getKey(),\n            userId: context.getId(),\n            experimentType: 'rollout',\n            experimentKey: storedData.rolloutKey,\n          }),\n        );\n\n        LogManager.Instance.debug(\n          buildMessage(DebugLogMessagesEnum.EXPERIMENTS_EVALUATION_WHEN_ROLLOUT_PASSED, {\n            userId: context.getId(),\n          }),\n        );\n\n        isEnabled = true;\n        shouldCheckForExperimentsRules = true;\n        rolloutVariationToReturn = variation;\n        const featureInfo = {\n          rolloutId: storedData.rolloutId,\n          rolloutKey: storedData.rolloutKey,\n          rolloutVariationId: storedData.rolloutVariationId,\n        };\n        evaluatedFeatureMap.set(featureKey, featureInfo);\n        Object.assign(passedRulesInformation, featureInfo);\n      }\n    }\n\n    if (!isObject(feature) || feature === undefined) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.FEATURE_NOT_FOUND, {\n          featureKey,\n        }),\n      );\n\n      deferredObject.reject({});\n\n      return deferredObject.promise;\n    }\n\n    // TODO: remove await from here, need not wait for gateway service at the time of calling getFlag\n    await SegmentationManager.Instance.setContextualData(settings, feature, context);\n\n    const rollOutRules = getSpecificRulesBasedOnType(feature, CampaignTypeEnum.ROLLOUT); // get all rollout rules\n\n    if (rollOutRules.length > 0 && !isEnabled) {\n      const rolloutRulesToEvaluate = [];\n\n      for (const rule of rollOutRules) {\n        const { preSegmentationResult, updatedDecision } = await evaluateRule(\n          settings,\n          feature,\n          rule,\n          context,\n          evaluatedFeatureMap,\n          null,\n          storageService,\n          decision,\n        );\n\n        Object.assign(decision, updatedDecision);\n\n        if (preSegmentationResult) {\n          // if pre segment passed, then break the loop and check the traffic allocation\n          rolloutRulesToEvaluate.push(rule);\n\n          evaluatedFeatureMap.set(featureKey, {\n            rolloutId: rule.getId(),\n            rolloutKey: rule.getKey(),\n            rolloutVariationId: rule.getVariations()[0]?.getId(),\n          });\n\n          break;\n        }\n\n        continue; // if rule does not satisfy, then check for other ROLLOUT rules\n      }\n\n      if (rolloutRulesToEvaluate.length > 0) {\n        const passedRolloutCampaign = new CampaignModel().modelFromDictionary(rolloutRulesToEvaluate[0]);\n        const variation = evaluateTrafficAndGetVariation(settings, passedRolloutCampaign, context.getId());\n\n        if (isObject(variation) && Object.keys(variation).length > 0) {\n          isEnabled = true;\n          shouldCheckForExperimentsRules = true;\n          rolloutVariationToReturn = variation;\n\n          _updateIntegrationsDecisionObject(passedRolloutCampaign, variation, passedRulesInformation, decision);\n\n          if (getShouldWaitForTrackingCalls()) {\n            await createAndSendImpressionForVariationShown(\n              settings,\n              passedRolloutCampaign.getId(),\n              variation.getId(),\n              context,\n            );\n          } else {\n            createAndSendImpressionForVariationShown(\n              settings,\n              passedRolloutCampaign.getId(),\n              variation.getId(),\n              context,\n            );\n          }\n        }\n      }\n    } else if (rollOutRules.length === 0) {\n      LogManager.Instance.debug(DebugLogMessagesEnum.EXPERIMENTS_EVALUATION_WHEN_NO_ROLLOUT_PRESENT);\n      shouldCheckForExperimentsRules = true;\n    }\n\n    if (shouldCheckForExperimentsRules) {\n      const experimentRulesToEvaluate = [];\n\n      // if rollout rule is passed, get all ab and Personalize rules\n      const experimentRules = getAllExperimentRules(feature);\n      const megGroupWinnerCampaigns: Map<number, number> = new Map();\n\n      for (const rule of experimentRules) {\n        const { preSegmentationResult, whitelistedObject, updatedDecision } = await evaluateRule(\n          settings,\n          feature,\n          rule,\n          context,\n          evaluatedFeatureMap,\n          megGroupWinnerCampaigns,\n          storageService,\n          decision,\n        );\n\n        Object.assign(decision, updatedDecision);\n\n        if (preSegmentationResult) {\n          if (whitelistedObject === null) {\n            // whitelistedObject will be null if pre segment passed but whitelisting failed\n            experimentRulesToEvaluate.push(rule);\n          } else {\n            isEnabled = true;\n            experimentVariationToReturn = whitelistedObject.variation;\n            Object.assign(passedRulesInformation, {\n              experimentId: rule.getId(),\n              experimentKey: rule.getKey(),\n              experimentVariationId: whitelistedObject.variationId,\n            });\n          }\n\n          break;\n        }\n        continue;\n      }\n\n      if (experimentRulesToEvaluate.length > 0) {\n        const campaign = new CampaignModel().modelFromDictionary(experimentRulesToEvaluate[0]);\n        const variation = evaluateTrafficAndGetVariation(settings, campaign, context.getId());\n\n        if (isObject(variation) && Object.keys(variation).length > 0) {\n          isEnabled = true;\n          experimentVariationToReturn = variation;\n\n          _updateIntegrationsDecisionObject(campaign, variation, passedRulesInformation, decision);\n          if (getShouldWaitForTrackingCalls()) {\n            await createAndSendImpressionForVariationShown(settings, campaign.getId(), variation.getId(), context);\n          } else {\n            createAndSendImpressionForVariationShown(settings, campaign.getId(), variation.getId(), context);\n          }\n        }\n      }\n    }\n\n    // If flag is enabled, store it in data\n    if (isEnabled) {\n      // set storage data\n      new StorageDecorator().setDataInStorage(\n        {\n          featureKey,\n          context,\n          ...passedRulesInformation,\n        },\n        storageService,\n      );\n    }\n\n    // call integration callback, if defined\n    hooksService.set(decision);\n    hooksService.execute(hooksService.get());\n\n    // Send data for Impact Campaign, if defined\n    if (feature.getImpactCampaign()?.getCampaignId()) {\n      LogManager.Instance.info(\n        buildMessage(InfoLogMessagesEnum.IMPACT_ANALYSIS, {\n          userId: context.getId(),\n          featureKey,\n          status: isEnabled ? 'enabled' : 'disabled',\n        }),\n      );\n      if (getShouldWaitForTrackingCalls()) {\n        await createAndSendImpressionForVariationShown(\n          settings,\n          feature.getImpactCampaign()?.getCampaignId(),\n          isEnabled ? 2 : 1, // 2 is for Variation(flag enabled), 1 is for Control(flag disabled)\n          context,\n        );\n      } else {\n        createAndSendImpressionForVariationShown(\n          settings,\n          feature.getImpactCampaign()?.getCampaignId(),\n          isEnabled ? 2 : 1, // 2 is for Variation(flag enabled), 1 is for Control(flag disabled)\n          context,\n        );\n      }\n    }\n\n    const variablesForEvaluatedFlag =\n      experimentVariationToReturn?.variables ?? rolloutVariationToReturn?.variables ?? [];\n\n    deferredObject.resolve({\n      isEnabled: () => isEnabled,\n      getVariables: () => variablesForEvaluatedFlag,\n      getVariable: (\n        key: string,\n        defaultValue: string, // loop over all variables object and return the value where key is equal to given key else return given default value\n      ) => {\n        const variable = variablesForEvaluatedFlag.find((variable) => variable.key === key);\n\n        return variable?.value ?? defaultValue;\n      },\n    });\n\n    return deferredObject.promise;\n  }\n}\n\n// Not PRIVATE methods but helper methods. If need be, move them to some util file to be reused by other API(s)\n\nfunction _updateIntegrationsDecisionObject(\n  campaign: CampaignModel,\n  variation: VariationModel,\n  passedRulesInformation: any,\n  decision: any,\n): void {\n  if (campaign.getType() === CampaignTypeEnum.ROLLOUT) {\n    Object.assign(passedRulesInformation, {\n      rolloutId: campaign.getId(),\n      rolloutKey: campaign.getKey(),\n      rolloutVariationId: variation.getId(),\n    });\n  } else {\n    Object.assign(passedRulesInformation, {\n      experimentId: campaign.getId(),\n      experimentKey: campaign.getKey(),\n      experimentVariationId: variation.getId(),\n    });\n  }\n  Object.assign(decision, passedRulesInformation);\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ContextModel } from '../models/user/ContextModel';\nimport { EventEnum } from '../enums/EventEnum';\nimport {\n  getEventsBaseProperties,\n  getAttributePayloadData,\n  sendPostApiRequest,\n  getShouldWaitForTrackingCalls,\n} from '../utils/NetworkUtil';\nimport { SettingsModel } from '../models/settings/SettingsModel';\n\ninterface ISetAttribute {\n  /**\n   * Sets an attribute for a user.\n   * @param settings Configuration settings.\n   * @param attributeKey The key of the attribute to set.\n   * @param attributeValue The value of the attribute.\n   * @param context Context containing user information.\n   */\n  setAttribute(\n    settings: SettingsModel,\n    attributeKey: string,\n    attributeValue: any,\n    context: ContextModel,\n  ): Promise<void>;\n}\n\nexport class SetAttributeApi implements ISetAttribute {\n  /**\n   * Implementation of setAttribute to create an impression for a user attribute.\n   * @param settings Configuration settings.\n   * @param attributeKey The key of the attribute to set.\n   * @param attributeValue The value of the attribute.\n   * @param context Context containing user information.\n   */\n  async setAttribute(\n    settings: SettingsModel,\n    attributeKey: string,\n    attributeValue: any,\n    context: ContextModel,\n  ): Promise<void> {\n    if (getShouldWaitForTrackingCalls()) {\n      await createImpressionForAttribute(settings, attributeKey, attributeValue, context);\n    } else {\n      createImpressionForAttribute(settings, attributeKey, attributeValue, context);\n    }\n  }\n}\n\n/**\n * Creates an impression for a user attribute and sends it to the server.\n * @param settings Configuration settings.\n * @param attributeKey The key of the attribute.\n * @param attributeValue The value of the attribute.\n * @param user User details.\n */\nconst createImpressionForAttribute = async (\n  settings: SettingsModel,\n  attributeKey: string,\n  attributeValue: any,\n  context: ContextModel,\n) => {\n  // Retrieve base properties for the event\n  const properties = getEventsBaseProperties(\n    settings,\n    EventEnum.VWO_SYNC_VISITOR_PROP,\n    encodeURIComponent(context.getUserAgent()),\n    context.getIpAddress(),\n  );\n  // Construct payload data for the attribute\n  const payload = getAttributePayloadData(\n    settings,\n    context.getId(),\n    EventEnum.VWO_SYNC_VISITOR_PROP,\n    attributeKey,\n    attributeValue,\n    context.getUserAgent(),\n    context.getIpAddress(),\n  );\n\n  // Send the constructed payload via POST request\n  await sendPostApiRequest(properties, payload);\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ApiEnum } from '../enums/ApiEnum';\nimport { ErrorLogMessagesEnum } from '../enums/log-messages';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { LogManager } from '../packages/logger';\nimport IHooksService from '../services/HooksService';\nimport { dynamic } from '../types/Common';\nimport { doesEventBelongToAnyFeature } from '../utils/FunctionUtil';\nimport { buildMessage } from '../utils/LogMessageUtil';\nimport {\n  getEventsBaseProperties,\n  getTrackGoalPayloadData,\n  sendPostApiRequest,\n  getShouldWaitForTrackingCalls,\n} from '../utils/NetworkUtil';\n\ninterface ITrack {\n  /**\n   * Tracks an event with given properties and context.\n   * @param settings Configuration settings for the tracking.\n   * @param eventName Name of the event to track.\n   * @param context Contextual information like user details.\n   * @param eventProperties Properties associated with the event.\n   * @param hooksService Manager for handling hooks and callbacks.\n   * @returns A promise that resolves to a record indicating the success or failure of the event tracking.\n   */\n  track(\n    settings: SettingsModel,\n    eventName: string,\n    context: ContextModel,\n    eventProperties: Record<string, dynamic>,\n    hooksService: IHooksService,\n  ): Promise<Record<string, boolean>>;\n}\n\nexport class TrackApi implements ITrack {\n  /**\n   * Implementation of the track method to handle event tracking.\n   * Checks if the event exists, creates an impression, and executes hooks.\n   */\n  async track(\n    settings: SettingsModel,\n    eventName: string,\n    context: ContextModel,\n    eventProperties: any,\n    hooksService: IHooksService,\n  ): Promise<Record<string, boolean>> {\n    if (doesEventBelongToAnyFeature(eventName, settings)) {\n      // Create an impression for the track event\n      if (getShouldWaitForTrackingCalls()) {\n        await createImpressionForTrack(settings, eventName, context, eventProperties);\n      } else {\n        createImpressionForTrack(settings, eventName, context, eventProperties);\n      }\n      // Set and execute integration callback for the track event\n      hooksService.set({ eventName: eventName, api: ApiEnum.TRACK });\n      hooksService.execute(hooksService.get());\n\n      return { [eventName]: true };\n    }\n    // Log an error if the event does not exist\n    LogManager.Instance.error(\n      buildMessage(ErrorLogMessagesEnum.EVENT_NOT_FOUND, {\n        eventName,\n      }),\n    );\n\n    return { [eventName]: false };\n  }\n}\n\n/**\n * Creates an impression for a track event and sends it via a POST API request.\n * @param settings Configuration settings for the tracking.\n * @param eventName Name of the event to track.\n * @param user User details.\n * @param eventProperties Properties associated with the event.\n */\nconst createImpressionForTrack = async (\n  settings: SettingsModel,\n  eventName: string,\n  context: ContextModel,\n  eventProperties: any,\n) => {\n  // Get base properties for the event\n  const properties = getEventsBaseProperties(\n    settings,\n    eventName,\n    encodeURIComponent(context.getUserAgent()),\n    context.getIpAddress(),\n  );\n  // Prepare the payload for the track goal\n  const payload = getTrackGoalPayloadData(\n    settings,\n    context.getId(),\n    eventName,\n    eventProperties,\n    context?.getUserAgent(),\n    context?.getIpAddress(),\n  );\n  // Send the prepared payload via POST API request\n  await sendPostApiRequest(properties, payload);\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const HTTP = 'http';\nexport const HTTPS = 'https';\n\nexport const SEED_URL = 'https://vwo.com';\nexport const HTTP_PROTOCOL = `${HTTP}://`;\nexport const HTTPS_PROTOCOL = `${HTTPS}://`;\nexport const BASE_URL = 'dev.visualwebsiteoptimizer.com';\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* global SDK_VERSION */\nimport { PlatformEnum } from '../enums/PlatformEnum';\nimport { SEED_URL, HTTP_PROTOCOL, HTTPS_PROTOCOL } from './Url';\n\nlet packageFile;\nlet platform;\n\n// For client-side SDK, to keep the build size low\n// avoid adding the whole package file in the bundle\nif (typeof process.env === 'undefined') {\n  packageFile = {\n    name: 'vwo-fme-javascript-sdk', // will be replaced by webpack for browser build\n    // @ts-expect-error This will be relaved by webpack at the time of build for browser\n    version: SDK_VERSION, // will be replaced by webpack for browser build\n  };\n\n  platform = PlatformEnum.CLIENT;\n} else {\n  packageFile = require('../../package.json');\n  platform = PlatformEnum.SERVER;\n}\n\nexport const Constants = {\n  SDK_NAME: packageFile.name,\n  SDK_VERSION: packageFile.version,\n\n  PLATFORM: platform,\n\n  MAX_TRAFFIC_PERCENT: 100,\n  MAX_TRAFFIC_VALUE: 10000,\n  STATUS_RUNNING: 'RUNNING',\n\n  SEED_VALUE: 1,\n  MAX_EVENTS_PER_REQUEST: 5000,\n  DEFAULT_REQUEST_TIME_INTERVAL: 600, // 10 * 60(secs) = 600 secs i.e. 10 minutes\n  DEFAULT_EVENTS_PER_REQUEST: 100,\n\n  SEED_URL,\n  HTTP_PROTOCOL,\n  HTTPS_PROTOCOL,\n\n  SETTINGS: 'settings',\n  SETTINGS_EXPIRY: 10000000,\n  SETTINGS_TIMEOUT: 50000,\n\n  HOST_NAME: 'dev.visualwebsiteoptimizer.com',\n  SETTINTS_ENDPOINT: '/server-side/v2-settings',\n  LOCATION_ENDPOINT: '/getLocation',\n\n  VWO_FS_ENVIRONMENT: 'vwo_fs_environment',\n\n  RANDOM_ALGO: 1,\n\n  API_VERSION: '1',\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LogManager } from '../packages/logger';\n\nimport { StorageEnum } from '../enums/StorageEnum';\nimport { FeatureModel } from '../models/campaign/FeatureModel';\nimport { VariationModel } from '../models/campaign/VariationModel';\nimport { IStorageService } from '../services/StorageService';\n\nimport { ErrorLogMessagesEnum } from '../enums/log-messages';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { buildMessage } from '../utils/LogMessageUtil';\nimport { Deferred } from '../utils/PromiseUtil';\n\ninterface IStorageDecorator {\n  /**\n   * Sets data in storage.\n   * @param data The data to be stored.\n   * @param storageService The storage service instance.\n   * @returns A promise that resolves to a VariationModel.\n   */\n  setDataInStorage(data: Record<any, any>, storageService: IStorageService): Promise<VariationModel>;\n\n  /**\n   * Retrieves a feature from storage.\n   * @param featureKey The key of the feature to retrieve.\n   * @param user The user object.\n   * @param storageService The storage service instance.\n   * @returns A promise that resolves to the retrieved feature or relevant status.\n   */\n  getFeatureFromStorage(featureKey: FeatureModel, context: ContextModel, storageService: IStorageService): Promise<any>;\n}\n\nexport class StorageDecorator implements IStorageDecorator {\n  /**\n   * Asynchronously retrieves a feature from storage based on the feature key and user.\n   * @param featureKey The key of the feature to retrieve.\n   * @param user The user object.\n   * @param storageService The storage service instance.\n   * @returns A promise that resolves to the retrieved feature or relevant status.\n   */\n  async getFeatureFromStorage(featureKey: any, context: ContextModel, storageService: IStorageService): Promise<any> {\n    const deferredObject = new Deferred();\n    storageService.getDataInStorage(featureKey, context).then((campaignMap: Record<any, any> | StorageEnum) => {\n      switch (campaignMap) {\n        case StorageEnum.STORAGE_UNDEFINED:\n          deferredObject.resolve(null); // No storage defined\n          break;\n        case StorageEnum.NO_DATA_FOUND:\n          deferredObject.resolve(null); // No data found in storage\n          break;\n        case StorageEnum.INCORRECT_DATA:\n          deferredObject.resolve(StorageEnum.INCORRECT_DATA); // Incorrect data found\n          break;\n        case StorageEnum.CAMPAIGN_PAUSED:\n          deferredObject.resolve(null); // Campaign is paused\n          break;\n        case StorageEnum.VARIATION_NOT_FOUND:\n          deferredObject.resolve(StorageEnum.VARIATION_NOT_FOUND); // No variation found\n          break;\n        case StorageEnum.WHITELISTED_VARIATION:\n          deferredObject.resolve(null); // Whitelisted variation, handle accordingly\n          break;\n        default:\n          deferredObject.resolve(campaignMap); // Valid data found, resolve with it\n      }\n    });\n\n    return deferredObject.promise;\n  }\n\n  /**\n   * Sets data in storage based on the provided data object.\n   * @param data The data to be stored, including feature key and user details.\n   * @param storageService The storage service instance.\n   * @returns A promise that resolves when the data is successfully stored.\n   */\n  setDataInStorage(data: Record<any, any>, storageService: IStorageService): Promise<VariationModel> {\n    const deferredObject = new Deferred();\n    const {\n      featureKey,\n      context,\n      rolloutId,\n      rolloutKey,\n      rolloutVariationId,\n      experimentId,\n      experimentKey,\n      experimentVariationId,\n    } = data;\n\n    if (!featureKey) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n          key: 'featureKey',\n        }),\n      );\n\n      deferredObject.reject(); // Reject promise if feature key is invalid\n      return;\n    }\n    if (!context.id) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n          key: 'Context or Context.id',\n        }),\n      );\n\n      deferredObject.reject(); // Reject promise if user ID is invalid\n      return;\n    }\n    if (rolloutKey && !experimentKey && !rolloutVariationId) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n          key: 'Variation:(rolloutKey, experimentKey or rolloutVariationId)',\n        }),\n      );\n\n      deferredObject.reject(); // Reject promise if rollout variation is invalid\n      return;\n    }\n    if (experimentKey && !experimentVariationId) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.STORING_DATA_ERROR, {\n          key: 'Variation:(experimentKey or rolloutVariationId)',\n        }),\n      );\n\n      deferredObject.reject(); // Reject promise if experiment variation is invalid\n      return;\n    }\n\n    storageService.setDataInStorage({\n      featureKey,\n      userId: context.id,\n      rolloutId,\n      rolloutKey,\n      rolloutVariationId,\n      experimentId,\n      experimentKey,\n      experimentVariationId,\n    });\n\n    deferredObject.resolve(); // Resolve promise when data is successfully set\n\n    return deferredObject.promise;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum ApiEnum {\n  GET_FLAG = 'getFlag',\n  TRACK = 'track',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum CampaignTypeEnum {\n  ROLLOUT = 'FLAG_ROLLOUT',\n  AB = 'FLAG_TESTING',\n  PERSONALIZE = 'FLAG_PERSONALIZE',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum EventEnum {\n  VWO_VARIATION_SHOWN = 'vwo_variationShown',\n  VWO_SYNC_VISITOR_PROP = 'vwo_syncVisitorProp',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum HeadersEnum {\n  USER_AGENT = 'X-Device-User-Agent',\n  IP = 'VWO-X-Forwarded-For',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum HttpMethodEnum {\n  GET = 'GET',\n  POST = 'POST',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum PlatformEnum {\n  CLIENT = 'client',\n  SERVER = 'server',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum StatusEnum {\n  PASSED = 'passed',\n  FAILED = 'failed',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum StorageEnum {\n  STORAGE_UNDEFINED,\n  INCORRECT_DATA,\n  NO_DATA_FOUND,\n  CAMPAIGN_PAUSED,\n  VARIATION_NOT_FOUND,\n  WHITELISTED_VARIATION,\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum UrlEnum {\n  BASE_URL = 'dev.visualwebsiteoptimizer.com',\n  SETTINGS_URL = '/server-side/settings',\n  // WEBHOOK_SETTINGS_URL = '/server-side/pull',\n  // BATCH_EVENTS = '/server-side/batch-events',\n  EVENTS = '/events/t',\n  ATTRIBUTE_CHECK = '/check-attribute',\n  GET_USER_DATA = '/get-user-details',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as messages from 'vwo-fme-sdk-log-messages';\n\nconst DebugLogMessagesEnum = messages.debugMessages;\nconst InfoLogMessagesEnum = messages.infoMessages;\nconst ErrorLogMessagesEnum = messages.errorMessages;\n\nexport { DebugLogMessagesEnum, InfoLogMessagesEnum, ErrorLogMessagesEnum };\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../types/Common';\nimport { MetricModel } from './MetricModel';\nimport { VariableModel } from './VariableModel';\nimport { VariationModel } from './VariationModel';\n\nexport class CampaignModel {\n  private id: number;\n  private segments: Record<string, dynamic>;\n  private percentTraffic: number;\n  private isUserListEnabled: boolean;\n  private key: string;\n  private type: string;\n  private name: string;\n  private isForcedVariationEnabled: boolean;\n  private variations: Array<VariationModel> = [];\n  private metrics: Array<MetricModel> = [];\n  private variables: Array<VariableModel> = [];\n  private variationId: number;\n  private campaignId: number;\n  private ruleKey: string;\n\n  copy(campaignModel: CampaignModel): void {\n    this.metrics = campaignModel.metrics;\n    this.variations = campaignModel.variations;\n    this.variables = campaignModel.variables;\n    this.processCampaignKeys(campaignModel);\n  }\n\n  modelFromDictionary(campaign: CampaignModel): this {\n    this.processCampaignProperties(campaign);\n    this.processCampaignKeys(campaign);\n    return this;\n  }\n\n  processCampaignProperties(campaign: CampaignModel): void {\n    if (campaign.variables) {\n      // campaign.var ||\n      if (\n        // (campaign.var && campaign.var.constructor === {}.constructor) ||\n        campaign.variables.constructor === {}.constructor\n      ) {\n        this.variables = [];\n      } else {\n        const variableList: Array<VariableModel> = campaign.variables; // campaign.var ||\n        variableList.forEach((variable: any) => {\n          this.variables.push(new VariableModel().modelFromDictionary(variable));\n        });\n      }\n    }\n\n    if (campaign.variations) {\n      // campaign.v ||\n      if (\n        // (campaign.v && campaign.v.constructor === {}.constructor) ||\n        campaign.variations.constructor === {}.constructor\n      ) {\n        this.variations = [];\n      } else {\n        const variationList: Array<VariationModel> = campaign.variations; // campaign.v ||\n        variationList.forEach((variation: any) => {\n          this.variations.push(new VariationModel().modelFromDictionary(variation));\n        });\n      }\n    }\n\n    if (campaign.metrics) {\n      // campaign.m ||\n      if (campaign.metrics && campaign.metrics.constructor === {}.constructor) {\n        this.metrics = [];\n      } else {\n        const metricsList: Array<MetricModel> = campaign.metrics || [];\n        metricsList.forEach((metric: any) => {\n          this.metrics.push(new MetricModel().modelFromDictionary(metric));\n        });\n      }\n    }\n  }\n\n  processCampaignKeys(campaign: CampaignModel): void {\n    this.id = campaign.id;\n    this.percentTraffic = campaign.percentTraffic; // campaign.pT ||\n    this.name = campaign.name; // campaign.n ||\n    this.variationId = campaign.variationId; // campaign.vId ||\n    this.campaignId = campaign.campaignId; // campaign.cId ||\n    this.ruleKey = campaign.ruleKey; // campaign.rK ||\n    this.isForcedVariationEnabled = campaign.isForcedVariationEnabled; // campaign.iFVE ||\n    this.isUserListEnabled = campaign.isUserListEnabled; // campaign.iULE ||\n    this.segments = campaign.segments;\n    this.key = campaign.key; // campaign.k ||\n    // this.priority = campaign.pr || campaign.priority;\n    this.type = campaign.type; // campaign.t ||\n  }\n\n  getId(): number {\n    return this.id;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getSegments(): Record<string, dynamic> {\n    return this.segments;\n  }\n\n  getTraffic(): number {\n    return this.percentTraffic;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n\n  getIsForcedVariationEnabled(): boolean {\n    return this.isForcedVariationEnabled;\n  }\n\n  getIsUserListEnabled(): boolean {\n    return this.isUserListEnabled;\n  }\n\n  getKey(): string {\n    return this.key;\n  }\n\n  getMetrics(): Array<MetricModel> {\n    return this.metrics;\n  }\n\n  getVariations(): Array<VariationModel> {\n    return this.variations;\n  }\n\n  getVariables(): Array<VariableModel> {\n    return this.variables;\n  }\n\n  getRuleKey(): string {\n    return this.ruleKey;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CampaignModel } from './CampaignModel';\nimport { ImpactCapmaignModel } from './ImpactCampaignModel';\nimport { MetricModel } from './MetricModel';\nimport { RuleModel } from './RuleModel';\n\nexport class FeatureModel {\n  private m: Array<MetricModel> = [];\n  private metrics: Array<MetricModel> = [];\n  private id: number;\n  private key: string;\n  private name: string;\n  private type: string;\n  private rules: Array<RuleModel> = [];\n  private impactCampaign: ImpactCapmaignModel = null;\n\n  private rulesLinkedCampaign: Array<CampaignModel> = [];\n  private isGatewayServiceRequired: boolean = false;\n\n  modelFromDictionary(feature: FeatureModel): this {\n    this.id = feature.id;\n    this.key = feature.key;\n    this.name = feature.name;\n    this.type = feature.type;\n    if (feature?.isGatewayServiceRequired) {\n      this.isGatewayServiceRequired = feature.isGatewayServiceRequired;\n    }\n    if (feature.impactCampaign) {\n      this.impactCampaign = new ImpactCapmaignModel().modelFromDictionary(feature.impactCampaign);\n    }\n\n    if ((feature.m && feature.m.constructor === {}.constructor) || feature.metrics?.constructor === {}.constructor) {\n      this.metrics = [];\n    } else {\n      const metricList: Array<MetricModel> = feature.m || feature.metrics;\n      metricList?.forEach((metric) => {\n        this.metrics.push(new MetricModel().modelFromDictionary(metric));\n      });\n    }\n\n    if (feature?.rules?.constructor === {}.constructor) {\n      this.rules = [];\n    } else {\n      const ruleList: Array<RuleModel> = feature.rules;\n      ruleList?.forEach((rule) => {\n        this.rules.push(new RuleModel().modelFromDictionary(rule));\n      });\n    }\n\n    if (feature?.rulesLinkedCampaign && feature.rulesLinkedCampaign?.constructor !== {}.constructor) {\n      const linkedCampaignList: Array<CampaignModel> = feature.rulesLinkedCampaign;\n      this.rulesLinkedCampaign = linkedCampaignList;\n    }\n\n    return this;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n\n  getId(): number {\n    return this.id;\n  }\n\n  getKey(): string {\n    return this.key;\n  }\n\n  getRules(): Array<RuleModel> {\n    return this.rules;\n  }\n\n  getImpactCampaign(): ImpactCapmaignModel {\n    return this.impactCampaign;\n  }\n\n  getRulesLinkedCampaign(): Array<CampaignModel> {\n    return this.rulesLinkedCampaign;\n  }\n\n  setRulesLinkedCampaign(rulesLinkedCampaign: Array<CampaignModel>): void {\n    this.rulesLinkedCampaign = rulesLinkedCampaign;\n  }\n\n  getMetrics(): Array<MetricModel> {\n    return this.metrics;\n  }\n\n  getIsGatewayServiceRequired(): boolean {\n    return this.isGatewayServiceRequired;\n  }\n\n  setIsGatewayServiceRequired(isGatewayServiceRequired: boolean): void {\n    this.isGatewayServiceRequired = isGatewayServiceRequired;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class ImpactCapmaignModel {\n  private campaignId: number;\n  private type: string;\n\n  modelFromDictionary(impactCampaign: ImpactCapmaignModel): this {\n    this.type = impactCampaign.type;\n    this.campaignId = impactCampaign.campaignId;\n    return this;\n  }\n\n  getCampaignId(): number {\n    return this.campaignId;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class MetricModel {\n  private key: string;\n  private identifier: string;\n\n  private i: number;\n  private id: number;\n\n  private t: string;\n  private type: string;\n\n  modelFromDictionary(metric: MetricModel): this {\n    this.identifier = metric.identifier || metric.key;\n    this.id = metric.i || metric.id;\n    this.type = metric.t || metric.type;\n    return this;\n  }\n\n  getId(): number {\n    return this.id;\n  }\n\n  getIdentifier(): string {\n    return this.identifier;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class RuleModel {\n  private status: boolean;\n  private variationId: number;\n  private campaignId: number;\n  private type: string;\n  private ruleKey: string;\n\n  modelFromDictionary(rule: RuleModel): this {\n    this.type = rule.type;\n    this.status = rule.status;\n    this.variationId = rule.variationId;\n    this.campaignId = rule.campaignId;\n    this.ruleKey = rule.ruleKey;\n    return this;\n  }\n\n  getCampaignId(): number {\n    return this.campaignId;\n  }\n\n  getVariationId(): number {\n    return this.variationId;\n  }\n\n  getStatus(): boolean {\n    return this.status;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n\n  getRuleKey(): string {\n    return this.ruleKey;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../types/Common';\n\nexport class VariableModel {\n  private val: dynamic;\n  private value: dynamic;\n\n  private type: string;\n\n  private k: string;\n  private key: string;\n\n  private i: number;\n  private id: number;\n\n  modelFromDictionary(variable: VariableModel): this {\n    this.value = variable.val || variable.value;\n    this.type = variable.type;\n    this.key = variable.k || variable.key;\n    this.id = variable.i || variable.id;\n\n    return this;\n  }\n\n  setValue(value: dynamic): void {\n    this.value = value;\n  }\n\n  setKey(key: string): void {\n    this.key = key;\n  }\n\n  setType(type: string): void {\n    this.type = type;\n  }\n\n  getId(): number {\n    return this.id;\n  }\n\n  getValue(): dynamic {\n    return this.value;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n\n  getKey(): string {\n    return this.key;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../types/Common';\nimport { VariableModel } from './VariableModel';\n\nexport class VariationModel {\n  private i: number;\n  private id: number;\n\n  private n: string;\n  private key: string;\n  private name: string;\n\n  private w: number;\n  private weight: number;\n\n  private startRangeVariation: number;\n  private endRangeVariation: number;\n  private variables: Array<VariableModel> = [];\n  private variations: Array<VariationModel> = [];\n\n  private seg: Record<string, dynamic>;\n  private segments: Record<string, dynamic>;\n\n  modelFromDictionary(variation: VariationModel): this {\n    this.id = variation.i || variation.id;\n    this.key = variation.n || variation.key || variation.name;\n    this.weight = variation.w || variation.weight;\n    this.setStartRange(variation.startRangeVariation);\n    this.setEndRange(variation.endRangeVariation);\n    if (variation.seg || variation.segments) {\n      this.segments = variation.seg || variation.segments;\n    }\n\n    if (variation.variables) {\n      if (variation.variables.constructor === {}.constructor) {\n        this.variables = [];\n      } else {\n        const variableList: Array<VariableModel> = variation.variables;\n        variableList.forEach((variable) => {\n          this.variables.push(new VariableModel().modelFromDictionary(variable));\n        });\n      }\n    }\n\n    if (variation.variations) {\n      if (variation.variations.constructor === {}.constructor) {\n        this.variations = [];\n      } else {\n        const variationList: Array<VariationModel> = variation.variations;\n        variationList.forEach((variation: any) => {\n          this.variations.push(new VariationModel().modelFromDictionary(variation));\n        });\n      }\n    }\n\n    return this;\n  }\n\n  setStartRange(startRange: number): void {\n    this.startRangeVariation = startRange;\n  }\n\n  setEndRange(endRange: number): void {\n    this.endRangeVariation = endRange;\n  }\n\n  setWeight(weight: number): void {\n    this.weight = weight;\n  }\n\n  getId(): number {\n    return this.id;\n  }\n\n  getKey(): string {\n    return this.key;\n  }\n\n  getWeight(): number {\n    return this.weight;\n  }\n\n  getSegments(): Record<string, dynamic> {\n    return this.segments;\n  }\n\n  getStartRangeVariation(): number {\n    return this.startRangeVariation;\n  }\n\n  getEndRangeVariation(): number {\n    return this.endRangeVariation;\n  }\n\n  getVariables(): Array<VariableModel> {\n    return this.variables;\n  }\n\n  getVariations(): Array<VariationModel> {\n    return this.variations;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Struct, array, boolean, number, object, optional, string, union, validate } from 'superstruct';\nimport { dynamic } from '../../types/Common';\nimport { SettingsModel } from '../settings/SettingsModel';\n\nexport class SettingsSchema {\n  private campaignMetricSchema: Struct<dynamic>;\n  private variableObjectSchema: Struct<dynamic>;\n  private campaignVariationSchema: Struct<dynamic>;\n  private campaignObjectSchema: Struct<dynamic>;\n  private settingsSchema: Struct<dynamic>;\n  private featureSchema: Struct<dynamic>;\n  private ruleSchema: Struct<dynamic>;\n\n  constructor() {\n    this.initializeSchemas();\n  }\n\n  private initializeSchemas(): void {\n    this.campaignMetricSchema = object({\n      id: union([number(), string()]),\n      type: string(),\n      identifier: string(),\n      mca: optional(union([number(), string()])),\n      hasProps: optional(boolean()),\n      revenueProp: optional(string()),\n    });\n\n    this.variableObjectSchema = object({\n      id: union([number(), string()]),\n      type: string(),\n      key: string(),\n      value: union([number(), string(), boolean(), object()]),\n    });\n\n    this.campaignVariationSchema = object({\n      id: union([number(), string()]),\n      name: string(),\n      weight: union([number(), string()]),\n      segments: optional(object()),\n      variables: optional(array(this.variableObjectSchema)),\n      startRangeVariation: optional(number()),\n      endRangeVariation: optional(number()),\n    });\n\n    this.campaignObjectSchema = object({\n      id: union([number(), string()]),\n      type: string(),\n      key: string(),\n      percentTraffic: optional(number()),\n      status: string(),\n      variations: array(this.campaignVariationSchema),\n      segments: object(),\n      isForcedVariationEnabled: optional(boolean()),\n      isAlwaysCheckSegment: optional(boolean()),\n      name: string(),\n    });\n\n    this.ruleSchema = object({\n      type: string(),\n      ruleKey: string(),\n      campaignId: number(),\n      variationId: optional(number()),\n    });\n\n    this.featureSchema = object({\n      id: union([number(), string()]),\n      key: string(),\n      status: string(),\n      name: string(),\n      type: string(),\n      metrics: array(this.campaignMetricSchema),\n      impactCampaign: optional(object()),\n      rules: optional(array(this.ruleSchema)),\n      variables: optional(array(this.variableObjectSchema)),\n    });\n\n    this.settingsSchema = object({\n      sdkKey: optional(string()),\n      version: union([number(), string()]),\n      accountId: union([number(), string()]),\n      features: optional(array(this.featureSchema)),\n      campaigns: array(this.campaignObjectSchema),\n      groups: optional(object()),\n      campaignGroups: optional(object()),\n      collectionPrefix: optional(string()),\n    });\n  }\n\n  isSettingsValid(settings: any | SettingsModel): boolean {\n    if (!settings) {\n      return false;\n    }\n\n    const [error] = validate(settings, this.settingsSchema);\n    return !error;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CampaignModel } from '../campaign/CampaignModel';\nimport { FeatureModel } from '../campaign/FeatureModel';\n\nexport class SettingsModel {\n  private sK?: string;\n  private sdkKey: string;\n\n  private f?: Array<FeatureModel> = [];\n  private features: Array<FeatureModel> = [];\n\n  private c?: Array<CampaignModel> = [];\n  private campaigns: Array<CampaignModel> = [];\n\n  private campaignGroups?: Record<string, number> = {};\n  private cG?: Record<string, number> = {};\n\n  private groups?: Record<string, any> = {};\n  private g?: Record<string, any> = {};\n\n  private a?: string;\n  private accountId: string;\n\n  private v?: number;\n  private version: number;\n  private collectionPrefix?: string;\n\n  constructor(settings: SettingsModel) {\n    this.sdkKey = settings.sK || settings.sdkKey;\n    this.accountId = settings.a || settings.accountId;\n    this.version = settings.v || settings.version;\n    this.collectionPrefix = settings.collectionPrefix;\n\n    if (\n      (settings.f && settings.f.constructor !== {}.constructor) ||\n      (settings.features && settings.features.constructor !== {}.constructor)\n    ) {\n      const featureList: Array<FeatureModel> = settings.f || settings.features;\n      featureList.forEach((feature) => {\n        this.features.push(new FeatureModel().modelFromDictionary(feature));\n      });\n    }\n\n    if (\n      (settings.c && settings.c.constructor !== {}.constructor) ||\n      (settings.campaigns && settings.campaigns.constructor !== {}.constructor)\n    ) {\n      const campaignList: Array<CampaignModel> = settings.c || settings.campaigns;\n      campaignList.forEach((campaign) => {\n        this.campaigns.push(new CampaignModel().modelFromDictionary(campaign));\n      });\n    }\n\n    if (settings.cG || settings.campaignGroups) {\n      this.campaignGroups = settings.cG || settings.campaignGroups;\n    }\n\n    if (settings.g || settings.groups) {\n      this.groups = settings.g || settings.groups;\n    }\n\n    return this;\n  }\n  getFeatures(): Array<FeatureModel> {\n    return this.features;\n  }\n\n  getCampaigns(): Array<CampaignModel> {\n    return this.campaigns;\n  }\n\n  getSdkkey(): string {\n    return this.sdkKey;\n  }\n\n  getAccountId(): string {\n    return this.accountId;\n  }\n\n  getVersion(): number {\n    return this.version;\n  }\n\n  getCollectionPrefix(): string {\n    return this.collectionPrefix;\n  }\n\n  getCampaignGroups(): Record<string, number> {\n    return this.campaignGroups;\n  }\n\n  getGroups(): Record<string, any> {\n    return this.groups;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../types/Common';\nimport { ContextVWOModel } from './ContextVWOModel';\n\nexport class ContextModel {\n  private id: string | number;\n  private userAgent?: string;\n  private ipAddress?: string;\n  private customVariables?: Record<string, any>;\n  private variationTargetingVariables?: Record<string, dynamic>;\n  private _vwo?: ContextVWOModel;\n\n  modelFromDictionary(context: Record<string, any>): this {\n    this.id = context.id;\n    this.userAgent = context.userAgent;\n    this.ipAddress = context.ipAddress;\n    if (context?.customVariables) {\n      this.customVariables = context.customVariables;\n    }\n    if (context?.variationTargetingVariables) {\n      this.variationTargetingVariables = context.variationTargetingVariables;\n    }\n    if (context?._vwo) {\n      this._vwo = new ContextVWOModel().modelFromDictionary(context._vwo);\n    }\n    return this;\n  }\n\n  getId(): string {\n    return this.id?.toString();\n  }\n\n  getUserAgent(): string {\n    return this.userAgent;\n  }\n\n  getIpAddress(): string {\n    return this.ipAddress;\n  }\n\n  getCustomVariables(): Record<string, any> {\n    return this.customVariables;\n  }\n\n  setCustomVariables(customVariables: Record<string, any>): void {\n    this.customVariables = customVariables;\n  }\n\n  getVariationTargetingVariables(): Record<string, dynamic> {\n    return this.variationTargetingVariables;\n  }\n\n  setVariationTargetingVariables(variationTargetingVariables: Record<string, dynamic>): void {\n    this.variationTargetingVariables = variationTargetingVariables;\n  }\n\n  getVwo(): ContextVWOModel {\n    return this._vwo;\n  }\n\n  setVwo(_vwo: ContextVWOModel): void {\n    this._vwo = _vwo;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class ContextVWOModel {\n  private location: Record<string, string>;\n  private userAgent: Record<string, string>;\n\n  modelFromDictionary(context: Record<string, any>): this {\n    if (context?.location) {\n      this.location = context.location;\n    }\n\n    if (context?.userAgent) {\n      this.userAgent = context.userAgent;\n    }\n    return this;\n  }\n\n  getLocation(): Record<string, string> {\n    return this.location;\n  }\n\n  getUaInfo(): Record<string, string> {\n    return this.userAgent;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as Hasher from 'murmurhash';\n\nconst SEED_VALUE = 1; // Seed value for the hash function\nexport class DecisionMaker {\n  /**\n   * Generates a bucket value based on the hash value, maximum value, and an optional multiplier.\n   *\n   * @param {number} hashValue - The hash value used for calculation\n   * @param {number} maxValue - The maximum value for bucket scaling\n   * @param {number} [multiplier=1] - Optional multiplier to adjust the value\n   * @returns {number} - The calculated bucket value\n   */\n  generateBucketValue(hashValue: number, maxValue: number, multiplier = 1): number {\n    // Calculate the ratio based on the hash value\n    const ratio = hashValue / Math.pow(2, 32);\n    // Calculate the multiplied value\n    const multipliedValue = (maxValue * ratio + 1) * multiplier;\n    // Round down to get the final value\n    const value = Math.floor(multipliedValue);\n\n    return value;\n  }\n\n  /**\n   * Gets the bucket value for a user based on the hash key and maximum value.\n   *\n   * @param {string} hashKey - The hash key for the user\n   * @param {number} [maxValue=100] - The maximum value for bucket scaling\n   * @returns {number} - The calculated bucket value for the user\n   */\n  getBucketValueForUser(hashKey: string, maxValue = 100): number {\n    const hashValue = Hasher.v3(hashKey, SEED_VALUE); // Calculate the hash value\n    const bucketValue = this.generateBucketValue(hashValue, maxValue); // Calculate the bucket value\n\n    return bucketValue; // Return the calculated bucket value\n  }\n\n  /**\n   * Calculates the bucket value for a given string with optional multiplier and maximum value.\n   *\n   * @param {string} str - The input string to calculate the bucket value for\n   * @param {number} [multiplier=1] - Optional multiplier to adjust the value\n   * @param {number} [maxValue=10000] - The maximum value for bucket scaling\n   * @returns {number} - The calculated bucket value\n   */\n  calculateBucketValue(str: string, multiplier = 1, maxValue = 10000): number {\n    const hashValue = this.generateHashValue(str); // Generate the hash value for the input string\n\n    return this.generateBucketValue(hashValue, maxValue, multiplier); // Generate and return the bucket value\n  }\n\n  /**\n   * Generates the hash value for a given hash key using murmurHash v3.\n   *\n   * @param {string} hashKey - The hash key for which the hash value is generated\n   * @returns {number} - The generated hash value\n   */\n  generateHashValue(hashKey: string): number {\n    return Hasher.v3(hashKey, SEED_VALUE); // Return the hash value generated using murmurHash\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../types/Common';\nimport { LogLevelEnum } from './enums/LogLevelEnum';\n\nconst AnsiColorEnum = {\n  BOLD: '\\x1b[1m',\n  CYAN: '\\x1b[36m',\n  GREEN: '\\x1b[32m',\n  LIGHTBLUE: '\\x1b[94m',\n  RED: '\\x1b[31m',\n  RESET: '\\x1b[0m',\n  WHITE: '\\x1b[30m',\n  YELLOW: '\\x1b[33m',\n};\n/**\n * Interface defining the structure for a log message builder.\n */\ninterface ILogMessageBuilder {\n  loggerConfig: Record<string, dynamic>; // Configuration for the logger\n  transportConfig: Record<string, dynamic>; // Configuration for the transport mechanism\n  prefix: string; // Prefix to be added to each log message\n  dateTimeFormat: dynamic; // Function or format for date and time in log messages\n\n  formatMessage(level: string, message: string): string; // Method to format a log message\n  getFormattedLevel(level: string): string; // Method to format the log level\n  getFormattedDateTime(): string; // Method to get formatted date and time\n}\n\n/**\n * Implements the ILogMessageBuilder interface to provide a concrete log message builder.\n */\nexport class LogMessageBuilder implements ILogMessageBuilder {\n  loggerConfig: Record<string, any>;\n  transportConfig: Record<string, any>;\n  prefix: string;\n  dateTimeFormat: any;\n\n  /**\n   * Constructs a new LogMessageBuilder instance.\n   * @param {Record<string, any>} loggerConfig - Configuration for the logger.\n   * @param {Record<string, any>} transportConfig - Configuration for the transport mechanism.\n   */\n  constructor(loggerConfig: Record<string, any>, transportConfig: Record<string, any>) {\n    this.loggerConfig = loggerConfig;\n    this.transportConfig = transportConfig;\n\n    // Set the prefix, defaulting to an empty string if not provided.\n    this.prefix = this.transportConfig.prefix || this.loggerConfig.prefix || '';\n    // Set the date and time format, defaulting to the logger's format if the transport's format is not provided.\n    this.dateTimeFormat = this.transportConfig.dateTimeFormat || this.loggerConfig.dateTimeFormat;\n  }\n\n  /**\n   * Formats a log message combining level, prefix, date/time, and the actual message.\n   * @param {string} level - The log level.\n   * @param {string} message - The message to log.\n   * @returns {string} The formatted log message.\n   */\n  formatMessage(level: string, message: string): string {\n    return `[${this.getFormattedLevel(level)}]: ${this.getFormattedPrefix(this.prefix)} ${this.getFormattedDateTime()} ${message}`;\n  }\n\n  getFormattedPrefix(prefix: string): string {\n    if (this.loggerConfig.isAnsiColorEnabled) {\n      return `${AnsiColorEnum.BOLD}${AnsiColorEnum.GREEN}${prefix}${AnsiColorEnum.RESET}`;\n    }\n\n    return `${prefix}`;\n  }\n\n  /**\n   * Returns the formatted log level with appropriate coloring based on the log level.\n   * @param {string} level - The log level.\n   * @returns {string} The formatted log level.\n   */\n  getFormattedLevel(level: string): string {\n    const upperCaseLevel = level.toUpperCase();\n    let LogLevelColorInfoEnum;\n\n    if (this.loggerConfig.isAnsiColorEnabled) {\n      LogLevelColorInfoEnum = {\n        [LogLevelEnum.TRACE]: `${AnsiColorEnum.BOLD}${AnsiColorEnum.WHITE}${upperCaseLevel}${AnsiColorEnum.RESET}`,\n        [LogLevelEnum.DEBUG]: `${AnsiColorEnum.BOLD}${AnsiColorEnum.LIGHTBLUE}${upperCaseLevel}${AnsiColorEnum.RESET}`,\n        [LogLevelEnum.INFO]: `${AnsiColorEnum.BOLD}${AnsiColorEnum.CYAN}${upperCaseLevel}${AnsiColorEnum.RESET}`,\n        [LogLevelEnum.WARN]: `${AnsiColorEnum.BOLD}${AnsiColorEnum.YELLOW}${upperCaseLevel}${AnsiColorEnum.RESET}`,\n        [LogLevelEnum.ERROR]: `${AnsiColorEnum.BOLD}${AnsiColorEnum.RED}${upperCaseLevel}${AnsiColorEnum.RESET}`,\n      };\n    } else {\n      LogLevelColorInfoEnum = {\n        [LogLevelEnum.TRACE]: upperCaseLevel,\n        [LogLevelEnum.DEBUG]: upperCaseLevel,\n        [LogLevelEnum.INFO]: upperCaseLevel,\n        [LogLevelEnum.WARN]: upperCaseLevel,\n        [LogLevelEnum.ERROR]: upperCaseLevel,\n      };\n    }\n\n    return LogLevelColorInfoEnum[level];\n  }\n\n  /**\n   * Retrieves the current date and time formatted according to the specified format.\n   * @returns {string} The formatted date and time.\n   */\n  getFormattedDateTime(): string {\n    return this.dateTimeFormat();\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Abstract class representing a logger.\n * This class provides the structure for logging mechanisms and should be extended by specific logger implementations.\n */\nexport abstract class Logger {\n  /**\n   * Logs a message at the trace level.\n   * @param {string} message - The message to log.\n   */\n  abstract trace(message: string): void;\n\n  /**\n   * Logs a message at the debug level.\n   * @param {string} message - The message to log.\n   */\n  abstract debug(message: string): void;\n\n  /**\n   * Logs a message at the info level.\n   * @param {string} message - The message to log.\n   */\n  abstract info(message: string): void;\n\n  /**\n   * Logs a message at the warn level.\n   * @param {string} message - The message to log.\n   */\n  abstract warn(message: string): void;\n\n  /**\n   * Logs a message at the error level.\n   * @param {string} message - The message to log.\n   */\n  abstract error(message: string): void;\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { dynamic } from '../../../types/Common';\n\nimport { Logger } from '../Logger';\nimport { ConsoleTransport } from '../transports/ConsoleTransport';\nimport { LogTransportManager } from './TransportManager';\n\nimport { isObject } from '../../../utils/DataTypeUtil';\nimport { LogLevelEnum } from '../enums/LogLevelEnum';\n\n/**\n * Interface defining the structure and methods for LogManager.\n */\nexport interface ILogManager {\n  transportManager?: LogTransportManager;\n  config?: Record<string, dynamic>;\n  name?: string;\n  requestId?: string;\n  level: string;\n  prefix?: string;\n  dateTimeFormat?: () => string;\n\n  transport?: Record<string, dynamic>;\n  transports?: Array<Record<string, dynamic>>;\n\n  addTransport?(transportObject: Record<string, dynamic>): void;\n  addTransports?(transportsList: Array<Record<string, dynamic>>): void;\n}\n\n/**\n * LogManager class provides logging functionality with support for multiple transports.\n * It is designed as a singleton to ensure a single instance throughout the application.\n */\nexport class LogManager extends Logger implements ILogManager {\n  private static instance: LogManager; // Singleton instance of LogManager\n  transportManager: LogTransportManager;\n  config: Record<string, any>;\n  name = 'VWO Logger'; // Default logger name\n  requestId = uuidv4(); // Unique request ID generated for each instance\n  level = LogLevelEnum.ERROR; // Default logging level\n  prefix = 'VWO-SDK'; // Default prefix for log messages\n  public dateTimeFormat(): string {\n    return new Date().toISOString(); // Default date-time format for log messages\n  }\n  transport: Record<string, any>;\n  transports: Array<Record<string, any>>;\n\n  /**\n   * Constructor for LogManager.\n   * @param {Record<string, any>} config - Configuration object for LogManager.\n   */\n  constructor(config?: Record<string, any>) {\n    super();\n\n    this.config = config;\n\n    if (config.isAlwaysNewInstance || !LogManager.instance) {\n      LogManager.instance = this;\n\n      // Initialize configuration with defaults or provided values\n      this.config.name = config.name || this.name;\n      this.config.requestId = config.requestId || this.requestId;\n      this.config.level = config.level || this.level;\n      this.config.prefix = config.prefix || this.prefix;\n      this.config.dateTimeFormat = config.dateTimeFormat || this.dateTimeFormat;\n\n      this.transportManager = new LogTransportManager(this.config);\n\n      this.handleTransports();\n    }\n\n    return LogManager.instance;\n  }\n\n  /**\n   * Provides access to the singleton instance of LogManager.\n   * @returns {LogManager} The singleton instance.\n   */\n  static get Instance(): LogManager {\n    return LogManager.instance;\n  }\n\n  /**\n   * Handles the initialization and setup of transports based on configuration.\n   */\n  handleTransports(): void {\n    const transports = this.config.transports;\n\n    if (transports?.length) {\n      this.addTransports(this.config.transports);\n    } else if (this.config.transport && isObject(this.config.transport)) {\n      this.addTransport(this.config.transport);\n    } else {\n      // if (this.config.defaultTransport)\n      // Add default ConsoleTransport if no other transport is specified\n      this.addTransport(\n        new ConsoleTransport({\n          level: this.config.level,\n        }),\n      );\n    }\n  }\n\n  /**\n   * Adds a single transport to the LogManager.\n   * @param {Record<any, any>} transport - The transport object to add.\n   */\n  addTransport(transport: Record<any, any>): void {\n    this.transportManager.addTransport(transport);\n  }\n\n  /**\n   * Adds multiple transports to the LogManager.\n   * @param {Array<Record<any, any>>} transports - The list of transport objects to add.\n   */\n  addTransports(transports: Record<any, any>): void {\n    for (let i = 0; i < transports.length; i++) {\n      this.addTransport(transports[i]);\n    }\n  }\n\n  /**\n   * Logs a trace message.\n   * @param {string} message - The message to log at trace level.\n   */\n  trace(message: string): void {\n    this.transportManager.log(LogLevelEnum.TRACE, message);\n  }\n\n  /**\n   * Logs a debug message.\n   * @param {string} message - The message to log at debug level.\n   */\n  debug(message: string): void {\n    this.transportManager.log(LogLevelEnum.DEBUG, message);\n  }\n\n  /**\n   * Logs an informational message.\n   * @param {string} message - The message to log at info level.\n   */\n  info(message: string): void {\n    this.transportManager.log(LogLevelEnum.INFO, message);\n  }\n\n  /**\n   * Logs a warning message.\n   * @param {string} message - The message to log at warn level.\n   */\n  warn(message: string): void {\n    this.transportManager.log(LogLevelEnum.WARN, message);\n  }\n\n  /**\n   * Logs an error message.\n   * @param {string} message - The message to log at error level.\n   */\n  error(message: string): void {\n    this.transportManager.log(LogLevelEnum.ERROR, message);\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { dynamic } from '../../../types/Common';\nimport { LogLevelEnum } from '../enums/LogLevelEnum';\nimport { LogMessageBuilder } from '../LogMessageBuilder';\nimport { Logger } from '../Logger';\nimport { isFunction } from '../../../utils/DataTypeUtil';\n\nenum LogLevelNumberEnum {\n  TRACE = 0,\n  DEBUG = 1,\n  INFO = 2,\n  WARN = 3,\n  ERROR = 4,\n}\n\ninterface IlogTransport extends Logger {\n  transports: Array<Record<string, dynamic>>;\n  config: Record<string, dynamic>;\n\n  // Determines if a message should be logged based on the transport and configuration levels\n  shouldLog(transportLevel: string, configLevel: string): boolean;\n  // Logs a message at a specified level\n  log(level: string, message: string): void;\n}\n\n/**\n * Manages logging transports and delegates logging messages to them based on configuration.\n * Implements the IlogTransport interface.\n */\nexport class LogTransportManager implements IlogTransport {\n  transports: Array<Record<string, any>>;\n  config: Record<string, any>;\n\n  /**\n   * Initializes the manager with a configuration object.\n   * @param {Record<string, any>} config - Configuration settings for the log manager.\n   */\n  constructor(config: Record<string, any>) {\n    this.transports = [];\n    this.config = config;\n  }\n\n  /**\n   * Adds a new transport to the manager.\n   * @param {Record<string, any>} transport - The transport object to be added.\n   */\n  addTransport(transport: Record<string, any>): void {\n    this.transports.push(transport);\n  }\n\n  /**\n   * Determines if the log should be processed based on the transport and configuration levels.\n   * @param {string} transportLevel - The log level set for the transport.\n   * @param {string} configLevel - The log level set in the configuration.\n   * @returns {boolean} - Returns true if the log level is appropriate for logging, false otherwise.\n   */\n  shouldLog(transportLevel: string, configLevel: string): boolean {\n    // Default to the most specific level available\n    // transportLevel = transportLevel || configLevel || this.config.level;\n\n    const targetLevel = LogLevelNumberEnum[transportLevel.toUpperCase()];\n    const desiredLevel = LogLevelNumberEnum[(configLevel || this.config.level).toUpperCase()];\n\n    return targetLevel >= desiredLevel;\n  }\n\n  /**\n   * Logs a message at TRACE level.\n   * @param {string} message - The message to log.\n   */\n  trace(message: string): void {\n    this.log(LogLevelEnum.TRACE, message);\n  }\n\n  /**\n   * Logs a message at DEBUG level.\n   * @param {string} message - The message to log.\n   */\n  debug(message: string): void {\n    this.log(LogLevelEnum.DEBUG, message);\n  }\n\n  /**\n   * Logs a message at INFO level.\n   * @param {string} message - The message to log.\n   */\n  info(message: string): void {\n    this.log(LogLevelEnum.INFO, message);\n  }\n\n  /**\n   * Logs a message at WARN level.\n   * @param {string} message - The message to log.\n   */\n  warn(message: string): void {\n    this.log(LogLevelEnum.WARN, message);\n  }\n\n  /**\n   * Logs a message at ERROR level.\n   * @param {string} message - The message to log.\n   */\n  error(message: string): void {\n    this.log(LogLevelEnum.ERROR, message);\n  }\n\n  /**\n   * Delegates the logging of messages to the appropriate transports.\n   * @param {string} level - The level at which to log the message.\n   * @param {string} message - The message to log.\n   */\n  log(level: string, message: string): void {\n    for (let i = 0; i < this.transports.length; i++) {\n      const logMessageBuilder = new LogMessageBuilder(this.config, this.transports[i]);\n      const formattedMessage = logMessageBuilder.formatMessage(level, message);\n      if (this.shouldLog(level, this.transports[i].level)) {\n        if (this.transports[i].log && isFunction(this.transports[i].log)) {\n          // Use custom log handler if available\n          this.transports[i].log(level, message);\n        } else {\n          // Otherwise, use the default log method\n          this.transports[i][level](formattedMessage);\n        }\n      }\n    }\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum LogLevelEnum {\n  TRACE = 'trace',\n  DEBUG = 'debug',\n  INFO = 'info',\n  WARN = 'warn',\n  ERROR = 'error',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { LogManager, ILogManager } from './core/LogManager';\nexport { LogLevelEnum } from './enums/LogLevelEnum';\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LogLevelEnum } from '../enums/LogLevelEnum';\nimport { Logger } from '../Logger';\n\n/**\n * ConsoleTransport class implements the Logger interface to provide logging functionality.\n * It outputs logs to the console based on the log level set in the configuration.\n */\nexport class ConsoleTransport implements Logger {\n  config: Record<string, any>; // Configuration object for the logger\n  level: string; // Current log level\n\n  /**\n   * Constructor initializes the ConsoleTransport with a configuration object.\n   * @param {Record<string, any>} config - Configuration settings for the logger, including 'level'.\n   */\n  constructor(config: Record<string, any> = {}) {\n    this.config = config; // Store the configuration\n    this.level = this.config.level; // Set the logging level from the configuration\n  }\n\n  /**\n   * Logs a trace message.\n   * @param {string} message - The message to log.\n   */\n  trace(message: string): void {\n    this.consoleLog(LogLevelEnum.TRACE, message);\n  }\n\n  /**\n   * Logs a debug message.\n   * @param {string} message - The message to log.\n   */\n  debug(message: string): void {\n    this.consoleLog(LogLevelEnum.DEBUG, message);\n  }\n\n  /**\n   * Logs an informational message.\n   * @param {string} message - The message to log.\n   */\n  info(message: string): void {\n    this.consoleLog(LogLevelEnum.INFO, message);\n  }\n\n  /**\n   * Logs a warning message.\n   * @param {string} message - The message to log.\n   */\n  warn(message: string): void {\n    this.consoleLog(LogLevelEnum.WARN, message);\n  }\n\n  /**\n   * Logs an error message.\n   * @param {string} message - The message to log.\n   */\n  error(message: string): void {\n    this.consoleLog(LogLevelEnum.ERROR, message);\n  }\n\n  /**\n   * Generic log function that logs messages to the console based on the log level.\n   * @param {string} level - The log level under which the message should be logged.\n   * @param {string} message - The message to log.\n   */\n  consoleLog(level: string, message: string): void {\n    console[level](message); // Use console's logging function dynamically based on the level\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { sendGetCall, sendPostCall } from '../../../utils/XMLUtil';\nimport { dynamic } from '../../../types/Common';\nimport { Deferred } from '../../../utils/PromiseUtil';\n\nimport { RequestModel } from '../models/RequestModel';\nimport { ResponseModel } from '../models/ResponseModel';\nimport { NetworkClientInterface } from './NetworkClientInterface';\n\n/**\n * Implements the NetworkClientInterface to handle network requests.\n */\nexport class NetworkBrowserClient implements NetworkClientInterface {\n  /**\n   * Performs a GET request using the provided RequestModel.\n   * @param {RequestModel} requestModel - The model containing request options.\n   * @returns {Promise<ResponseModel>} A promise that resolves to a ResponseModel.\n   */\n  GET(requestModel: RequestModel): Promise<ResponseModel> {\n    const deferred = new Deferred();\n\n    // Extract network options from the request model.\n    const networkOptions: Record<string, dynamic> = requestModel.getOptions();\n    const responseModel = new ResponseModel();\n\n    sendGetCall({\n      networkOptions,\n      successCallback: (data: dynamic) => {\n        responseModel.setData(data);\n        deferred.resolve(responseModel);\n      },\n      errorCallback: (error: dynamic) => {\n        responseModel.setError(error);\n        deferred.reject(responseModel);\n      },\n    });\n\n    /*try {\n      fetch(url)\n          .then(res => {\n            // Some endpoints return empty strings as the response body; treat\n            // as raw text and handle potential JSON parsing errors below\n            return res.text().then(text => {\n              let jsonData = {};\n              try {\n                jsonData = JSON.parse(text);\n              } catch (err) {\n                console.info(\n                  `VWO-SDK - [INFO]: VWO didn't send JSON response which is expected: ${err}`\n                );\n              }\n\n              if (res.status === 200) {\n                responseModel.setData(jsonData);\n                deferred.resolve(responseModel);\n              } else {\n                let error = `VWO-SDK - [ERROR]: Request failed for fetching account settings. Got Status Code: ${\n                  res.status\n                }`;\n\n                responseModel.setError(error);\n                deferred.reject(responseModel);\n              }\n            });\n          })\n          .catch(err => {\n            responseModel.setError(err);\n            deferred.reject(responseModel);\n          });\n    } catch (err) {\n      responseModel.setError(err);\n      deferred.reject(responseModel);\n    } */\n    return deferred.promise;\n  }\n\n  /**\n   * Performs a POST request using the provided RequestModel.\n   * @param {RequestModel} request - The model containing request options.\n   * @returns {Promise<ResponseModel>} A promise that resolves or rejects with a ResponseModel.\n   */\n  POST(request: RequestModel): Promise<ResponseModel> {\n    const deferred = new Deferred();\n    const networkOptions: Record<string, dynamic> = request.getOptions();\n    const responseModel = new ResponseModel();\n\n    sendPostCall({\n      networkOptions,\n      successCallback: (data: dynamic) => {\n        responseModel.setData(data);\n        deferred.resolve(responseModel);\n      },\n      errorCallback: (error: dynamic) => {\n        responseModel.setError(error);\n        deferred.reject(responseModel);\n      },\n    });\n\n    /* try {\n      const options: any = Object.assign(\n        {},\n        { method: HttpMethodEnum.POST },\n        { body: networkOptions.body },\n        { headers: networkOptions.headers }\n      );\n\n      fetch(url, options)\n          .then(res => {\n            // Some endpoints return empty strings as the response body; treat\n            // as raw text and handle potential JSON parsing errors below\n            return res.text().then(text => {\n              let jsonData = {};\n              try {\n                jsonData = JSON.parse(text);\n              } catch (err) {\n                console.info(\n                  `VWO-SDK - [INFO]: VWO didn't send JSON response which is expected: ${err}`\n                );\n              }\n\n              if (res.status === 200) {\n                responseModel.setData(jsonData);\n                deferred.resolve(responseModel);\n              } else {\n                let error = `VWO-SDK - [ERROR]: Request failed for fetching account settings. Got Status Code: ${\n                  res.status\n                }`;\n\n                responseModel.setError(error);\n                deferred.reject(responseModel);\n              }\n            });\n          })\n          .catch(err => {\n            responseModel.setError(err);\n            deferred.reject(responseModel);\n          });\n    } catch (err) {\n      responseModel.setError(err);\n      deferred.reject(responseModel);\n    } */\n\n    return deferred.promise;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../../types/Common';\nimport { GlobalRequestModel } from '../models/GlobalRequestModel';\nimport { RequestModel } from '../models/RequestModel';\n\n/**\n * A class responsible for creating and modifying request models based on a global configuration.\n */\nexport class RequestHandler {\n  /**\n   * Creates a new request by merging properties from a base request and a configuration model.\n   * If both the request URL and the base URL from the configuration are missing, it returns null.\n   * Otherwise, it merges the properties from the configuration into the request if they are not already set.\n   *\n   * @param {RequestModel} request - The initial request model.\n   * @param {GlobalRequestModel} config - The global request configuration model.\n   * @returns {RequestModel} The merged request model or null if both URLs are missing.\n   */\n  createRequest(request: RequestModel, config: GlobalRequestModel): RequestModel {\n    // Check if both the request URL and the configuration base URL are missing\n    if (\n      (config.getBaseUrl() === null || config.getBaseUrl() === undefined) &&\n      (request.getUrl() === null || request.getUrl() === undefined)\n    ) {\n      return null; // Return null if no URL is specified\n    }\n    // Set the request URL, defaulting to the configuration base URL if not set\n    request.setUrl(request.getUrl() || config.getBaseUrl());\n    // Set the request timeout, defaulting to the configuration timeout if not set\n    request.setTimeout(request.getTimeout() || config.getTimeout());\n    // Set the request body, defaulting to the configuration body if not set\n    request.setBody(request.getBody() || config.getBody());\n    // Set the request headers, defaulting to the configuration headers if not set\n    request.setHeaders(request.getHeaders() || config.getHeaders());\n    // Initialize request query parameters, defaulting to an empty object if not set\n    const requestQueryParams: Record<string, dynamic> = request.getQuery() || {};\n    // Initialize configuration query parameters, defaulting to an empty object if not set\n    const configQueryParams: Record<string, dynamic> = config.getQuery() || {};\n\n    // Merge configuration query parameters into the request query parameters if they don't exist\n    for (const queryKey in configQueryParams) {\n      if (!Object.prototype.hasOwnProperty.call(requestQueryParams, queryKey)) {\n        requestQueryParams[queryKey] = configQueryParams[queryKey];\n      }\n    }\n    // Set the merged query parameters back to the request\n    request.setQuery(requestQueryParams);\n    return request; // Return the modified request\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet NetworkClient;\n\nif ((typeof process.env as any) === 'undefined') {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  NetworkClient = require('./client/NetworkBrowserClient').NetworkBrowserClient;\n} else {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  NetworkClient = require('./client/NetworkClient').NetworkClient;\n}\n\nexport { NetworkClient };\nexport { NetworkClientInterface } from './client/NetworkClientInterface';\nexport { NetworkManager } from './manager/NetworkManager';\nexport { GlobalRequestModel } from './models/GlobalRequestModel';\nexport { RequestModel } from './models/RequestModel';\nexport { ResponseModel } from './models/ResponseModel';\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Deferred } from '../../../utils/PromiseUtil';\nimport { NetworkClientInterface } from '../client/NetworkClientInterface';\nimport { RequestHandler } from '../handlers/RequestHandler';\nimport { GlobalRequestModel } from '../models/GlobalRequestModel';\nimport { RequestModel } from '../models/RequestModel';\nimport { ResponseModel } from '../models/ResponseModel';\n\nexport class NetworkManager {\n  private config: GlobalRequestModel; // Holds the global configuration for network requests\n  private client: NetworkClientInterface; // Interface for the network client handling the actual HTTP requests\n  private static instance: NetworkManager; // Singleton instance of NetworkManager\n\n  /**\n   * Attaches a network client to the manager, or uses a default if none provided.\n   * @param {NetworkClientInterface} client - The client to attach, optional.\n   */\n  attachClient(client?: NetworkClientInterface): void {\n    if ((typeof process.env as any) === 'undefined') {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const { NetworkBrowserClient } = require('../client/NetworkBrowserClient');\n\n      this.client = client || new NetworkBrowserClient(); // Use provided client or default to NetworkClient\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const { NetworkClient } = require('../client/NetworkClient');\n\n      this.client = client || new NetworkClient(); // Use provided client or default to NetworkClient\n    }\n\n    this.config = new GlobalRequestModel(null, null, null, null); // Initialize with default config\n  }\n\n  /**\n   * Singleton accessor for the NetworkManager instance.\n   * @returns {NetworkManager} The singleton instance.\n   */\n  static get Instance(): NetworkManager {\n    this.instance = this.instance || new NetworkManager(); // Create instance if it doesn't exist\n    return this.instance;\n  }\n\n  /**\n   * Sets the global configuration for network requests.\n   * @param {GlobalRequestModel} config - The configuration to set.\n   */\n  setConfig(config: GlobalRequestModel): void {\n    this.config = config; // Set the global request configuration\n  }\n\n  /**\n   * Retrieves the current global configuration.\n   * @returns {GlobalRequestModel} The current configuration.\n   */\n  getConfig(): GlobalRequestModel {\n    return this.config; // Return the global request configuration\n  }\n\n  /**\n   * Creates a network request model by merging specific request data with global config.\n   * @param {RequestModel} request - The specific request data.\n   * @returns {RequestModel} The merged request model.\n   */\n  createRequest(request: RequestModel): RequestModel {\n    const options: RequestModel = new RequestHandler().createRequest(request, this.config); // Merge and create request\n    return options;\n  }\n\n  /**\n   * Performs a GET request using the provided request model.\n   * @param {RequestModel} request - The request model.\n   * @returns {Promise<ResponseModel>} A promise that resolves to the response model.\n   */\n  get(request: RequestModel): Promise<ResponseModel> {\n    const deferred = new Deferred(); // Create a new deferred promise\n\n    const networkOptions: RequestModel = this.createRequest(request); // Create network request options\n    if (!networkOptions.getUrl()) {\n      deferred.reject(new Error('no url found')); // Reject if no URL is found\n    } else {\n      this.client\n        .GET(networkOptions)\n        .then((response: ResponseModel) => {\n          deferred.resolve(response); // Resolve with the response\n        })\n        .catch((errorResponse: ResponseModel) => {\n          deferred.reject(errorResponse); // Reject with the error response\n        });\n    }\n\n    return deferred.promise; // Return the promise\n  }\n\n  /**\n   * Performs a POST request using the provided request model.\n   * @param {RequestModel} request - The request model.\n   * @returns {Promise<ResponseModel>} A promise that resolves to the response model.\n   */\n  post(request: RequestModel): Promise<ResponseModel> {\n    const deferred = new Deferred(); // Create a new deferred promise\n\n    const networkOptions: RequestModel = this.createRequest(request); // Create network request options\n    if (!networkOptions.getUrl()) {\n      deferred.reject(new Error('no url found')); // Reject if no URL is found\n    } else {\n      this.client\n        .POST(networkOptions)\n        .then((response: ResponseModel) => {\n          deferred.resolve(response); // Resolve with the response\n        })\n        .catch((error: ResponseModel) => {\n          deferred.reject(error); // Reject with the error\n        });\n    }\n\n    return deferred.promise; // Return the promise\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../../types/Common';\n\n/**\n * Represents a model for global HTTP requests configuration.\n * This class encapsulates all necessary details such as URL, query parameters, body, headers,\n * timeout settings, and development mode flag.\n */\nexport class GlobalRequestModel {\n  private url: string; // Base URL of the HTTP request\n  private timeout = 3000; // Default timeout for the HTTP request in milliseconds\n  private query: Record<string, dynamic>; // Query parameters for the HTTP request\n  private body: Record<string, dynamic>; // Body of the HTTP request\n  private headers: Record<string, string>; // HTTP headers\n  private isDevelopmentMode: boolean; // Flag to indicate if the request is in development mode\n\n  /**\n   * Constructs an instance of the GlobalRequestModel.\n   * @param url The base URL of the HTTP request.\n   * @param query Query parameters as a record of key-value pairs.\n   * @param body Body of the request as a record of key-value pairs.\n   * @param headers HTTP headers as a record of key-value pairs.\n   */\n  constructor(\n    url: string,\n    query: Record<string, dynamic>,\n    body: Record<string, dynamic>,\n    headers: Record<string, any>,\n  ) {\n    this.url = url;\n    this.query = query;\n    this.body = body;\n    this.headers = headers;\n  }\n\n  /**\n   * Sets the query parameters for the HTTP request.\n   * @param query A record of key-value pairs representing the query parameters.\n   */\n  setQuery(query: Record<string, dynamic>): void {\n    this.query = query;\n  }\n\n  /**\n   * Retrieves the query parameters of the HTTP request.\n   * @returns A record of key-value pairs representing the query parameters.\n   */\n  getQuery(): Record<string, dynamic> {\n    return this.query;\n  }\n\n  /**\n   * Sets the body of the HTTP request.\n   * @param body A record of key-value pairs representing the body content.\n   */\n  setBody(body: Record<string, dynamic>): void {\n    this.body = body;\n  }\n\n  /**\n   * Retrieves the body of the HTTP request.\n   * @returns A record of key-value pairs representing the body content.\n   */\n  getBody(): Record<string, dynamic> {\n    return this.body;\n  }\n\n  /**\n   * Sets the base URL of the HTTP request.\n   * @param url The base URL as a string.\n   */\n  setBaseUrl(url: string): void {\n    this.url = url;\n  }\n\n  /**\n   * Retrieves the base URL of the HTTP request.\n   * @returns The base URL as a string.\n   */\n  getBaseUrl(): string {\n    return this.url;\n  }\n\n  /**\n   * Sets the timeout duration for the HTTP request.\n   * @param timeout Timeout in milliseconds.\n   */\n  setTimeout(timeout: number): void {\n    this.timeout = timeout;\n  }\n\n  /**\n   * Retrieves the timeout duration of the HTTP request.\n   * @returns Timeout in milliseconds.\n   */\n  getTimeout(): number {\n    return this.timeout;\n  }\n\n  /**\n   * Sets the HTTP headers for the request.\n   * @param headers A record of key-value pairs representing the HTTP headers.\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this.headers = headers;\n  }\n\n  /**\n   * Retrieves the HTTP headers of the request.\n   * @returns A record of key-value pairs representing the HTTP headers.\n   */\n  getHeaders(): Record<string, string> {\n    return this.headers;\n  }\n\n  /**\n   * Sets the development mode status for the request.\n   * @param isDevelopmentMode Boolean flag indicating if the request is in development mode.\n   */\n  setDevelopmentMode(isDevelopmentMode: boolean): void {\n    this.isDevelopmentMode = isDevelopmentMode;\n  }\n\n  /**\n   * Retrieves the development mode status of the request.\n   * @returns Boolean indicating if the request is in development mode.\n   */\n  getDevelopmentMode(): boolean {\n    return this.isDevelopmentMode;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HttpMethodEnum } from '../../../enums/HttpMethodEnum';\nimport { dynamic } from '../../../types/Common';\nimport { HTTPS } from '../../../constants/Url';\n\n/**\n * Represents a model for HTTP requests.\n * This class encapsulates all necessary details such as URL, method, path, query parameters, body, headers,\n * scheme, port, and timeout settings.\n */\nexport class RequestModel {\n  private url: string; // Base URL of the HTTP request\n  private method: string; // HTTP method (GET, POST, etc.)\n  private scheme: string; // Protocol scheme (http, https)\n  private port: number; // Port number\n  private path: string; // Path of the URL\n  private query: Record<string, dynamic>; // Query parameters\n  private timeout: number; // Timeout for the HTTP request in milliseconds\n  private body: Record<string, dynamic>; // Body of the HTTP request\n  private headers: Record<string, string>; // HTTP headers\n\n  /**\n   * Constructs an instance of the RequestModel.\n   * @param url The base URL of the HTTP request.\n   * @param method HTTP method, default is 'GET'.\n   * @param path URL path.\n   * @param query Query parameters as a record of key-value pairs.\n   * @param body Body of the request as a record of key-value pairs.\n   * @param headers HTTP headers as a record of key-value pairs.\n   * @param scheme Protocol scheme, default is 'http'.\n   * @param port Port number, default is 80.\n   */\n  constructor(\n    url: string,\n    method: string = HttpMethodEnum.GET,\n    path: string,\n    query: Record<string, dynamic>,\n    body: Record<string, dynamic>,\n    headers: Record<string, string>,\n    scheme: string = HTTPS,\n    port: number,\n  ) {\n    this.url = url;\n    this.method = method;\n    this.path = path;\n    this.query = query;\n    this.body = body;\n    this.headers = headers;\n    this.scheme = scheme;\n    this.port = port;\n  }\n\n  /**\n   * Retrieves the HTTP method.\n   * @returns The HTTP method as a string.\n   */\n  getMethod(): string {\n    return this.method;\n  }\n\n  /**\n   * Sets the HTTP method.\n   * @param method The HTTP method to set.\n   */\n  setMethod(method: string): void {\n    this.method = method;\n  }\n\n  /**\n   * Retrieves the body of the HTTP request.\n   * @returns A record of key-value pairs representing the body content.\n   */\n  getBody(): Record<string, dynamic> {\n    return this.body;\n  }\n\n  /**\n   * Sets the body of the HTTP request.\n   * @param body A record of key-value pairs representing the body content.\n   */\n  setBody(body: Record<string, dynamic>): void {\n    this.body = body;\n  }\n\n  /**\n   * Sets the query parameters for the HTTP request.\n   * @param query A record of key-value pairs representing the query parameters.\n   */\n  setQuery(query: Record<string, dynamic>): void {\n    this.query = query;\n  }\n\n  /**\n   * Retrieves the query parameters of the HTTP request.\n   * @returns A record of key-value pairs representing the query parameters.\n   */\n  getQuery(): Record<string, dynamic> {\n    return this.query;\n  }\n\n  /**\n   * Sets the HTTP headers for the request.\n   * @param headers A record of key-value pairs representing the HTTP headers.\n   */\n  setHeaders(headers: Record<string, string>): this {\n    this.headers = headers;\n    return this;\n  }\n\n  /**\n   * Retrieves the HTTP headers of the request.\n   * @returns A record of key-value pairs representing the HTTP headers.\n   */\n  getHeaders(): Record<string, string> {\n    return this.headers;\n  }\n\n  /**\n   * Sets the timeout duration for the HTTP request.\n   * @param timeout Timeout in milliseconds.\n   */\n  setTimeout(timeout: number): this {\n    this.timeout = timeout;\n    return this;\n  }\n\n  /**\n   * Retrieves the timeout duration of the HTTP request.\n   * @returns Timeout in milliseconds.\n   */\n  getTimeout(): number {\n    return this.timeout;\n  }\n\n  /**\n   * Retrieves the base URL of the HTTP request.\n   * @returns The base URL as a string.\n   */\n  getUrl(): string {\n    return this.url;\n  }\n\n  /**\n   * Sets the base URL of the HTTP request.\n   * @param url The base URL as a string.\n   */\n  setUrl(url: string): this {\n    this.url = url;\n    return this;\n  }\n\n  /**\n   * Retrieves the scheme of the HTTP request.\n   * @returns The scheme as a string.\n   */\n  getScheme(): string {\n    return this.scheme;\n  }\n\n  /**\n   * Sets the scheme of the HTTP request.\n   * @param scheme The scheme to set (http or https).\n   */\n  setScheme(scheme: string): this {\n    this.scheme = scheme;\n    return this;\n  }\n\n  /**\n   * Retrieves the port number of the HTTP request.\n   * @returns The port number as an integer.\n   */\n  getPort(): number {\n    return this.port;\n  }\n\n  /**\n   * Sets the port number for the HTTP request.\n   * @param port The port number to set.\n   */\n  setPort(port: number): this {\n    this.port = port;\n    return this;\n  }\n\n  /**\n   * Retrieves the path of the HTTP request.\n   * @returns The path as a string.\n   */\n  getPath(): string {\n    return this.path;\n  }\n\n  /**\n   * Sets the path of the HTTP request.\n   * @param path The path to set.\n   */\n  setPath(path: string): this {\n    this.path = path;\n    return this;\n  }\n\n  /**\n   * Constructs the options for the HTTP request based on the current state of the model.\n   * This method is used to prepare the request options for execution.\n   * @returns A record containing all relevant options for the HTTP request.\n   */\n  getOptions(): Record<string, any> {\n    let queryParams = '';\n    for (const key in this.query) {\n      const queryString = `${key}=${this.query[key]}&`;\n      queryParams += queryString;\n    }\n\n    const [hostname, collectionPrefix] = this.url.split('/');\n    const options: Record<string, any> = {\n      hostname, // if url is example.com/as01, hostname will be example.com\n      agent: false,\n    };\n\n    if (this.scheme) {\n      options.scheme = this.scheme;\n    }\n    if (this.port) {\n      options.port = this.port;\n    }\n    if (this.headers) {\n      options.headers = this.headers;\n    }\n\n    if (this.method) {\n      options.method = this.method;\n    }\n\n    if (this.body) {\n      const postBody = JSON.stringify(this.body);\n      options.headers = options.headers || {};\n      options.headers['Content-Type'] = 'application/json';\n\n      if (typeof Buffer === 'undefined') {\n        options.headers['Content-Length'] = new TextEncoder().encode(postBody).length;\n      } else {\n        options.headers['Content-Length'] = Buffer.byteLength(postBody);\n      }\n      options.body = this.body;\n    }\n\n    if (this.path) {\n      if (queryParams !== '') {\n        options.path = this.path + '?' + queryParams || '';\n      } else {\n        options.path = this.path;\n      }\n    }\n\n    if (collectionPrefix) {\n      options.path = `/${collectionPrefix}` + options.path;\n    }\n    if (this.timeout) {\n      options.timeout = this.timeout;\n    }\n    if (options.path.charAt(options.path.length - 1) === '&') {\n      options.path = options.path.substring(0, options.path.length - 1);\n    }\n\n    return options;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../../types/Common';\n\n/**\n * Represents the response model for network operations.\n * This class encapsulates details about the HTTP response including status code, headers, data, and errors.\n */\nexport class ResponseModel {\n  private statusCode: number; // HTTP status code of the response\n  private error: dynamic; // Error object if the request failed\n  private headers: Record<string, string>; // Headers received in the response\n  private data: dynamic; // Data payload of the response\n\n  /**\n   * Sets the status code of the response.\n   * @param {number} statusCode - The HTTP status code\n   */\n  setStatusCode(statusCode: number): void {\n    this.statusCode = statusCode;\n  }\n\n  /**\n   * Sets the headers of the response.\n   * @param {Record<string, string>} headers - The headers of the response\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this.headers = headers;\n  }\n\n  /**\n   * Sets the data of the response.\n   * @param {dynamic} data - The data payload of the response\n   */\n  setData(data: dynamic): void {\n    this.data = data;\n  }\n\n  /**\n   * Sets the error object of the response.\n   * @param {dynamic} error - The error object if the request failed\n   */\n  setError(error: dynamic): void {\n    this.error = error;\n  }\n\n  /**\n   * Retrieves the headers of the response.\n   * @returns {Record<string, string>} The headers of the response\n   */\n  getHeaders(): Record<string, string> {\n    return this.headers;\n  }\n\n  /**\n   * Retrieves the data payload of the response.\n   * @returns {dynamic} The data payload of the response\n   */\n  getData(): dynamic {\n    return this.data;\n  }\n\n  /**\n   * Retrieves the status code of the response.\n   * @returns {number} The HTTP status code\n   */\n  getStatusCode(): number {\n    return this.statusCode;\n  }\n\n  /**\n   * Retrieves the error object of the response.\n   * @returns {dynamic} The error object if the request failed\n   */\n  getError(): dynamic {\n    return this.error;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SegmentEvaluator } from '../evaluators/SegmentEvaluator';\nimport { dynamic } from '../../../types/Common';\nimport { SettingsModel } from '../../../models/settings/SettingsModel';\nimport { getFromGatewayService, getQueryParams } from '../../../utils/GatewayServiceUtil';\nimport { UrlEnum } from '../../../enums/UrlEnum';\nimport { LogManager } from '../../logger';\nimport { ContextModel } from '../../../models/user/ContextModel';\nimport { FeatureModel } from '../../../models/campaign/FeatureModel';\nimport { ContextVWOModel } from '../../../models/user/ContextVWOModel';\nimport { SettingsService } from '../../../services/SettingsService';\nimport { isUndefined } from '../../../utils/DataTypeUtil';\n\nexport class SegmentationManager {\n  private static instance: SegmentationManager; // Singleton instance of SegmentationManager\n  evaluator: SegmentEvaluator; // Holds the instance of SegmentEvaluator\n\n  /**\n   * Singleton pattern implementation for getting the instance of SegmentationManager.\n   * @returns {SegmentationManager} The singleton instance.\n   */\n  static get Instance(): SegmentationManager {\n    this.instance = this.instance || new SegmentationManager(); // Create new instance if it doesn't exist\n    return this.instance;\n  }\n\n  /**\n   * Attaches an evaluator to the manager, or creates a new one if none is provided.\n   * @param {SegmentEvaluator} evaluator - Optional evaluator to attach.\n   */\n  attachEvaluator(evaluator?: SegmentEvaluator): void {\n    this.evaluator = evaluator || new SegmentEvaluator(); // Use provided evaluator or create new one\n  }\n\n  /**\n   * Sets the contextual data for the segmentation process.\n   * @param {any} settings - The settings data.\n   * @param {any} feature - The feature data including segmentation needs.\n   * @param {any} context - The context data for the evaluation.\n   */\n  async setContextualData(settings: SettingsModel, feature: FeatureModel, context: ContextModel) {\n    this.attachEvaluator(); // Ensure a fresh evaluator instance\n    this.evaluator.settings = settings; // Set settings in evaluator\n    this.evaluator.context = context; // Set context in evaluator\n    this.evaluator.feature = feature; // Set feature in evaluator\n\n    // if both user agent and ip is null then we should not get data from gateway service\n    if (context?.getUserAgent() === null && context?.getIpAddress() === null) {\n      return;\n    }\n\n    if (feature.getIsGatewayServiceRequired() === true) {\n      if (\n        SettingsService.Instance.isGatewayServiceProvided &&\n        (isUndefined(context.getVwo()) || context.getVwo() === null)\n      ) {\n        const queryParams = {};\n        if (context?.getUserAgent()) {\n          queryParams['userAgent'] = context.getUserAgent();\n        }\n\n        if (context?.getIpAddress()) {\n          queryParams['ipAddress'] = context.getIpAddress();\n        }\n        try {\n          const params = getQueryParams(queryParams);\n          const _vwo = await getFromGatewayService(params, UrlEnum.GET_USER_DATA);\n          context.setVwo(new ContextVWOModel().modelFromDictionary(_vwo));\n        } catch (err) {\n          LogManager.Instance.error(`Error in setting contextual data for segmentation. Got error: ${err.error}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Validates the segmentation against provided DSL and properties.\n   * @param {Record<string, dynamic>} dsl - The segmentation DSL.\n   * @param {Record<any, dynamic>} properties - The properties to validate against.\n   * @param {SettingsModel} settings - The settings model.\n   * @param {any} context - Optional context.\n   * @returns {Promise<boolean>} True if segmentation is valid, otherwise false.\n   */\n  async validateSegmentation(dsl: Record<string, dynamic>, properties: Record<any, dynamic>): Promise<boolean> {\n    return await this.evaluator.isSegmentationValid(dsl, properties); // Delegate to evaluator's method\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SegmentOperandRegexEnum {\n  LOWER = '^lower',\n  LOWER_MATCH = '^lower\\\\((.*)\\\\)',\n  WILDCARD = '^wildcard',\n  WILDCARD_MATCH = '^wildcard\\\\((.*)\\\\)',\n  REGEX = '^regex',\n  REGEX_MATCH = '^regex\\\\((.*)\\\\)',\n  STARTING_STAR = '^\\\\*',\n  ENDING_STAR = '\\\\*$',\n  GREATER_THAN_MATCH = '^gt\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)',\n  GREATER_THAN_EQUAL_TO_MATCH = '^gte\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)',\n  LESS_THAN_MATCH = '^lt\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)',\n  LESS_THAN_EQUAL_TO_MATCH = '^lte\\\\((\\\\d+\\\\.?\\\\d*|\\\\.\\\\d+)\\\\)',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SegmentOperandValueEnum {\n  LOWER_VALUE = 1,\n  STARTING_ENDING_STAR_VALUE = 2,\n  STARTING_STAR_VALUE = 3,\n  ENDING_STAR_VALUE = 4,\n  REGEX_VALUE = 5,\n  EQUAL_VALUE = 6,\n  GREATER_THAN_VALUE = 7,\n  GREATER_THAN_EQUAL_TO_VALUE = 8,\n  LESS_THAN_VALUE = 9,\n  LESS_THAN_EQUAL_TO_VALUE = 10,\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SegmentOperatorValueEnum {\n  AND = 'and',\n  NOT = 'not',\n  OR = 'or',\n  CUSTOM_VARIABLE = 'custom_variable',\n  USER = 'user',\n  COUNTRY = 'country',\n  REGION = 'region',\n  CITY = 'city',\n  OPERATING_SYSTEM = 'os',\n  DEVICE_TYPE = 'device_type',\n  DEVICE = 'device',\n  BROWSER_AGENT = 'browser_string',\n  UA = 'ua',\n  FEATURE_ID = 'featureId',\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { StorageDecorator } from '../../../decorators/StorageDecorator';\nimport { SettingsModel } from '../../../models/settings/SettingsModel';\nimport { LogManager } from '../../logger';\nimport { StorageService } from '../../../services/StorageService';\nimport { dynamic } from '../../../types/Common';\nimport { isObject } from '../../../utils/DataTypeUtil';\nimport { SegmentOperatorValueEnum } from '../enums/SegmentOperatorValueEnum';\nimport { Segmentation } from '../Segmentation';\nimport { getKeyValue } from '../utils/SegmentUtil';\nimport { SegmentOperandEvaluator } from './SegmentOperandEvaluator';\nimport { ContextModel } from '../../../models/user/ContextModel';\nimport { FeatureModel } from '../../../models/campaign/FeatureModel';\n\nexport class SegmentEvaluator implements Segmentation {\n  context: ContextModel;\n  settings: SettingsModel;\n  feature: FeatureModel;\n\n  /**\n   * Validates if the segmentation defined in the DSL is applicable based on the provided properties.\n   * @param dsl The domain-specific language defining the segmentation rules.\n   * @param properties The properties against which the DSL rules are evaluated.\n   * @returns A Promise resolving to a boolean indicating if the segmentation is valid.\n   */\n  async isSegmentationValid(dsl: Record<string, dynamic>, properties: Record<string, dynamic>): Promise<boolean> {\n    const { key, value } = getKeyValue(dsl);\n    const operator = key;\n    const subDsl = value;\n\n    // Evaluate based on the type of segmentation operator\n    switch (operator) {\n      case SegmentOperatorValueEnum.NOT:\n        return !(await this.isSegmentationValid(subDsl, properties));\n      case SegmentOperatorValueEnum.AND:\n        return await this.every(subDsl, properties);\n      case SegmentOperatorValueEnum.OR:\n        return await this.some(subDsl, properties);\n      case SegmentOperatorValueEnum.CUSTOM_VARIABLE:\n        return await new SegmentOperandEvaluator().evaluateCustomVariableDSL(subDsl, properties);\n      case SegmentOperatorValueEnum.USER:\n        return new SegmentOperandEvaluator().evaluateUserDSL(subDsl, properties);\n      case SegmentOperatorValueEnum.UA:\n        return new SegmentOperandEvaluator().evaluateUserAgentDSL(subDsl, this.context);\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Evaluates if any of the DSL nodes are valid using the OR logic.\n   * @param dslNodes Array of DSL nodes to evaluate.\n   * @param customVariables Custom variables provided for evaluation.\n   * @returns A Promise resolving to a boolean indicating if any of the nodes are valid.\n   */\n  async some(dslNodes: Array<Record<string, dynamic>>, customVariables: Record<string, dynamic>): Promise<boolean> {\n    const uaParserMap: Record<string, string[]> = {};\n    let keyCount: number = 0; // Initialize count of keys encountered\n    let isUaParser = false;\n\n    for (const dsl of dslNodes) {\n      for (const key in dsl) {\n        // Check for user agent related keys\n        if (\n          key === SegmentOperatorValueEnum.OPERATING_SYSTEM ||\n          key === SegmentOperatorValueEnum.BROWSER_AGENT ||\n          key === SegmentOperatorValueEnum.DEVICE_TYPE ||\n          key === SegmentOperatorValueEnum.DEVICE\n        ) {\n          isUaParser = true;\n          const value = dsl[key];\n\n          if (!uaParserMap[key]) {\n            uaParserMap[key] = [];\n          }\n\n          // Ensure value is treated as an array of strings\n          const valuesArray = Array.isArray(value) ? value : [value];\n          valuesArray.forEach((val: dynamic) => {\n            if (typeof val === 'string') {\n              uaParserMap[key].push(val);\n            }\n          });\n\n          keyCount++; // Increment count of keys encountered\n        }\n\n        // Check for feature toggle based on feature ID\n        if (key === SegmentOperatorValueEnum.FEATURE_ID) {\n          const featureIdObject = dsl[key] as Record<string, string>;\n          const featureIdKey: string = Object.keys(featureIdObject)[0];\n          const featureIdValue: string = featureIdObject[featureIdKey];\n\n          if (featureIdValue === 'on' || featureIdValue === 'off') {\n            const features = this.settings.getFeatures();\n            const feature = features.find((feature) => feature.getId() === parseInt(featureIdKey));\n\n            if (feature) {\n              const featureKey = feature.getKey();\n              const result = await this.checkInUserStorage(this.settings, featureKey, this.context);\n              // if the result is false, then we need to return true as feature is not present in the user storage\n              if (featureIdValue === 'off') {\n                return !result;\n              }\n              return result;\n            } else {\n              LogManager.Instance.error('Feature not found with featureIdKey: ' + featureIdKey);\n              return null; // Handle the case when feature is not found\n            }\n          }\n        }\n      }\n\n      // Check if the count of keys encountered is equal to dslNodes.length\n      if (isUaParser && keyCount === dslNodes.length) {\n        try {\n          const uaParserResult = await this.checkUserAgentParser(uaParserMap);\n          return uaParserResult;\n        } catch (err) {\n          LogManager.Instance.error('Failed to validate User Agent. Erro: ' + err);\n        }\n      }\n\n      // Recursively check each DSL node\n      if (await this.isSegmentationValid(dsl, customVariables)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Evaluates all DSL nodes using the AND logic.\n   * @param dslNodes Array of DSL nodes to evaluate.\n   * @param customVariables Custom variables provided for evaluation.\n   * @returns A Promise resolving to a boolean indicating if all nodes are valid.\n   */\n  async every(dslNodes: Array<Record<string, dynamic>>, customVariables: Record<string, dynamic>): Promise<boolean> {\n    const locationMap: Record<string, dynamic> = {};\n    for (const dsl of dslNodes) {\n      // Check if the DSL node contains location-related keys\n      if (\n        SegmentOperatorValueEnum.COUNTRY in dsl ||\n        SegmentOperatorValueEnum.REGION in dsl ||\n        SegmentOperatorValueEnum.CITY in dsl\n      ) {\n        this.addLocationValuesToMap(dsl, locationMap);\n        // Check if the number of location keys matches the number of DSL nodes\n        if (Object.keys(locationMap).length === dslNodes.length) {\n          const segmentResult = await this.checkLocationPreSegmentation(locationMap);\n          return segmentResult;\n        }\n        continue;\n      }\n      const res = await this.isSegmentationValid(dsl, customVariables);\n      if (!res) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Adds location values from a DSL node to a map.\n   * @param dsl DSL node containing location data.\n   * @param locationMap Map to store location data.\n   */\n  addLocationValuesToMap(dsl: Record<string, dynamic>, locationMap: Record<string, dynamic>): void {\n    // Add country, region, and city information to the location map if present\n    if (SegmentOperatorValueEnum.COUNTRY in dsl) {\n      locationMap[SegmentOperatorValueEnum.COUNTRY] = dsl[SegmentOperatorValueEnum.COUNTRY];\n    }\n    if (SegmentOperatorValueEnum.REGION in dsl) {\n      locationMap[SegmentOperatorValueEnum.REGION] = dsl[SegmentOperatorValueEnum.REGION];\n    }\n    if (SegmentOperatorValueEnum.CITY in dsl) {\n      locationMap[SegmentOperatorValueEnum.CITY] = dsl[SegmentOperatorValueEnum.CITY];\n    }\n  }\n\n  /**\n   * Checks if the user's location matches the expected location criteria.\n   * @param locationMap Map of expected location values.\n   * @returns A Promise resolving to a boolean indicating if the location matches.\n   */\n  async checkLocationPreSegmentation(locationMap: Record<string, dynamic>): Promise<boolean> {\n    // Ensure user's IP address is available\n    if (this.context?.getIpAddress() === undefined) {\n      LogManager.Instance.error('To evaluate location pre Segment, please pass ipAddress in context object');\n      return false;\n    }\n    // Check if location data is available and matches the expected values\n    if (\n      !this.context?.getVwo()?.getLocation() ||\n      this.context?.getVwo()?.getLocation() === undefined ||\n      this.context?.getVwo()?.getLocation() === null\n    ) {\n      return false;\n    }\n    return this.valuesMatch(locationMap, this.context?.getVwo()?.getLocation());\n  }\n\n  /**\n   * Checks if the user's device information matches the expected criteria.\n   * @param uaParserMap Map of expected user agent values.\n   * @returns A Promise resolving to a boolean indicating if the user agent matches.\n   */\n  async checkUserAgentParser(uaParserMap: Record<string, string[]>): Promise<boolean> {\n    // Ensure user's user agent is available\n    if (!this.context?.getUserAgent() || this.context?.getUserAgent() === undefined) {\n      LogManager.Instance.error('To evaluate user agent related segments, please pass userAgent in context object');\n      return false;\n    }\n    // Check if user agent data is available and matches the expected values\n    if (!this.context?.getVwo()?.getUaInfo() || this.context?.getVwo()?.getUaInfo() === undefined) {\n      return false;\n    }\n\n    return this.checkValuePresent(uaParserMap, this.context?.getVwo()?.getUaInfo());\n  }\n\n  /**\n   * Checks if the feature is enabled for the user by querying the storage.\n   * @param settings The settings model containing configuration.\n   * @param featureKey The key of the feature to check.\n   * @param user The user object to check against.\n   * @returns A Promise resolving to a boolean indicating if the feature is enabled for the user.\n   */\n  async checkInUserStorage(settings: SettingsModel, featureKey: string, context: ContextModel): Promise<any> {\n    const storageService = new StorageService();\n    // Retrieve feature data from storage\n    const storedData: Record<any, any> = await new StorageDecorator().getFeatureFromStorage(\n      featureKey,\n      context,\n      storageService,\n    );\n\n    // Check if the stored data is an object and not empty\n    if (isObject(storedData) && Object.keys(storedData).length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Checks if the actual values match the expected values specified in the map.\n   * @param expectedMap A map of expected values for different keys.\n   * @param actualMap A map of actual values to compare against.\n   * @returns A Promise resolving to a boolean indicating if all actual values match the expected values.\n   */\n  async checkValuePresent(expectedMap: Record<string, string[]>, actualMap: Record<string, string>): Promise<boolean> {\n    for (const key in actualMap) {\n      if (Object.prototype.hasOwnProperty.call(expectedMap, key)) {\n        const expectedValues = expectedMap[key];\n        // convert expected values to lowercase\n        expectedValues.forEach((value, index) => {\n          expectedValues[index] = value.toLowerCase();\n        });\n        const actualValue = actualMap[key];\n\n        // Handle wildcard patterns for all keys\n        for (const val of expectedValues) {\n          // Check if the value is a wildcard pattern and matches the actual value using regex\n          if (val.startsWith('wildcard(') && val.endsWith(')')) {\n            // Extract pattern from wildcard string\n            const wildcardPattern = val.slice(9, -1);\n            // Convert wildcard pattern to regex and check if it matches the actual value\n            const regex = new RegExp(wildcardPattern.replace(/\\*/g, '.*'), 'i'); // Convert wildcard pattern to regex, 'i' for case-insensitive\n            // Check if the actual value matches the regex pattern for the key\n            if (regex.test(actualValue)) {\n              // match found, return true as we only need to check if any of the expected values match the actual value\n              return true;\n            }\n          }\n        }\n\n        // this will be checked for all cases where wildcard is not present\n        if (expectedValues.includes(actualValue?.toLowerCase())) {\n          return true; // Direct value match found, return true\n        }\n      }\n    }\n    return false; // No matches found\n  }\n\n  /**\n   * Compares expected location values with user's location to determine a match.\n   * @param expectedLocationMap A map of expected location values.\n   * @param userLocation The user's actual location.\n   * @returns A boolean indicating if the user's location matches the expected values.\n   */\n  async valuesMatch(expectedLocationMap, userLocation) {\n    for (const [key, value] of Object.entries(expectedLocationMap)) {\n      if (key in userLocation) {\n        const normalizedValue1 = this.normalizeValue(value);\n        const normalizedValue2 = this.normalizeValue(userLocation[key]);\n        if (normalizedValue1 !== normalizedValue2) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    return true; // If all values match, return true\n  }\n\n  /**\n   * Normalizes a value to a consistent format for comparison.\n   * @param value The value to normalize.\n   * @returns The normalized value.\n   */\n  normalizeValue(value) {\n    if (value === null || value === undefined) {\n      return null;\n    }\n    // Remove quotes and trim whitespace\n    return value.toString().replace(/^\"|\"$/g, '').trim();\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getKeyValue, matchWithRegex } from '../utils/SegmentUtil';\nimport { SegmentOperandValueEnum } from '../enums/SegmentOperandValueEnum';\nimport { SegmentOperandRegexEnum } from '../enums/SegmentOperandRegexEnum';\nimport { isBoolean } from '../../../utils/DataTypeUtil';\nimport { dynamic } from '../../../types/Common';\nimport { getFromGatewayService } from '../../../utils/GatewayServiceUtil';\nimport { UrlEnum } from '../../../enums/UrlEnum';\nimport { LogManager } from '../../logger';\nimport { ContextModel } from '../../../models/user/ContextModel';\n\n/**\n * SegmentOperandEvaluator class provides methods to evaluate different types of DSL (Domain Specific Language)\n * expressions based on the segment conditions defined for custom variables, user IDs, and user agents.\n */\nexport class SegmentOperandEvaluator {\n  /**\n   * Evaluates a custom variable DSL expression.\n   * @param {Record<string, dynamic>} dslOperandValue - The DSL expression for the custom variable.\n   * @param {Record<string, dynamic>} properties - The properties object containing the actual values to be matched against.\n   * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating if the DSL condition is met.\n   */\n  async evaluateCustomVariableDSL(\n    dslOperandValue: Record<string, dynamic>,\n    properties: Record<string, dynamic>,\n  ): Promise<boolean> {\n    // Extract key and value from the DSL operand\n    const { key, value } = getKeyValue(dslOperandValue);\n    const operandKey = key;\n    const operand = value;\n\n    // Check if the property exists\n    if (!Object.prototype.hasOwnProperty.call(properties, operandKey)) {\n      return false;\n    }\n\n    // Handle 'inlist' operand\n    if (operand.includes('inlist')) {\n      const listIdRegex = /inlist\\(([^:]+)\\)/;\n      const match = operand.match(listIdRegex);\n      if (!match || match.length < 2) {\n        LogManager.Instance.error(\"Invalid 'inList' operand format\");\n        return false;\n      }\n\n      // Process the tag value and prepare query parameters\n      const tagValue = properties[operandKey];\n      const attributeValue = this.preProcessTagValue(tagValue);\n      const listId = match[1];\n      const queryParamsObj = {\n        attribute: attributeValue,\n        listId: listId,\n      };\n\n      // Make a web service call to check the attribute against the list\n      try {\n        const res = await getFromGatewayService(queryParamsObj, UrlEnum.ATTRIBUTE_CHECK);\n        if (!res || res === undefined || res === 'false' || res.status === 0) {\n          return false;\n        }\n        return res;\n      } catch (error) {\n        LogManager.Instance.error('Error while fetching data: ' + error);\n        return false;\n      }\n    } else {\n      // Process other types of operands\n      let tagValue = properties[operandKey];\n      tagValue = this.preProcessTagValue(tagValue);\n      const { operandType, operandValue } = this.preProcessOperandValue(operand);\n      const processedValues = this.processValues(operandValue, tagValue);\n      tagValue = processedValues.tagValue;\n      return this.extractResult(operandType, processedValues.operandValue, tagValue);\n    }\n  }\n\n  /**\n   * Evaluates a user DSL expression to check if a user ID is in a specified list.\n   * @param {Record<string, any>} dslOperandValue - The DSL expression containing user IDs.\n   * @param {Record<string, dynamic>} properties - The properties object containing the actual user ID to check.\n   * @returns {boolean} - True if the user ID is in the list, otherwise false.\n   */\n  evaluateUserDSL(dslOperandValue: Record<string, any>, properties: Record<string, dynamic>): boolean {\n    const users = dslOperandValue.split(',');\n    for (let i = 0; i < users.length; i++) {\n      if (users[i].trim() == properties._vwoUserId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Evaluates a user agent DSL expression.\n   * @param {Record<string, any>} dslOperandValue - The DSL expression for the user agent.\n   * @param {any} context - The context object containing the user agent string.\n   * @returns {boolean} - True if the user agent matches the DSL condition, otherwise false.\n   */\n  evaluateUserAgentDSL(dslOperandValue: Record<string, any>, context: ContextModel): boolean {\n    const operand = dslOperandValue;\n    if (!context.getUserAgent() || context.getUserAgent() === undefined) {\n      LogManager.Instance.info('To Evaluate UserAgent segmentation, please provide userAgent in context');\n      return false;\n    }\n    let tagValue = decodeURIComponent(context.getUserAgent());\n    const { operandType, operandValue } = this.preProcessOperandValue(operand);\n    const processedValues = this.processValues(operandValue, tagValue);\n    tagValue = processedValues.tagValue as string; // Fix: Type assertion to ensure tagValue is of type string\n    return this.extractResult(operandType, processedValues.operandValue, tagValue);\n  }\n\n  /**\n   * Pre-processes the tag value to ensure it is in the correct format for evaluation.\n   * @param {any} tagValue - The value to be processed.\n   * @returns {string | boolean} - The processed tag value, either as a string or a boolean.\n   */\n  preProcessTagValue(tagValue: any): string | boolean {\n    // Default to empty string if undefined\n    if (tagValue === undefined) {\n      tagValue = '';\n    }\n    // Convert boolean values to boolean type\n    if (isBoolean(tagValue)) {\n      tagValue = tagValue ? true : false;\n    }\n    // Convert all non-null values to string\n    if (tagValue !== null) {\n      tagValue = tagValue.toString();\n    }\n    return tagValue;\n  }\n\n  /**\n   * Pre-processes the operand value to determine its type and extract the value based on regex matches.\n   * @param {any} operand - The operand to be processed.\n   * @returns {Record<string, any>} - An object containing the operand type and value.\n   */\n  preProcessOperandValue(operand: any): Record<string, any> {\n    let operandType: SegmentOperandValueEnum;\n    let operandValue: dynamic;\n    // Determine the type of operand and extract value based on regex patterns\n    if (matchWithRegex(operand, SegmentOperandRegexEnum.LOWER_MATCH)) {\n      operandType = SegmentOperandValueEnum.LOWER_VALUE;\n      operandValue = this.extractOperandValue(operand, SegmentOperandRegexEnum.LOWER_MATCH);\n    } else if (matchWithRegex(operand, SegmentOperandRegexEnum.WILDCARD_MATCH)) {\n      operandValue = this.extractOperandValue(operand, SegmentOperandRegexEnum.WILDCARD_MATCH);\n      const startingStar = matchWithRegex(operandValue, SegmentOperandRegexEnum.STARTING_STAR);\n      const endingStar = matchWithRegex(operandValue, SegmentOperandRegexEnum.ENDING_STAR);\n      // Determine specific wildcard type\n      if (startingStar && endingStar) {\n        operandType = SegmentOperandValueEnum.STARTING_ENDING_STAR_VALUE;\n      } else if (startingStar) {\n        operandType = SegmentOperandValueEnum.STARTING_STAR_VALUE;\n      } else if (endingStar) {\n        operandType = SegmentOperandValueEnum.ENDING_STAR_VALUE;\n      }\n      // Remove wildcard characters from the operand value\n      operandValue = operandValue\n        .replace(new RegExp(SegmentOperandRegexEnum.STARTING_STAR), '')\n        .replace(new RegExp(SegmentOperandRegexEnum.ENDING_STAR), '');\n    } else if (matchWithRegex(operand, SegmentOperandRegexEnum.REGEX_MATCH)) {\n      operandType = SegmentOperandValueEnum.REGEX_VALUE;\n      operandValue = this.extractOperandValue(operand, SegmentOperandRegexEnum.REGEX_MATCH);\n    } else if (matchWithRegex(operand, SegmentOperandRegexEnum.GREATER_THAN_MATCH)) {\n      operandType = SegmentOperandValueEnum.GREATER_THAN_VALUE;\n      operandValue = this.extractOperandValue(operand, SegmentOperandRegexEnum.GREATER_THAN_MATCH);\n    } else if (matchWithRegex(operand, SegmentOperandRegexEnum.GREATER_THAN_EQUAL_TO_MATCH)) {\n      operandType = SegmentOperandValueEnum.GREATER_THAN_EQUAL_TO_VALUE;\n      operandValue = this.extractOperandValue(operand, SegmentOperandRegexEnum.GREATER_THAN_EQUAL_TO_MATCH);\n    } else if (matchWithRegex(operand, SegmentOperandRegexEnum.LESS_THAN_MATCH)) {\n      operandType = SegmentOperandValueEnum.LESS_THAN_VALUE;\n      operandValue = this.extractOperandValue(operand, SegmentOperandRegexEnum.LESS_THAN_MATCH);\n    } else if (matchWithRegex(operand, SegmentOperandRegexEnum.LESS_THAN_EQUAL_TO_MATCH)) {\n      operandType = SegmentOperandValueEnum.LESS_THAN_EQUAL_TO_VALUE;\n      operandValue = this.extractOperandValue(operand, SegmentOperandRegexEnum.LESS_THAN_EQUAL_TO_MATCH);\n    } else {\n      operandType = SegmentOperandValueEnum.EQUAL_VALUE;\n      operandValue = operand;\n    }\n    return {\n      operandType,\n      operandValue,\n    };\n  }\n\n  /**\n   * Extracts the operand value from a string based on a specified regex pattern.\n   * @param {any} operand - The operand string to extract from.\n   * @param {string} regex - The regex pattern to use for extraction.\n   * @returns {string} - The extracted value.\n   */\n  extractOperandValue(operand: any, regex: string): string {\n    // Match operand with regex and return the first capturing group\n    return matchWithRegex(operand, regex) && matchWithRegex(operand, regex)[1];\n  }\n\n  /**\n   * Processes numeric values from operand and tag values, converting them to strings.\n   * @param {any} operandValue - The operand value to process.\n   * @param {any} tagValue - The tag value to process.\n   * @returns {Record<string, dynamic>} - An object containing the processed operand and tag values as strings.\n   */\n  processValues(operandValue: any, tagValue: any): Record<string, dynamic> {\n    // Convert operand and tag values to floats\n    const processedOperandValue = parseFloat(operandValue);\n    const processedTagValue = parseFloat(tagValue);\n    // Return original values if conversion fails\n    if (!processedOperandValue || !processedTagValue) {\n      return {\n        operandValue: operandValue,\n        tagValue: tagValue,\n      };\n    }\n    // now we have surity that both are numbers\n    // now we can convert them independently to int type if they\n    // are int rather than floats\n    // if (processedOperandValue === Math.floor(processedOperandValue)) {\n    //   processedOperandValue = parseInt(processedOperandValue, 10);\n    // }\n    // if (processedTagValue === Math.floor(processedTagValue)) {\n    //   processedTagValue = parseInt(processedTagValue, 10);\n    // }\n    // Convert numeric values back to strings\n    return {\n      operandValue: processedOperandValue.toString(),\n      tagValue: processedTagValue.toString(),\n    };\n  }\n\n  /**\n   * Extracts the result of the evaluation based on the operand type and values.\n   * @param {SegmentOperandValueEnum} operandType - The type of the operand.\n   * @param {any} operandValue - The value of the operand.\n   * @param {any} tagValue - The value of the tag to compare against.\n   * @returns {boolean} - The result of the evaluation.\n   */\n  extractResult(operandType: SegmentOperandValueEnum, operandValue: any, tagValue: any): boolean {\n    let result: boolean;\n\n    switch (operandType) {\n      case SegmentOperandValueEnum.LOWER_VALUE:\n        // Check if both values are equal, ignoring case\n        if (tagValue !== null) {\n          result = operandValue.toLowerCase() === tagValue.toLowerCase();\n        }\n        break;\n      case SegmentOperandValueEnum.STARTING_ENDING_STAR_VALUE:\n        // Check if the tagValue contains the operandValue\n        if (tagValue !== null) {\n          result = tagValue.indexOf(operandValue) > -1;\n        }\n        break;\n      case SegmentOperandValueEnum.STARTING_STAR_VALUE:\n        // Check if the tagValue ends with the operandValue\n        if (tagValue !== null) {\n          result = tagValue.endsWith(operandValue);\n        }\n        break;\n      case SegmentOperandValueEnum.ENDING_STAR_VALUE:\n        // Check if the tagValue starts with the operandValue\n        if (tagValue !== null) {\n          result = tagValue.startsWith(operandValue);\n        }\n        break;\n      case SegmentOperandValueEnum.REGEX_VALUE:\n        // Evaluate the tagValue against the regex pattern of operandValue\n        try {\n          const pattern = new RegExp(operandValue, 'g');\n          result = !!pattern.test(tagValue);\n        } catch (err) {\n          result = false;\n        }\n        break;\n      case SegmentOperandValueEnum.GREATER_THAN_VALUE:\n        if (tagValue !== null) {\n          try {\n            result = parseFloat(operandValue) < parseFloat(tagValue);\n          } catch (err) {\n            result = false;\n          }\n        }\n        break;\n      case SegmentOperandValueEnum.GREATER_THAN_EQUAL_TO_VALUE:\n        if (tagValue !== null) {\n          try {\n            result = parseFloat(operandValue) <= parseFloat(tagValue);\n          } catch (err) {\n            result = false;\n          }\n        }\n        break;\n      case SegmentOperandValueEnum.LESS_THAN_VALUE:\n        if (tagValue !== null) {\n          try {\n            result = parseFloat(operandValue) > parseFloat(tagValue);\n          } catch (err) {\n            result = false;\n          }\n        }\n        break;\n      case SegmentOperandValueEnum.LESS_THAN_EQUAL_TO_VALUE:\n        if (tagValue !== null) {\n          try {\n            result = parseFloat(operandValue) >= parseFloat(tagValue);\n          } catch (err) {\n            result = false;\n          }\n        }\n        break;\n      default:\n        // Check if the tagValue is exactly equal to the operandValue\n        result = tagValue === operandValue;\n    }\n\n    return result;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { SegmentationManager } from './core/SegmentationManger';\nexport { SegmentEvaluator } from './evaluators/SegmentEvaluator';\nexport { Segmentation } from './Segmentation';\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isObject } from '../../../utils/DataTypeUtil';\n\n/**\n * Extracts the first key-value pair from the provided object.\n * @param {Record<string, any>} obj - The object from which to extract the key-value pair.\n * @returns {Record<string, any> | undefined} An object containing the first key and value, or undefined if input is not an object.\n */\nexport function getKeyValue(obj: Record<string, any>): Record<string, any> | undefined {\n  // Check if the input is a valid object using isObject utility function\n  if (!isObject(obj)) {\n    return;\n  }\n\n  // Extract the first key from the object\n  const key = Object.keys(obj)[0];\n  // Retrieve the value associated with the first key\n  const value = obj[key];\n  // Return an object containing the key and value\n  return {\n    key,\n    value,\n  };\n}\n\n/**\n * Matches a string against a regular expression and returns the match result.\n * @param {string} string - The string to match against the regex.\n * @param {string} regex - The regex pattern as a string.\n * @returns {RegExpMatchArray | null} The results of the regex match, or null if an error occurs.\n */\nexport function matchWithRegex(string: string, regex: string): RegExpMatchArray | null {\n  try {\n    // Attempt to match the string with the regex\n    return string.match(new RegExp(regex));\n  } catch (err) {\n    // Return null if an error occurs during regex matching\n    return null;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../../types/Common';\n\nexport abstract class Connector {\n  // abstract connect(_config: Record<string, dynamic>): this;\n\n  abstract set(_key: string, _data: dynamic): void | Promise<dynamic>;\n\n  abstract get(_key: string): this | Promise<dynamic>;\n\n  // abstract getAll(): Record<string, dynamic> | Promise<Array<Record<string, dynamic>>>;\n\n  // abstract getKeys(): string[] | Promise<dynamic>;\n\n  // abstract has(_key: string): boolean | Promise<dynamic>;\n\n  // abstract hasData(): boolean | Promise<dynamic>;\n\n  // abstract update(_key: string, _data: dynamic, ttl: number): Promise<dynamic>;\n\n  // abstract remove(_key: string): this | Promise<dynamic>;\n\n  // abstract clear(): this | Promise<dynamic>;\n\n  // abstract close(): this; // TODO: stop\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Connector } from './Connector';\n\n// TODO: move to file\n// enum ConnectorEnum {\n//   MEMORY = 'memory',\n//   REDIS = 'redis'\n// }\n\nexport class Storage {\n  public static instance: Storage;\n  public connector: Connector | Record<any, any>; // RedisConnector |\n  // public storageType: dynamic;\n\n  public attachConnector(connector: any): any {\n    if (connector?.prototype?.constructor?.toString()?.trim()?.substring(0, 5) === 'class') {\n      this.connector = new connector();\n    } else {\n      this.connector = connector;\n    }\n\n    return this.connector;\n  }\n\n  public static get Instance(): Storage {\n    this.instance = this.instance || new Storage();\n\n    return this.instance;\n  }\n\n  public getConnector(): any {\n    return this.connector;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { Storage } from './Storage';\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DecisionMaker } from '../packages/decision-maker';\nimport { LogManager } from '../packages/logger';\nimport { SegmentationManager } from '../packages/segmentation-evaluator';\n\nimport { Constants } from '../constants';\nimport { VariationModel } from '../models/campaign/VariationModel';\n\nimport { CampaignTypeEnum } from '../enums/CampaignTypeEnum';\nimport { DebugLogMessagesEnum, InfoLogMessagesEnum } from '../enums/log-messages';\nimport { CampaignModel } from '../models/campaign/CampaignModel';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { isObject } from '../utils/DataTypeUtil';\nimport { buildMessage } from '../utils/LogMessageUtil';\n\ninterface ICampaignDecisionService {\n  isUserPartOfCampaign(userId: any, campaign: CampaignModel): boolean;\n  getVariation(variations: Array<VariationModel>, bucketValue: number): VariationModel;\n  checkInRange(variation: VariationModel, bucketValue: number): VariationModel;\n  bucketUserToVariation(userId: any, accountId: any, campaign: CampaignModel): VariationModel;\n  getPreSegmentationDecision(campaign: CampaignModel, context: ContextModel): Promise<any>;\n  getVariationAlloted(userId: any, accountId: any, campaign: CampaignModel): VariationModel;\n}\n\nexport class CampaignDecisionService implements ICampaignDecisionService {\n  /**\n   * Calculate if this user should become part of the campaign or not\n   *\n   * @param {String} userId the unique ID assigned to a user\n   * @param {Object} campaign fot getting the value of traffic allotted to the campaign\n   *\n   * @return {Boolean} if User is a part of Campaign or not\n   */\n  isUserPartOfCampaign(userId: any, campaign: CampaignModel): boolean {\n    // if (!ValidateUtil.isValidValue(userId) || !campaign) {\n    //   return false;\n    // }\n\n    if (!campaign || !userId) {\n      return false;\n    }\n    let trafficAllocation;\n    if (campaign.getType() === CampaignTypeEnum.ROLLOUT || campaign.getType() === CampaignTypeEnum.PERSONALIZE) {\n      trafficAllocation = campaign.getVariations()[0].getWeight();\n    } else {\n      trafficAllocation = campaign.getTraffic();\n    }\n    const valueAssignedToUser = new DecisionMaker().getBucketValueForUser(`${campaign.getId()}_${userId}`);\n    const isUserPart = valueAssignedToUser !== 0 && valueAssignedToUser <= trafficAllocation;\n\n    LogManager.Instance.info(\n      buildMessage(InfoLogMessagesEnum.USER_PART_OF_CAMPAIGN, {\n        userId,\n        notPart: isUserPart ? '' : 'not',\n        campaignKey: campaign.getKey(),\n      }),\n    );\n\n    return isUserPart;\n  }\n\n  /**\n   * Returns the Variation by checking the Start and End Bucket Allocations of each Variation\n   *\n   * @param {Object} campaign which contains the variations\n   * @param {Number} bucketValue the bucket Value of the user\n   *\n   * @return {Object|null} variation data allotted to the user or null if not\n   */\n  getVariation(variations: Array<VariationModel>, bucketValue: number): VariationModel {\n    for (let i = 0; i < variations.length; i++) {\n      const variation = variations[i];\n      if (bucketValue >= variation.getStartRangeVariation() && bucketValue <= variation.getEndRangeVariation()) {\n        return variation;\n      }\n    }\n\n    return null;\n  }\n\n  checkInRange(variation: VariationModel, bucketValue: number): VariationModel {\n    if (bucketValue >= variation.getStartRangeVariation() && bucketValue <= variation.getEndRangeVariation()) {\n      return variation;\n    }\n  }\n\n  /**\n   * Validates the User ID and generates Variation into which the User is bucketed in.\n   *\n   * @param {String} userId the unique ID assigned to User\n   * @param {Object} campaign the Campaign of which User is a part of\n   *\n   * @return {Object|null} variation data into which user is bucketed in or null if not\n   */\n  bucketUserToVariation(userId: any, accountId: any, campaign: CampaignModel): VariationModel {\n    let multiplier;\n\n    if (!campaign || !userId) {\n      return null;\n    }\n\n    if (campaign.getTraffic()) {\n      multiplier = 1;\n    }\n\n    const percentTraffic = campaign.getTraffic();\n    const hashValue = new DecisionMaker().generateHashValue(`${campaign.getId()}_${accountId}_${userId}`);\n    const bucketValue = new DecisionMaker().generateBucketValue(hashValue, Constants.MAX_TRAFFIC_VALUE, multiplier);\n\n    LogManager.Instance.debug(\n      buildMessage(DebugLogMessagesEnum.USER_BUCKET_TO_VARIATION, {\n        userId,\n        campaignKey: campaign.getKey(),\n        percentTraffic,\n        bucketValue,\n        hashValue,\n      }),\n    );\n\n    return this.getVariation(campaign.getVariations(), bucketValue);\n  }\n\n  async getPreSegmentationDecision(campaign: CampaignModel, context: ContextModel): Promise<boolean> {\n    // validate segmentation\n    const campaignType = campaign.getType();\n    let segments = {};\n\n    if (campaignType === CampaignTypeEnum.ROLLOUT || campaignType === CampaignTypeEnum.PERSONALIZE) {\n      segments = campaign.getVariations()[0].getSegments();\n    } else if (campaignType === CampaignTypeEnum.AB) {\n      segments = campaign.getSegments();\n    }\n    if (isObject(segments) && !Object.keys(segments).length) {\n      LogManager.Instance.info(\n        buildMessage(InfoLogMessagesEnum.SEGMENTATION_SKIP, {\n          userId: context.getId(),\n          campaignKey: campaign.getRuleKey(),\n        }),\n      );\n\n      return true;\n    } else {\n      const preSegmentationResult = await SegmentationManager.Instance.validateSegmentation(\n        segments,\n        context.getCustomVariables(),\n      );\n\n      if (!preSegmentationResult) {\n        LogManager.Instance.info(\n          buildMessage(InfoLogMessagesEnum.SEGMENTATION_STATUS, {\n            userId: context.getId(),\n            campaignKey: campaign.getRuleKey(),\n            status: 'failed',\n          }),\n        );\n\n        return false;\n      }\n\n      LogManager.Instance.info(\n        buildMessage(InfoLogMessagesEnum.SEGMENTATION_STATUS, {\n          userId: context.getId(),\n          campaignKey: campaign.getRuleKey(),\n          status: 'passed',\n        }),\n      );\n\n      return true;\n    }\n  }\n\n  getVariationAlloted(userId: any, accountId: any, campaign: CampaignModel): VariationModel {\n    const isUserPart = this.isUserPartOfCampaign(userId, campaign);\n    if (campaign.getType() === CampaignTypeEnum.ROLLOUT || campaign.getType() === CampaignTypeEnum.PERSONALIZE) {\n      if (isUserPart) {\n        return campaign.getVariations()[0];\n      } else {\n        return null;\n      }\n    } else {\n      if (isUserPart) {\n        return this.bucketUserToVariation(userId, accountId, campaign);\n      } else {\n        return null;\n      }\n    }\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { IVWOOptions } from '../models/VWOOptionsModel';\nimport { isFunction } from '../utils/DataTypeUtil';\n\nexport interface IHooksService {\n  execute(properties: Record<string, any>): void;\n  set(properties: Record<string, any>): void;\n  get(): Record<string, any>;\n}\nclass HooksService implements IHooksService {\n  private callback: ((properties: Record<string, any>) => void) | undefined;\n  private isCallBackFunction: boolean;\n  private decision: Record<string, any>;\n\n  constructor(options: IVWOOptions) {\n    this.callback = options.integrations?.callback;\n    this.isCallBackFunction = isFunction(this.callback);\n    this.decision = {};\n  }\n\n  /**\n   * Executes the callback\n   * @param {Record<string, any>} properties Properties from the callback\n   */\n  execute(properties: Record<string, any>): void {\n    if (this.isCallBackFunction) {\n      this.callback(properties);\n    }\n  }\n\n  /**\n   * Sets properties to the decision object\n   * @param {Record<string, any>} properties Properties to set\n   */\n  set(properties: Record<string, any>): void {\n    if (this.isCallBackFunction) {\n      this.decision = properties;\n    }\n  }\n\n  /**\n   * Retrieves the decision object\n   * @returns {Record<string, any>} The decision object\n   */\n  get(): Record<string, any> {\n    return this.decision;\n  }\n}\n\nexport default HooksService;\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../types/Common';\n\nimport { LogManager } from '../packages/logger';\nimport { NetworkManager, RequestModel, ResponseModel } from '../packages/network-layer';\n\nimport { Deferred } from '../utils/PromiseUtil';\n\nimport { Constants } from '../constants';\nimport { HTTPS_PROTOCOL, HTTP_PROTOCOL } from '../constants/Url';\nimport { HttpMethodEnum } from '../enums/HttpMethodEnum';\nimport { DebugLogMessagesEnum, ErrorLogMessagesEnum, InfoLogMessagesEnum } from '../enums/log-messages';\nimport { SettingsSchema } from '../models/schemas/SettingsSchemaValidation';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { buildMessage } from '../utils/LogMessageUtil';\nimport { getSettingsPath } from '../utils/NetworkUtil';\n\ninterface ISettingsService {\n  sdkKey: string;\n\n  getSettings(forceFetch: boolean): Promise<dynamic>;\n\n  fetchSettings(): Promise<dynamic>;\n}\n\nexport class SettingsService implements ISettingsService {\n  sdkKey: string;\n  accountId: number;\n  expiry: number;\n  networkTimeout: number;\n  hostname: string;\n  port: number;\n  protocol: string;\n  isGatewayServiceProvided: boolean = false;\n  private static instance: SettingsService;\n\n  constructor(options: Record<string, any>) {\n    this.sdkKey = options.sdkKey;\n    this.accountId = options.accountId;\n    this.expiry = options?.settings?.expiry || Constants.SETTINGS_EXPIRY;\n    this.networkTimeout = options?.settings?.timeout || Constants.SETTINGS_TIMEOUT;\n\n    if (options?.gatewayService?.url) {\n      let parsedUrl;\n      this.isGatewayServiceProvided = true;\n      if (\n        options.gatewayService.url.startsWith(HTTP_PROTOCOL) ||\n        options.gatewayService.url.startsWith(HTTPS_PROTOCOL)\n      ) {\n        parsedUrl = new URL(`${options.gatewayService.url}`);\n      } else if (options.gatewayService?.protocol) {\n        parsedUrl = new URL(`${options.gatewayService.protocol}://${options.gatewayService.url}`);\n      } else {\n        parsedUrl = new URL(`${HTTPS_PROTOCOL}${options.gatewayService.url}`);\n      }\n      this.hostname = parsedUrl.hostname;\n      this.protocol = parsedUrl.protocol.replace(':', '');\n      if (parsedUrl.port) {\n        this.port = parseInt(parsedUrl.port);\n      } else if (options.gatewayService?.port) {\n        this.port = options.gatewayService.port;\n      }\n    } else {\n      this.hostname = Constants.HOST_NAME;\n    }\n\n    // if (this.expiry > 0) {\n    //   this.setSettingsExpiry();\n    // }\n    LogManager.Instance.debug(\n      buildMessage(DebugLogMessagesEnum.SERVICE_INITIALIZED, {\n        service: 'Settings Manager',\n      }),\n    );\n    SettingsService.instance = this;\n  }\n\n  static get Instance(): SettingsService {\n    return SettingsService.instance;\n  }\n\n  private setSettingsExpiry() {\n    const settingsTimeout = setTimeout(() => {\n      this.fetchSettingsAndCacheInStorage().then(() => {\n        clearTimeout(settingsTimeout);\n        // again set the timer\n        // NOTE: setInterval could be used but it will not consider the time required to fetch settings\n        // This breaks the timer rythm and also sends more call than required\n        this.setSettingsExpiry();\n      });\n    }, this.expiry);\n  }\n\n  private fetchSettingsAndCacheInStorage() {\n    const deferredObject = new Deferred();\n    // const storageConnector = Storage.Instance.getConnector();\n\n    this.fetchSettings()\n      .then(async (res) => {\n        // LogManager.Instance.info('Settings fetched successfully');\n\n        // const method = update ? 'update' : 'set';\n\n        // storageConnector[method](Constants.SETTINGS, res).then(() => {\n        //   LogManager.Instance.info('Settings persisted in cache: memory');\n        //   deferredObject.resolve(res);\n        // });\n        deferredObject.resolve(res);\n      })\n      .catch((err) => {\n        LogManager.Instance.error(\n          buildMessage(ErrorLogMessagesEnum.SETTINGS_FETCH_ERROR, {\n            err: JSON.stringify(err),\n          }),\n        );\n\n        deferredObject.resolve(null);\n      });\n\n    return deferredObject.promise;\n  }\n\n  fetchSettings(): Promise<SettingsModel> {\n    const deferredObject = new Deferred();\n\n    if (!this.sdkKey || !this.accountId) {\n      deferredObject.reject(new Error('sdkKey is required for fetching account settings. Aborting!'));\n    }\n\n    const networkInstance = NetworkManager.Instance;\n    const options: Record<string, dynamic> = getSettingsPath(this.sdkKey, this.accountId);\n\n    options.platform = Constants.PLATFORM;\n    options['api-version'] = Constants.API_VERSION;\n\n    if (!networkInstance.getConfig().getDevelopmentMode()) {\n      options.s = 'prod';\n    }\n\n    try {\n      const request: RequestModel = new RequestModel(\n        this.hostname,\n        HttpMethodEnum.GET,\n        Constants.SETTINTS_ENDPOINT,\n        options,\n        null,\n        null,\n        this.protocol,\n        this.port,\n      );\n      request.setTimeout(this.networkTimeout);\n\n      networkInstance\n        .get(request)\n        .then((response: ResponseModel) => {\n          deferredObject.resolve(response.getData());\n        })\n        .catch((err: ResponseModel) => {\n          deferredObject.reject(err);\n        });\n\n      return deferredObject.promise;\n    } catch (err) {\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.SETTINGS_FETCH_ERROR, {\n          err: JSON.stringify(err),\n        }),\n      );\n\n      deferredObject.reject(err);\n      return deferredObject.promise;\n    }\n  }\n\n  getSettings(forceFetch = false): Promise<SettingsModel> {\n    const deferredObject = new Deferred();\n\n    if (forceFetch) {\n      this.fetchSettingsAndCacheInStorage().then((settings) => {\n        deferredObject.resolve(settings);\n      });\n    } else {\n      // const storageConnector = Storage.Instance.getConnector();\n\n      // if (storageConnector) {\n      //   storageConnector\n      //     .get(Constants.SETTINGS)\n      //     .then((storedSettings: dynamic) => {\n      //       if (!isObject(storedSettings)) {\n      //         this.fetchSettingsAndCacheInStorage().then((fetchedSettings) => {\n      //           const isSettingsValid = new SettingsSchema().isSettingsValid(fetchedSettings);\n      //           if (isSettingsValid) {\n      //             deferredObject.resolve(fetchedSettings);\n      //           } else {\n      //             deferredObject.reject(new Error('Settings are not valid. Failed schema validation.'));\n      //           }\n      //         });\n      //       } else {\n      //         deferredObject.resolve(storedSettings);\n      //       }\n      //     })\n      //     .catch(() => {\n      //       this.fetchSettingsAndCacheInStorage().then((fetchedSettings) => {\n      //         deferredObject.resolve(fetchedSettings);\n      //       });\n      //     });\n      // } else {\n      this.fetchSettingsAndCacheInStorage().then((fetchedSettings) => {\n        const isSettingsValid = new SettingsSchema().isSettingsValid(fetchedSettings);\n        if (isSettingsValid) {\n          LogManager.Instance.info(InfoLogMessagesEnum.SETTINGS_FETCH_SUCCESS);\n\n          deferredObject.resolve(fetchedSettings);\n        } else {\n          LogManager.Instance.error(ErrorLogMessagesEnum.SETTINGS_SCHEMA_INVALID);\n\n          deferredObject.resolve({});\n        }\n      });\n      // }\n    }\n\n    return deferredObject.promise;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { StorageEnum } from '../enums/StorageEnum';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { Storage } from '../packages/storage';\nimport { dynamic } from '../types/Common';\n\nimport { ErrorLogMessagesEnum } from '../enums/log-messages';\nimport { LogManager } from '../packages/logger';\nimport { isNull, isUndefined } from '../utils/DataTypeUtil';\nimport { buildMessage } from '../utils/LogMessageUtil';\nimport { Deferred } from '../utils/PromiseUtil';\n\nexport interface IStorageService {\n  getDataInStorage(featureKey: any, context: ContextModel): Promise<Record<any, any>>;\n  setDataInStorage(data: Record<any, any>): Promise<void>;\n}\nexport class StorageService implements IStorageService {\n  private storageData: Record<string, dynamic> = {};\n\n  /**\n   * Retrieves data from storage based on the feature key and user ID.\n   * @param featureKey The key to identify the feature data.\n   * @param user The user object containing at least an ID.\n   * @returns A promise that resolves to the data retrieved or an error/storage status enum.\n   */\n  async getDataInStorage(featureKey: any, context: ContextModel): Promise<Record<any, any>> {\n    const deferredObject = new Deferred();\n    const storageInstance = Storage.Instance.getConnector();\n\n    // Check if the storage instance is available\n    if (isNull(storageInstance) || isUndefined(storageInstance)) {\n      deferredObject.resolve(StorageEnum.STORAGE_UNDEFINED);\n    } else {\n      storageInstance\n        .get(featureKey, context.getId())\n        .then((data: Record<string, any>) => {\n          deferredObject.resolve(data);\n        })\n        .catch((err) => {\n          LogManager.Instance.error(\n            buildMessage(ErrorLogMessagesEnum.STORED_DATA_ERROR, {\n              err,\n            }),\n          );\n\n          deferredObject.resolve(StorageEnum.NO_DATA_FOUND);\n        });\n    }\n\n    return deferredObject.promise;\n  }\n\n  /**\n   * Stores data in the storage.\n   * @param data The data to be stored as a record.\n   * @returns A promise that resolves to true if data is successfully stored, otherwise false.\n   */\n  async setDataInStorage(data: Record<any, any>): Promise<void> {\n    const deferredObject = new Deferred();\n\n    const storageInstance = Storage.Instance.getConnector();\n    // Check if the storage instance is available\n    if (storageInstance === null || storageInstance === undefined) {\n      deferredObject.resolve(false);\n    } else {\n      storageInstance\n        .set(data)\n        .then(() => {\n          deferredObject.resolve(true);\n        })\n        .catch(() => {\n          deferredObject.resolve(false);\n        });\n    }\n\n    return deferredObject.promise;\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Constants } from '../constants';\nimport { CampaignTypeEnum } from '../enums/CampaignTypeEnum';\nimport { InfoLogMessagesEnum } from '../enums/log-messages';\nimport { CampaignModel } from '../models/campaign/CampaignModel';\nimport { FeatureModel } from '../models/campaign/FeatureModel';\nimport { VariationModel } from '../models/campaign/VariationModel';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { LogManager } from '../packages/logger';\nimport { buildMessage } from './LogMessageUtil';\n/**\n * Sets the variation allocation for a given campaign based on its type.\n * If the campaign type is ROLLOUT or PERSONALIZE, it handles the campaign using `_handleRolloutCampaign`.\n * Otherwise, it assigns range values to each variation in the campaign.\n * @param {CampaignModel} campaign - The campaign for which to set the variation allocation.\n */\nexport function setVariationAllocation(campaign: CampaignModel): void {\n  // Check if the campaign type is ROLLOUT or PERSONALIZE\n  if (campaign.getType() === CampaignTypeEnum.ROLLOUT || campaign.getType() === CampaignTypeEnum.PERSONALIZE) {\n    _handleRolloutCampaign(campaign);\n  } else {\n    let currentAllocation = 0;\n    // Iterate over each variation in the campaign\n    campaign.getVariations().forEach((variation) => {\n      // Assign range values to the variation and update the current allocation\n      const stepFactor = assignRangeValues(variation, currentAllocation);\n      currentAllocation += stepFactor;\n      // Log the range allocation for debugging\n      LogManager.Instance.info(\n        buildMessage(InfoLogMessagesEnum.VARIATION_RANGE_ALLOCATION, {\n          variationKey: variation.getKey(),\n          campaignKey: campaign.getKey(),\n          variationWeight: variation.getWeight(),\n          startRange: variation.getStartRangeVariation(),\n          endRange: variation.getEndRangeVariation(),\n        }),\n      );\n    });\n  }\n}\n\n/**\n * Assigns start and end range values to a variation based on its weight.\n * @param {VariationModel} data - The variation model to assign range values.\n * @param {number} currentAllocation - The current allocation value before this variation.\n * @returns {number} The step factor calculated from the variation's weight.\n */\nexport function assignRangeValues(data: VariationModel, currentAllocation: number) {\n  // Calculate the bucket range based on the variation's weight\n  const stepFactor: number = _getVariationBucketRange(data.getWeight());\n\n  // Set the start and end range of the variation\n  if (stepFactor) {\n    data.setStartRange(currentAllocation + 1);\n    data.setEndRange(currentAllocation + stepFactor);\n  } else {\n    data.setStartRange(-1);\n    data.setEndRange(-1);\n  }\n  return stepFactor;\n}\n\n/**\n * Scales the weights of variations to sum up to 100%.\n * @param {any[]} variations - The list of variations to scale.\n */\nexport function scaleVariationWeights(variations: any) {\n  // Calculate the total weight of all variations\n  const totalWeight = variations.reduce((acc, variation) => {\n    return acc + variation.weight;\n  }, 0);\n  // If total weight is zero, assign equal weight to each variation\n  if (!totalWeight) {\n    const equalWeight = 100 / variations.length;\n    variations.forEach((variation) => (variation.weight = equalWeight));\n  } else {\n    // Scale each variation's weight to make the total 100%\n    variations.forEach((variation) => (variation.weight = (variation.weight / totalWeight) * 100));\n  }\n}\n\n/**\n * Generates a bucketing seed based on user ID, campaign, and optional group ID.\n * @param {string} userId - The user ID.\n * @param {any} campaign - The campaign object.\n * @param {string} [groupId] - The optional group ID.\n * @returns {string} The bucketing seed.\n */\nexport function getBucketingSeed(userId: string, campaign: CampaignModel, groupId: number) {\n  // Return a seed combining group ID and user ID if group ID is provided\n  if (groupId) {\n    return `${groupId}_${userId}`;\n  }\n  // Return a seed combining campaign ID and user ID otherwise\n  return `${campaign.getId()}_${userId}`;\n}\n\n/**\n * Retrieves a variation by its ID within a specific campaign identified by its key.\n * @param {SettingsModel} settings - The settings model containing all campaigns.\n * @param {string} campaignKey - The key of the campaign.\n * @param {string} variationId - The ID of the variation to retrieve.\n * @returns {VariationModel | null} The found variation model or null if not found.\n */\nexport function getVariationFromCampaignKey(settings: SettingsModel, campaignKey: string, variationId: number) {\n  // Find the campaign by its key\n  const campaign: CampaignModel = settings.getCampaigns().find((campaign: CampaignModel) => {\n    return campaign.getKey() === campaignKey;\n  });\n\n  if (campaign) {\n    // Find the variation by its ID within the found campaign\n    const variation: VariationModel = campaign.getVariations().find((variation: VariationModel) => {\n      return variation.getId() === variationId;\n    });\n\n    if (variation) {\n      // Return a new instance of VariationModel based on the found variation\n      return new VariationModel().modelFromDictionary(variation);\n    }\n  }\n  return null;\n}\n\n/**\n * Sets the allocation ranges for a list of campaigns.\n * @param {CampaignModel[]} campaigns - The list of campaigns to set allocations for.\n */\nexport function setCampaignAllocation(campaigns: any[]) {\n  let stepFactor = 0;\n  for (let i = 0, currentAllocation = 0; i < campaigns.length; i++) {\n    const campaign = campaigns[i];\n\n    // Assign range values to each campaign and update the current allocation\n    stepFactor = assignRangeValuesMEG(campaign, currentAllocation);\n    currentAllocation += stepFactor;\n  }\n}\n\n/**\n * Determines if a campaign is part of a group.\n * @param {SettingsModel} settings - The settings model containing group associations.\n * @param {string} campaignId - The ID of the campaign to check.\n * @returns {Object} An object containing the group ID and name if the campaign is part of a group, otherwise an empty object.\n */\nexport function getGroupDetailsIfCampaignPartOfIt(settings: SettingsModel, campaignId: any) {\n  // Check if the campaign is associated with a group and return the group details\n  if (campaignId in settings.getCampaignGroups() && settings.getCampaignGroups()) {\n    return {\n      groupId: settings.getCampaignGroups()[campaignId],\n      groupName: settings.getGroups()[settings.getCampaignGroups()[campaignId]].name,\n    };\n  }\n  return {};\n}\n\n/**\n * Finds all groups associated with a feature specified by its key.\n * @param {SettingsModel} settings - The settings model containing all features and groups.\n * @param {string} featureKey - The key of the feature to find groups for.\n * @returns {Array} An array of groups associated with the feature.\n */\nexport function findGroupsFeaturePartOf(settings: SettingsModel, featureKey: string) {\n  const campaignIds: Array<number> = [];\n  // Loop over all rules inside the feature where the feature key matches and collect all campaign IDs\n  settings.getFeatures().forEach((feature) => {\n    if (feature.getKey() === featureKey) {\n      feature.getRules().forEach((rule) => {\n        if (campaignIds.indexOf(rule.getCampaignId()) === -1) {\n          campaignIds.push(rule.getCampaignId());\n        }\n      });\n    }\n  });\n\n  // Loop over all campaigns and find the group for each campaign\n  const groups: Array<any> = [];\n  campaignIds.forEach((campaignId) => {\n    const group = getGroupDetailsIfCampaignPartOfIt(settings, campaignId);\n    if (group.groupId) {\n      // Check if the group is already added to the groups array to avoid duplicates\n      const groupIndex = groups.findIndex((grp) => grp.groupId === group.groupId);\n      if (groupIndex === -1) {\n        groups.push(group);\n      }\n    }\n  });\n  return groups;\n}\n\n/**\n * Retrieves campaigns by a specific group ID.\n * @param {SettingsModel} settings - The settings model containing all groups.\n * @param {any} groupId - The ID of the group.\n * @returns {Array} An array of campaigns associated with the specified group ID.\n */\nexport function getCampaignsByGroupId(settings: SettingsModel, groupId: number) {\n  const group = settings.getGroups()[groupId];\n  if (group) {\n    return group.campaigns; // Return the campaigns associated with the group\n  } else {\n    return []; // Return an empty array if the group ID is not found\n  }\n}\n\n/**\n * Retrieves feature keys from a list of campaign IDs.\n * @param {SettingsModel} settings - The settings model containing all features.\n * @param {any} campaignIds - An array of campaign IDs.\n * @returns {Array} An array of feature keys associated with the provided campaign IDs.\n */\nexport function getFeatureKeysFromCampaignIds(settings: SettingsModel, campaignIds: any) {\n  const featureKeys = [];\n  for (const campaignId of campaignIds) {\n    settings.getFeatures().forEach((feature) => {\n      feature.getRules().forEach((rule) => {\n        if (rule.getCampaignId() === campaignId) {\n          featureKeys.push(feature.getKey()); // Add feature key if campaign ID matches\n        }\n      });\n    });\n  }\n  return featureKeys;\n}\n\n/**\n * Retrieves campaign IDs from a specific feature key.\n * @param {SettingsModel} settings - The settings model containing all features.\n * @param {string} featureKey - The key of the feature.\n * @returns {Array} An array of campaign IDs associated with the specified feature key.\n */\nexport function getCampaignIdsFromFeatureKey(settings: SettingsModel, featureKey: string) {\n  const campaignIds = [];\n  settings.getFeatures().forEach((feature) => {\n    if (feature.getKey() === featureKey) {\n      feature.getRules().forEach((rule) => {\n        campaignIds.push(rule.getCampaignId()); // Add campaign ID if feature key matches\n      });\n    }\n  });\n  return campaignIds;\n}\n\n/**\n * Assigns range values to a campaign based on its weight.\n * @param {any} data - The campaign data containing weight.\n * @param {number} currentAllocation - The current allocation value before this campaign.\n * @returns {number} The step factor calculated from the campaign's weight.\n */\nexport function assignRangeValuesMEG(data: any, currentAllocation: number) {\n  const stepFactor: number = _getVariationBucketRange(data.weight);\n\n  if (stepFactor) {\n    data.startRangeVariation = currentAllocation + 1; // Set the start range\n    data.endRangeVariation = currentAllocation + stepFactor; // Set the end range\n  } else {\n    data.startRangeVariation = -1; // Set invalid range if step factor is zero\n    data.endRangeVariation = -1;\n  }\n  return stepFactor;\n}\n\n/**\n * Retrieves the rule type using a campaign ID from a specific feature.\n * @param {any} feature - The feature containing rules.\n * @param {number} campaignId - The campaign ID to find the rule type for.\n * @returns {string} The rule type if found, otherwise an empty string.\n */\nexport function getRuleTypeUsingCampaignIdFromFeature(feature: FeatureModel, campaignId: number) {\n  const rule = feature.getRules().find((rule) => rule.getCampaignId() === campaignId);\n  return rule ? rule.getType() : ''; // Return the rule type if found\n}\n\n/**\n * Calculates the bucket range for a variation based on its weight.\n * @param {number} variationWeight - The weight of the variation.\n * @returns {number} The calculated bucket range.\n */\nfunction _getVariationBucketRange(variationWeight: number) {\n  if (!variationWeight || variationWeight === 0) {\n    return 0; // Return zero if weight is invalid or zero\n  }\n\n  const startRange = Math.ceil(variationWeight * 100);\n\n  return Math.min(startRange, Constants.MAX_TRAFFIC_VALUE); // Ensure the range does not exceed the max traffic value\n}\n\n/**\n * Handles the rollout campaign by setting start and end ranges for all variations.\n * @param {CampaignModel} campaign - The campaign to handle.\n */\nfunction _handleRolloutCampaign(campaign: CampaignModel): void {\n  // Set start and end ranges for all variations in the campaign\n  for (let i = 0; i < campaign.getVariations().length; i++) {\n    const variation = campaign.getVariations()[i];\n    const endRange = campaign.getVariations()[i].getWeight() * 100;\n\n    variation.setStartRange(1);\n    variation.setEndRange(endRange);\n\n    LogManager.Instance.info(\n      buildMessage(InfoLogMessagesEnum.VARIATION_RANGE_ALLOCATION, {\n        variationKey: variation.getKey(),\n        campaignKey: campaign.getKey(),\n        variationWeight: variation.getWeight(),\n        startRange: 1,\n        endRange,\n      }),\n    );\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../types/Common';\n\ntype FunctionType = (val: dynamic) => void;\n\n/**\n * Checks if a value is an object excluding arrays, functions, regexes, promises, and dates.\n * @param val The value to check.\n * @returns True if the value is an object, false otherwise.\n */\nexport function isObject<T>(\n  val: T,\n): val is Record<any, dynamic> & Exclude<T, Array<dynamic> | FunctionType | RegExp | Promise<dynamic> | Date> {\n  // Using Object.prototype.toString to get a precise string representation of the value type\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Checks if a value is an array.\n * @param val The value to check.\n * @returns True if the value is an array, false otherwise.\n */\nexport function isArray(val: dynamic): val is Array<dynamic> {\n  return Object.prototype.toString.call(val) === '[object Array]';\n}\n\n/**\n * Checks if a value is null.\n * @param val The value to check.\n * @returns True if the value is null, false otherwise.\n */\nexport function isNull(val: dynamic): val is null {\n  return Object.prototype.toString.call(val) === '[object Null]';\n}\n\n/**\n * Checks if a value is undefined.\n * @param val The value to check.\n * @returns True if the value is undefined, false otherwise.\n */\nexport function isUndefined(val: dynamic): val is undefined {\n  return Object.prototype.toString.call(val) === '[object Undefined]';\n}\n\n/**\n * Checks if a value is defined, i.e., not undefined and not null.\n * @param val The value to check.\n * @returns True if the value is defined, false otherwise.\n */\nexport function isDefined<T>(val: T): val is NonNullable<T> {\n  return !isUndefined(val) && !isNull(val);\n}\n\n/**\n * Checks if a value is a number, including NaN.\n * @param val The value to check.\n * @returns True if the value is a number, false otherwise.\n */\nexport function isNumber(val: dynamic): val is number {\n  // Note: NaN is also a number\n  return Object.prototype.toString.call(val) === '[object Number]';\n}\n\n/**\n * Checks if a value is a string.\n * @param val The value to check.\n * @returns True if the value is a string, false otherwise.\n */\nexport function isString(val: dynamic): val is string {\n  return Object.prototype.toString.call(val) === '[object String]';\n}\n\n/**\n * Checks if a value is a boolean.\n * @param val The value to check.\n * @returns True if the value is a boolean, false otherwise.\n */\nexport function isBoolean(val: dynamic): val is boolean {\n  return Object.prototype.toString.call(val) === '[object Boolean]';\n}\n\n/**\n * Checks if a value is NaN.\n * @param val The value to check.\n * @returns True if the value is NaN, false otherwise.\n */\nexport function isNaN(val: dynamic): val is number {\n  // NaN is the only JavaScript value that is treated as unequal to itself\n  return val !== val;\n}\n\n/**\n * Checks if a value is a Date object.\n * @param val The value to check.\n * @returns True if the value is a Date object, false otherwise.\n */\nexport function isDate(val: dynamic): val is Date {\n  return Object.prototype.toString.call(val) === '[object Date]';\n}\n\n/**\n * Checks if a value is a function.\n * @param val The value to check.\n * @returns True if the value is a function, false otherwise.\n */\nexport function isFunction(val: dynamic): val is FunctionType {\n  return Object.prototype.toString.call(val) === '[object Function]';\n}\n\n/**\n * Checks if a value is a regular expression.\n * @param val The value to check.\n * @returns True if the value is a regular expression, false otherwise.\n */\nexport function isRegex(val: dynamic): val is RegExp {\n  return Object.prototype.toString.call(val) === '[object RegExp]';\n}\n\n/**\n * Checks if a value is a Promise.\n * @param val The value to check.\n * @returns True if the value is a Promise, false otherwise.\n */\nexport function isPromise(val: dynamic): val is Promise<dynamic> {\n  return Object.prototype.toString.call(val) === '[object Promise]';\n}\n\n/**\n * Determines the type of the given value using various type-checking utility functions.\n * @param val The value to determine the type of.\n * @returns A string representing the type of the value.\n */\nexport function getType(val: dynamic): string {\n  // Check if the value is an Object (excluding arrays, functions, etc.)\n  return isObject(val)\n    ? 'Object'\n    : // Check if the value is an Array\n      isArray(val)\n      ? 'Array'\n      : // Check if the value is null\n        isNull(val)\n        ? 'Null'\n        : // Check if the value is undefined\n          isUndefined(val)\n          ? 'Undefined'\n          : // Check if the value is NaN (Not a Number)\n            isNaN(val)\n            ? 'NaN'\n            : // Check if the value is a Number (including NaN)\n              isNumber(val)\n              ? 'Number'\n              : // Check if the value is a String\n                isString(val)\n                ? 'String'\n                : // Check if the value is a Boolean\n                  isBoolean(val)\n                  ? 'Boolean'\n                  : // Check if the value is a Date object\n                    isDate(val)\n                    ? 'Date'\n                    : // Check if the value is a Regular Expression\n                      isRegex(val)\n                      ? 'Regex'\n                      : // Check if the value is a Function\n                        isFunction(val)\n                        ? 'Function'\n                        : // Check if the value is a Promise\n                          isPromise(val)\n                          ? 'Promise'\n                          : // If none of the above, return 'Unknown Type'\n                            'Unknown Type';\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isPromise } from '../utils/DataTypeUtil';\nimport { CampaignTypeEnum } from '../enums/CampaignTypeEnum';\nimport { StatusEnum } from '../enums/StatusEnum';\nimport { InfoLogMessagesEnum } from '../enums/log-messages';\nimport { CampaignModel } from '../models/campaign/CampaignModel';\nimport { FeatureModel } from '../models/campaign/FeatureModel';\nimport { VariationModel } from '../models/campaign/VariationModel';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { DecisionMaker } from '../packages/decision-maker';\nimport { LogManager } from '../packages/logger';\nimport { SegmentationManager } from '../packages/segmentation-evaluator';\nimport { CampaignDecisionService } from '../services/CampaignDecisionService';\nimport { IStorageService } from '../services/StorageService';\nimport { isObject } from '../utils/DataTypeUtil';\nimport {\n  assignRangeValues,\n  getBucketingSeed,\n  getGroupDetailsIfCampaignPartOfIt,\n  scaleVariationWeights,\n} from './CampaignUtil';\nimport { cloneObject } from './FunctionUtil';\nimport { buildMessage } from './LogMessageUtil';\nimport { evaluateGroups } from './MegUtil';\nimport { getUUID } from './UuidUtil';\n\nexport const checkWhitelistingAndPreSeg = async (\n  settings: SettingsModel,\n  feature: FeatureModel,\n  campaign: CampaignModel,\n  context: ContextModel,\n  evaluatedFeatureMap: Map<string, any>,\n  megGroupWinnerCampaigns: Map<number, number>,\n  storageService: IStorageService,\n  decision: any,\n): Promise<[boolean, any]> => {\n  const vwoUserId = getUUID(context.getId(), settings.getAccountId());\n  const campaignId = campaign.getId();\n\n  if (campaign.getType() === CampaignTypeEnum.AB) {\n    // set _vwoUserId for variation targeting variables\n    context.setVariationTargetingVariables(\n      Object.assign({}, context.getVariationTargetingVariables(), {\n        _vwoUserId: campaign.getIsUserListEnabled() ? vwoUserId : context.getId(),\n      }),\n    );\n\n    Object.assign(decision, { variationTargetingVariables: context.getVariationTargetingVariables() }); // for integration\n\n    // check if the campaign satisfies the whitelisting\n    if (campaign.getIsForcedVariationEnabled()) {\n      const whitelistedVariation = await _checkCampaignWhitelisting(campaign, context);\n      if (whitelistedVariation && Object.keys(whitelistedVariation).length > 0) {\n        return [true, whitelistedVariation];\n      }\n    } else {\n      LogManager.Instance.info(\n        buildMessage(InfoLogMessagesEnum.WHITELISTING_SKIP, {\n          campaignKey: campaign.getRuleKey(),\n          userId: context.getId(),\n        }),\n      );\n    }\n  }\n  // userlist segment is also available for campaign pre segmentation\n  context.setCustomVariables(\n    Object.assign({}, context.getCustomVariables(), {\n      _vwoUserId: campaign.getIsUserListEnabled() ? vwoUserId : context.getId(),\n    }),\n  );\n\n  Object.assign(decision, { customVariables: context.getCustomVariables() }); // for integeration\n\n  // Check if RUle being evaluated is part of Mutually Exclusive Group\n  const { groupId } = getGroupDetailsIfCampaignPartOfIt(settings, campaignId);\n  // Check if group is already evaluated and we have eligible winner campaigns\n  const groupWinnerCampaignId = megGroupWinnerCampaigns?.get(groupId);\n  if (groupWinnerCampaignId) {\n    // check if the campaign is the winner of the group\n    if (groupWinnerCampaignId === campaignId) {\n      return [true, null];\n    }\n    // as group is already evaluated, no need to check again, return false directly\n    return [false, null];\n  }\n\n  // If Whitelisting is skipped/failed and campaign not part of any MEG Groups\n  // Check campaign's pre-segmentation\n  const isPreSegmentationPassed = await new CampaignDecisionService().getPreSegmentationDecision(campaign, context);\n\n  if (isPreSegmentationPassed && groupId) {\n    const winnerCampaign = await evaluateGroups(\n      settings,\n      feature,\n      groupId,\n      evaluatedFeatureMap,\n      context,\n      storageService,\n    );\n\n    if (winnerCampaign && winnerCampaign.id === campaignId) {\n      return [true, null];\n    }\n    megGroupWinnerCampaigns.set(groupId, winnerCampaign?.id || 0);\n    return [false, null];\n  }\n\n  return [isPreSegmentationPassed, null];\n};\n\nexport const evaluateTrafficAndGetVariation = (\n  settings: SettingsModel,\n  campaign: CampaignModel,\n  userId: string | number,\n): VariationModel => {\n  const variation = new CampaignDecisionService().getVariationAlloted(userId, settings.getAccountId(), campaign);\n  if (!variation) {\n    LogManager.Instance.info(\n      buildMessage(InfoLogMessagesEnum.USER_CAMPAIGN_BUCKET_INFO, {\n        campaignKey: campaign.getKey(),\n        userId,\n        status: 'did not get any variation',\n      }),\n    );\n\n    return null;\n  }\n  LogManager.Instance.info(\n    buildMessage(InfoLogMessagesEnum.USER_CAMPAIGN_BUCKET_INFO, {\n      campaignKey: campaign.getKey(),\n      userId,\n      status: `got variation:${variation.getKey()}`,\n    }),\n  );\n\n  return variation;\n};\n\n/******************\n * PRIVATE METHODS\n ******************/\n\n/**\n * Check for whitelisting\n * @param campaign      Campaign object\n * @param userId        User ID\n * @param variationTargetingVariables   Variation targeting variables\n * @returns\n */\nconst _checkCampaignWhitelisting = async (campaign: CampaignModel, context: ContextModel): Promise<any> => {\n  // check if the campaign satisfies the whitelisting\n  const whitelistingResult = await _evaluateWhitelisting(campaign, context);\n  const status = whitelistingResult ? StatusEnum.PASSED : StatusEnum.FAILED;\n  const variationString = whitelistingResult ? whitelistingResult.variation.key : '';\n\n  LogManager.Instance.info(\n    buildMessage(InfoLogMessagesEnum.WHITELISTING_STATUS, {\n      userId: context.getId(),\n      campaignKey: campaign.getRuleKey(),\n      status,\n      variationString,\n    }),\n  );\n\n  return whitelistingResult;\n};\n\nconst _evaluateWhitelisting = async (campaign: CampaignModel, context: ContextModel): Promise<any> => {\n  const targetedVariations = [];\n  const promises: Promise<any>[] = [];\n\n  let whitelistedVariation;\n\n  campaign.getVariations().forEach((variation) => {\n    if (isObject(variation.getSegments()) && !Object.keys(variation.getSegments()).length) {\n      LogManager.Instance.info(\n        buildMessage(InfoLogMessagesEnum.WHITELISTING_SKIP, {\n          campaignKey: campaign.getRuleKey(),\n          userId: context.getId(),\n          variation: variation.getKey() ? `for variation: ${variation.getKey()}` : '',\n        }),\n      );\n\n      return;\n    }\n    // check for segmentation and evaluate\n    if (isObject(variation.getSegments())) {\n      let SegmentEvaluatorResult = SegmentationManager.Instance.validateSegmentation(\n        variation.getSegments(),\n        context.getVariationTargetingVariables(),\n      );\n      SegmentEvaluatorResult = isPromise(SegmentEvaluatorResult)\n        ? SegmentEvaluatorResult\n        : Promise.resolve(SegmentEvaluatorResult);\n      SegmentEvaluatorResult.then((evaluationResult) => {\n        if (evaluationResult) {\n          targetedVariations.push(cloneObject(variation));\n        }\n      });\n\n      promises.push(SegmentEvaluatorResult);\n    }\n  });\n\n  // Wait for all promises to resolve\n  await Promise.all(promises);\n\n  if (targetedVariations.length > 1) {\n    scaleVariationWeights(targetedVariations);\n    for (let i = 0, currentAllocation = 0, stepFactor = 0; i < targetedVariations.length; i++) {\n      stepFactor = assignRangeValues(targetedVariations[i], currentAllocation);\n      currentAllocation += stepFactor;\n    }\n    whitelistedVariation = new CampaignDecisionService().getVariation(\n      targetedVariations,\n      new DecisionMaker().calculateBucketValue(getBucketingSeed(context.getId(), campaign, null)),\n    );\n  } else {\n    whitelistedVariation = targetedVariations[0];\n  }\n\n  if (whitelistedVariation) {\n    return {\n      variation: whitelistedVariation,\n      variationName: whitelistedVariation.name,\n      variationId: whitelistedVariation.id,\n    };\n  }\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CampaignTypeEnum } from '../enums/CampaignTypeEnum';\nimport { CampaignModel } from '../models/campaign/CampaignModel';\nimport { FeatureModel } from '../models/campaign/FeatureModel';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { dynamic } from '../types/Common';\nimport { isString } from './DataTypeUtil';\n\n/**\n * Clones an object deeply.\n * @param {dynamic} obj - The object to clone.\n * @returns {any} The cloned object.\n */\nexport function cloneObject(obj: dynamic): any {\n  if (!obj) {\n    // Return the original object if it is null or undefined\n    return obj;\n  }\n  // Use JSON stringify and parse method to perform a deep clone\n  const clonedObj = JSON.parse(JSON.stringify(obj));\n  return clonedObj;\n}\n\n/**\n * Gets the current Unix timestamp in seconds.\n * @returns {number} The current Unix timestamp.\n */\nexport function getCurrentUnixTimestamp(): number {\n  // Convert the current date to Unix timestamp in seconds\n  return Math.ceil(+new Date() / 1000);\n}\n\n/**\n * Gets the current Unix timestamp in milliseconds.\n * @returns {number} The current Unix timestamp in milliseconds.\n */\nexport function getCurrentUnixTimestampInMillis(): number {\n  // Convert the current date to Unix timestamp in milliseconds\n  return +new Date();\n}\n\n/**\n * Generates a random number between 0 and 1.\n * @returns {number} A random number.\n */\nexport function getRandomNumber(): number {\n  // Use Math.random to generate a random number\n  return Math.random();\n}\n\n/**\n * Retrieves specific rules based on the type from a feature.\n * @param {FeatureModel} feature - The key of the feature.\n * @param {CampaignTypeEnum | null} type - The type of the rules to retrieve.\n * @returns {Array} An array of rules that match the type.\n */\nexport function getSpecificRulesBasedOnType(feature: FeatureModel, type: CampaignTypeEnum = null) {\n  // Return an empty array if no linked campaigns are found\n  if (feature && !feature?.getRulesLinkedCampaign()) {\n    return [];\n  }\n  // Filter the rules by type if a type is specified and is a string\n  if (feature && feature.getRulesLinkedCampaign() && type && isString(type)) {\n    return feature.getRulesLinkedCampaign().filter((rule) => {\n      const ruleModel = new CampaignModel().modelFromDictionary(rule);\n      return ruleModel.getType() === type;\n    });\n  }\n  // Return all linked campaigns if no type is specified\n  return feature.getRulesLinkedCampaign();\n}\n\n/**\n * Retrieves all AB and Personalize rules from a feature.\n * @param {any} settings - The settings containing features.\n * @param {string} featureKey - The key of the feature.\n * @returns {Array} An array of AB and Personalize rules.\n */\nexport function getAllExperimentRules(feature: FeatureModel) {\n  // Retrieve the feature by its key\n  // Filter the rules to include only AB and Personalize types\n  return (\n    feature\n      ?.getRulesLinkedCampaign()\n      .filter((rule) => rule.getType() === CampaignTypeEnum.AB || rule.getType() === CampaignTypeEnum.PERSONALIZE) || []\n  );\n}\n\n/**\n * Retrieves a feature by its key from the settings.\n * @param {any} settings - The settings containing features.\n * @param {string} featureKey - The key of the feature to find.\n * @returns {any} The feature if found, otherwise undefined.\n */\nexport function getFeatureFromKey(settings: SettingsModel, featureKey: string) {\n  // Find the feature by its key\n  return settings?.getFeatures()?.find((feature) => feature.getKey() === featureKey);\n}\n\n/**\n * Checks if an event exists within any feature's metrics.\n * @param {string} eventName - The name of the event to check.\n * @param {any} settings - The settings containing features.\n * @returns {boolean} True if the event exists, otherwise false.\n */\nexport function doesEventBelongToAnyFeature(eventName: string, settings: SettingsModel): boolean {\n  // Use the `some` method to check if any feature contains the event in its metrics\n  return settings\n    .getFeatures()\n    .some((feature) => feature.getMetrics().some((metric) => metric.getIdentifier() === eventName));\n}\n\n/**\n * Adds linked campaigns to each feature in the settings based on rules.\n * @param {any} settings - The settings file to modify.\n */\nexport function addLinkedCampaignsToSettings(settings: SettingsModel): void {\n  // Create maps for quick access to campaigns and variations\n  const campaignMap = new Map<number, CampaignModel>(\n    settings.getCampaigns().map((campaign) => [campaign.getId(), campaign]),\n  );\n\n  // Loop over all features\n  for (const feature of settings.getFeatures()) {\n    const rulesLinkedCampaign = feature\n      .getRules()\n      .map((rule) => {\n        const campaign: CampaignModel = campaignMap.get(rule.getCampaignId());\n        if (!campaign) return null;\n\n        // Create a linked campaign object with the rule and campaign\n        const linkedCampaign: any = { key: campaign.getKey(), ...campaign, ruleKey: rule.getRuleKey() };\n        // If a variationId is specified, find and add the variation\n        if (rule.getVariationId()) {\n          const variation = campaign.getVariations().find((v) => v.getId() === rule.getVariationId());\n          if (variation) {\n            linkedCampaign.variations = [variation];\n          }\n        }\n\n        return linkedCampaign;\n      })\n      .filter((campaign) => campaign !== null); // Filter out any null entries\n\n    const rulesLinkedCampaignModel = rulesLinkedCampaign.map((campaign) => {\n      const campaignModel = new CampaignModel();\n      campaignModel.modelFromDictionary(campaign);\n      return campaignModel;\n    });\n    // Assign the linked campaigns to the feature\n    feature.setRulesLinkedCampaign(rulesLinkedCampaignModel);\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CampaignTypeEnum } from '../enums/CampaignTypeEnum';\nimport { HttpMethodEnum } from '../enums/HttpMethodEnum';\nimport { ErrorLogMessagesEnum } from '../enums/log-messages';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { LogManager } from '../packages/logger';\nimport { NetworkManager, RequestModel, ResponseModel } from '../packages/network-layer';\nimport { SettingsService } from '../services/SettingsService';\nimport { Deferred } from './PromiseUtil';\nimport { UrlUtil } from './UrlUtil';\n\n/**\n * Asynchronously retrieves data from a web service using the specified query parameters and endpoint.\n * @param queryParams - The parameters to be used in the query string of the request.\n * @param endpoint - The endpoint URL to which the request is sent.\n * @returns A promise that resolves to the response data or false if an error occurs.\n */\nexport async function getFromGatewayService(queryParams: any, endpoint: any): Promise<any> {\n  // Create a new deferred object to manage promise resolution\n  const deferredObject = new Deferred();\n  // Singleton instance of the network manager\n  const networkInstance = NetworkManager.Instance;\n\n  // Check if the base URL is not set correctly\n  if (!SettingsService.Instance.isGatewayServiceProvided) {\n    // Log an informational message about the invalid URL\n    LogManager.Instance.error(ErrorLogMessagesEnum.GATEWAY_URL_ERROR);\n    // Resolve the promise with false indicating an error or invalid state\n    deferredObject.resolve(false);\n    return deferredObject.promise;\n  }\n\n  try {\n    // Create a new request model instance with the provided parameters\n    const request: RequestModel = new RequestModel(\n      UrlUtil.getBaseUrl(),\n      HttpMethodEnum.GET,\n      endpoint,\n      queryParams,\n      null,\n      null,\n      SettingsService.Instance.protocol,\n      SettingsService.Instance.port,\n    );\n\n    // Perform the network GET request\n    networkInstance\n      .get(request)\n      .then((response: ResponseModel) => {\n        // Resolve the deferred object with the data from the response\n        deferredObject.resolve(response.getData());\n      })\n      .catch((err: ResponseModel) => {\n        // Reject the deferred object with the error response\n        deferredObject.reject(err);\n      });\n\n    return deferredObject.promise;\n  } catch (err) {\n    // Resolve the promise with false as fallback\n    deferredObject.resolve(false);\n    return deferredObject.promise;\n  }\n}\n\n/**\n * Encodes the query parameters to ensure they are URL-safe.\n * @param queryParams  The query parameters to be encoded.\n * @returns  An object containing the encoded query parameters.\n */\nexport function getQueryParams(queryParams: Record<string, string | number>): Record<string, string> {\n  const encodedParams: Record<string, string> = {};\n\n  for (const [key, value] of Object.entries(queryParams)) {\n    // Encode the parameter value to ensure it is URL-safe\n    const encodedValue = encodeURIComponent(String(value));\n    // Add the encoded parameter to the result object\n    encodedParams[key] = encodedValue;\n  }\n\n  return encodedParams;\n}\n\n/**\n * Adds isGatewayServiceRequired flag to each feature in the settings based on pre segmentation.\n * @param {any} settings - The settings file to modify.\n */\nexport function addIsGatewayServiceRequiredFlag(settings: SettingsModel): void {\n  // \\b(?<!\\\"custom_variable\\\"[^\\}]*)(country|region|city|os|device_type|browser_string|ua)\\b: This part matches the usual patterns (like country, region, etc.) that are not under custom_variable\n  // |(?<=\"custom_variable\"\\s*:\\s*{\\s*\"[^)]*\"\\s*:\\s*\")inlist\\([^)]*\\)(?=\"): This part matches inlist(*) only when it appears under \"custom_variable\" : { \".*\" : \"\n  const pattern =\n    /\\b(?<!\"custom_variable\"[^}]*)(country|region|city|os|device_type|browser_string|ua)\\b|(?<=\"custom_variable\"\\s*:\\s*{\\s*\"name\"\\s*:\\s*\")inlist\\([^)]*\\)(?=\")/g;\n\n  for (const feature of settings.getFeatures()) {\n    const rules = feature.getRulesLinkedCampaign();\n    for (const rule of rules) {\n      let segments = {};\n      if (rule.getType() === CampaignTypeEnum.PERSONALIZE || rule.getType() === CampaignTypeEnum.ROLLOUT) {\n        segments = rule.getVariations()[0].getSegments();\n      } else {\n        segments = rule.getSegments();\n      }\n      if (segments) {\n        const jsonSegments = JSON.stringify(segments);\n        const matches = jsonSegments.match(pattern);\n        if (matches && matches.length > 0) {\n          feature.setIsGatewayServiceRequired(true);\n          break;\n        }\n      }\n    }\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { getEventsBaseProperties, getTrackUserPayloadData, sendPostApiRequest } from './NetworkUtil';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { EventEnum } from '../enums/EventEnum';\n\n/**\n * Creates and sends an impression for a variation shown event.\n * This function constructs the necessary properties and payload for the event\n * and uses the NetworkUtil to send a POST API request.\n *\n * @param {SettingsModel} settings - The settings model containing configuration.\n * @param {number} campaignId - The ID of the campaign.\n * @param {number} variationId - The ID of the variation shown to the user.\n * @param {ContextModel} context - The user context model containing user-specific data.\n */\nexport const createAndSendImpressionForVariationShown = async (\n  settings: SettingsModel,\n  campaignId: number,\n  variationId: number,\n  context: ContextModel,\n) => {\n  // Get base properties for the event\n  const properties = getEventsBaseProperties(\n    settings,\n    EventEnum.VWO_VARIATION_SHOWN,\n    encodeURIComponent(context.getUserAgent()), // Encode user agent to ensure URL safety\n    context.getIpAddress(),\n  );\n\n  // Construct payload data for tracking the user\n  const payload = getTrackUserPayloadData(\n    settings,\n    context.getId(),\n    EventEnum.VWO_VARIATION_SHOWN,\n    campaignId,\n    variationId,\n    context.getUserAgent(),\n    context.getIpAddress(),\n  );\n\n  // Send the constructed properties and payload as a POST request\n  await sendPostApiRequest(properties, payload);\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isFunction } from '../utils/DataTypeUtil';\n\nconst nargs = /\\{([0-9a-zA-Z_]+)\\}/g;\n\n/**\n * Constructs a message by replacing placeholders in a template with corresponding values from a data object.\n *\n * @param {string} template - The message template containing placeholders in the format `{key}`.\n * @param {Record<string, any>} data - An object containing keys and values used to replace the placeholders in the template.\n * @returns {string} The constructed message with all placeholders replaced by their corresponding values from the data object.\n */\nexport function buildMessage(template: string, data: Record<string, any> = {}): string {\n  try {\n    return template.replace(nargs, (match, key, index) => {\n      // Check for escaped placeholders\n      if (template[index - 1] === '{' && template[index + match.length] === '}') {\n        return key;\n      }\n\n      // Retrieve the value from the data object\n      const value = data[key];\n\n      // If the key does not exist or the value is null/undefined, return an empty string\n      if (value === undefined || value === null) {\n        return '';\n      }\n\n      // If the value is a function, evaluate it\n      return isFunction(value) ? value() : value;\n    });\n  } catch (err) {\n    return template; // Return the original template in case of an error\n  }\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Constants } from '../constants';\nimport { StorageDecorator } from '../decorators/StorageDecorator';\nimport { CampaignTypeEnum } from '../enums/CampaignTypeEnum';\nimport { InfoLogMessagesEnum } from '../enums/log-messages';\nimport { CampaignModel } from '../models/campaign/CampaignModel';\nimport { FeatureModel } from '../models/campaign/FeatureModel';\nimport { VariationModel } from '../models/campaign/VariationModel';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { DecisionMaker } from '../packages/decision-maker';\nimport { LogManager } from '../packages/logger';\nimport { CampaignDecisionService } from '../services/CampaignDecisionService';\nimport { IStorageService } from '../services/StorageService';\nimport { evaluateRule } from '../utils/RuleEvaluationUtil';\nimport {\n  getBucketingSeed,\n  getCampaignIdsFromFeatureKey,\n  getCampaignsByGroupId,\n  getFeatureKeysFromCampaignIds,\n  getVariationFromCampaignKey,\n  setCampaignAllocation,\n} from './CampaignUtil';\nimport { isObject, isUndefined } from './DataTypeUtil';\nimport { evaluateTrafficAndGetVariation } from './DecisionUtil';\nimport { cloneObject, getFeatureFromKey, getSpecificRulesBasedOnType } from './FunctionUtil';\nimport { buildMessage } from './LogMessageUtil';\n\n/**\n * Evaluates groups for a given feature and group ID.\n *\n * @param settings - The settings model.\n * @param feature - The feature model to evaluate.\n * @param groupId - The ID of the group.\n * @param evaluatedFeatureMap - A map containing evaluated features.\n * @param context - The context model.\n * @param storageService - The storage service.\n * @returns A promise that resolves to the evaluation result.\n */\nexport const evaluateGroups = async (\n  settings: SettingsModel,\n  feature: FeatureModel,\n  groupId: number,\n  evaluatedFeatureMap: Map<string, any>,\n  context: ContextModel,\n  storageService: IStorageService,\n): Promise<any> => {\n  const featureToSkip = [];\n  const campaignMap: Map<string, any[]> = new Map();\n  // get all feature keys and all campaignIds from the groupId\n  const { featureKeys, groupCampaignIds } = getFeatureKeysFromGroup(settings, groupId);\n  for (const featureKey of featureKeys) {\n    const feature = getFeatureFromKey(settings, featureKey);\n    // get all campaignIds from the featureKey\n    const featureCampaignIds = getCampaignIdsFromFeatureKey(settings, featureKey);\n    // check if the feature is already evaluated\n    if (featureToSkip.includes(featureKey)) {\n      continue;\n    }\n    // evaluate the feature rollout rules\n    const isRolloutRulePassed = await _isRolloutRuleForFeaturePassed(\n      settings,\n      feature,\n      evaluatedFeatureMap,\n      featureToSkip,\n      storageService,\n      context,\n    );\n    if (isRolloutRulePassed) {\n      settings.getCampaigns().forEach((campaign) => {\n        // groupCampaignIds.includes(campaign.getId()) -> campaign we are adding should be in the group\n        // featureCampaignIds.includes(campaign.getId()) -> checks that campaign should be part of the feature that we evaluated\n        if (groupCampaignIds.includes(campaign.getId()) && featureCampaignIds.includes(campaign.getId())) {\n          if (!campaignMap.has(featureKey)) {\n            campaignMap.set(featureKey, []);\n          }\n          // check if the campaign is already present in the campaignMap for the feature\n          if (campaignMap.get(featureKey).findIndex((item) => item.key === campaign.getKey()) === -1) {\n            campaignMap.get(featureKey).push(campaign);\n          }\n        }\n      });\n    }\n  }\n  const { eligibleCampaigns, eligibleCampaignsWithStorage } = await _getEligbleCampaigns(\n    settings,\n    campaignMap,\n    context,\n    storageService,\n  );\n\n  return await _findWinnerCampaignAmongEligibleCampaigns(\n    settings,\n    feature.getKey(),\n    eligibleCampaigns,\n    eligibleCampaignsWithStorage,\n    groupId,\n    context,\n  );\n};\n\n/**\n * Retrieves feature keys associated with a group based on the group ID.\n *\n * @param settings - The settings model.\n * @param groupId - The ID of the group.\n * @returns An object containing feature keys and group campaign IDs.\n */\nexport function getFeatureKeysFromGroup(settings: SettingsModel, groupId: number) {\n  const groupCampaignIds = getCampaignsByGroupId(settings, groupId);\n  const featureKeys = getFeatureKeysFromCampaignIds(settings, groupCampaignIds);\n\n  return { featureKeys, groupCampaignIds };\n}\n\n/*******************************\n * PRIVATE methods - MegUtil\n ******************************/\n\n/**\n * Evaluates the feature rollout rules for a given feature.\n *\n * @param settings - The settings model.\n * @param feature - The feature model to evaluate.\n * @param evaluatedFeatureMap - A map containing evaluated features.\n * @param featureToSkip - An array of features to skip during evaluation.\n * @param storageService - The storage service.\n * @param context - The context model.\n * @returns A promise that resolves to true if the feature passes the rollout rules, false otherwise.\n */\nconst _isRolloutRuleForFeaturePassed = async (\n  settings: SettingsModel,\n  feature: FeatureModel,\n  evaluatedFeatureMap: Map<string, any>,\n  featureToSkip: any[],\n  storageService: IStorageService,\n  context: ContextModel,\n): Promise<boolean> => {\n  if (evaluatedFeatureMap.has(feature.getKey()) && 'rolloutId' in evaluatedFeatureMap.get(feature.getKey())) {\n    return true;\n  }\n  const rollOutRules = getSpecificRulesBasedOnType(feature, CampaignTypeEnum.ROLLOUT);\n  if (rollOutRules.length > 0) {\n    let ruleToTestForTraffic = null;\n    for (const rule of rollOutRules) {\n      const { preSegmentationResult } = await evaluateRule(\n        settings,\n        feature,\n        rule,\n        context,\n        evaluatedFeatureMap,\n        null,\n        storageService,\n        {},\n      );\n      if (preSegmentationResult) {\n        ruleToTestForTraffic = rule;\n        break;\n      }\n      continue;\n    }\n    if (ruleToTestForTraffic !== null) {\n      const campaign = new CampaignModel().modelFromDictionary(ruleToTestForTraffic);\n      const variation = evaluateTrafficAndGetVariation(settings, campaign, context.getId());\n      if (isObject(variation) && Object.keys(variation).length > 0) {\n        evaluatedFeatureMap.set(feature.getKey(), {\n          rolloutId: ruleToTestForTraffic.id,\n          rolloutKey: ruleToTestForTraffic.key,\n          rolloutVariationId: ruleToTestForTraffic.variations[0].id,\n        });\n        return true;\n      }\n    }\n    // no rollout rule passed\n    featureToSkip.push(feature.getKey());\n    return false;\n  }\n  // no rollout rule, evaluate experiments\n  LogManager.Instance.info(\n    buildMessage(InfoLogMessagesEnum.MEG_SKIP_ROLLOUT_EVALUATE_EXPERIMENTS, {\n      featureKey: feature.getKey(),\n    }),\n  );\n  return true;\n};\n\n/**\n * Retrieves eligible campaigns based on the provided campaign map and context.\n *\n * @param settings - The settings model.\n * @param campaignMap - A map containing feature keys and corresponding campaigns.\n * @param context - The context model.\n * @param storageService - The storage service.\n * @returns A promise that resolves to an object containing eligible campaigns, campaigns with storage, and ineligible campaigns.\n */\nconst _getEligbleCampaigns = async (\n  settings: SettingsModel,\n  campaignMap: Map<string, any[]>,\n  context: ContextModel,\n  storageService: IStorageService,\n): Promise<any> => {\n  const eligibleCampaigns = [];\n  const eligibleCampaignsWithStorage = [];\n  const inEligibleCampaigns = [];\n  const campaignMapArray = Array.from<[string, CampaignModel[]]>(campaignMap);\n\n  // Iterate over the campaign map to determine eligible campaigns\n  for (const [featureKey, campaigns] of campaignMapArray) {\n    for (const campaign of campaigns) {\n      const storedData: Record<any, any> = await new StorageDecorator().getFeatureFromStorage(\n        featureKey,\n        context,\n        storageService,\n      );\n\n      // Check if campaign is stored in storage\n      if (storedData?.experimentVariationId) {\n        if (storedData.experimentKey && storedData.experimentKey === campaign.getKey()) {\n          const variation: VariationModel = getVariationFromCampaignKey(\n            settings,\n            storedData.experimentKey,\n            storedData.experimentVariationId,\n          );\n          if (variation) {\n            LogManager.Instance.info(\n              buildMessage(InfoLogMessagesEnum.MEG_CAMPAIGN_FOUND_IN_STORAGE, {\n                campaignKey: storedData.experimentKey,\n                userId: context.getId(),\n              }),\n            );\n\n            if (eligibleCampaignsWithStorage.findIndex((item) => item.key === campaign.getKey()) === -1) {\n              eligibleCampaignsWithStorage.push(campaign);\n            }\n            continue;\n          }\n        }\n      }\n\n      // Check if user is eligible for the campaign\n      if (\n        (await new CampaignDecisionService().getPreSegmentationDecision(\n          new CampaignModel().modelFromDictionary(campaign),\n          context,\n        )) &&\n        new CampaignDecisionService().isUserPartOfCampaign(context.getId(), campaign)\n      ) {\n        LogManager.Instance.info(\n          buildMessage(InfoLogMessagesEnum.MEG_CAMPAIGN_FOUND_IN_STORAGE, {\n            campaignKey: campaign.getKey(),\n            userId: context.getId(),\n          }),\n        );\n\n        eligibleCampaigns.push(campaign);\n        continue;\n      }\n\n      inEligibleCampaigns.push(campaign);\n    }\n  }\n\n  return Promise.resolve({\n    eligibleCampaigns,\n    eligibleCampaignsWithStorage,\n    inEligibleCampaigns,\n  });\n};\n\n/**\n * Evaluates the eligible campaigns and determines the winner campaign based on the provided settings, feature key, eligible campaigns, eligible campaigns with storage, group ID, and context.\n *\n * @param settings - The settings model.\n * @param featureKey - The key of the feature.\n * @param eligibleCampaigns - An array of eligible campaigns.\n * @param eligibleCampaignsWithStorage - An array of eligible campaigns with storage.\n * @param groupId - The ID of the group.\n * @param context - The context model.\n * @returns A promise that resolves to the winner campaign.\n */\nconst _findWinnerCampaignAmongEligibleCampaigns = async (\n  settings: SettingsModel,\n  featureKey: string,\n  eligibleCampaigns: any[],\n  eligibleCampaignsWithStorage: any[],\n  groupId: number,\n  context: ContextModel,\n): Promise<any> => {\n  // getCampaignIds from featureKey\n  let winnerCampaign = null;\n  const campaignIds = getCampaignIdsFromFeatureKey(settings, featureKey);\n  // get the winner from each group and store it in winnerFromEachGroup\n  const megAlgoNumber = !isUndefined(settings?.getGroups()[groupId]?.et)\n    ? settings.getGroups()[groupId].et\n    : Constants.RANDOM_ALGO;\n\n  // if eligibleCampaignsWithStorage has only one campaign, then that campaign is the winner\n  if (eligibleCampaignsWithStorage.length === 1) {\n    winnerCampaign = eligibleCampaignsWithStorage[0];\n    LogManager.Instance.info(\n      buildMessage(InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n        campaignKey: eligibleCampaignsWithStorage[0].getKey(),\n        groupId,\n        userId: context.getId(),\n        algo: '',\n      }),\n    );\n  } else if (eligibleCampaignsWithStorage.length > 1 && megAlgoNumber === Constants.RANDOM_ALGO) {\n    // if eligibleCampaignsWithStorage has more than one campaign and algo is random, then find the winner using random algo\n    winnerCampaign = _normalizeWeightsAndFindWinningCampaign(\n      eligibleCampaignsWithStorage,\n      context,\n      campaignIds,\n      groupId,\n    );\n  } else if (eligibleCampaignsWithStorage.length > 1) {\n    // if eligibleCampaignsWithStorage has more than one campaign and algo is not random, then find the winner using advanced algo\n    winnerCampaign = _getCampaignUsingAdvancedAlgo(\n      settings,\n      eligibleCampaignsWithStorage,\n      context,\n      campaignIds,\n      groupId,\n    );\n  }\n\n  if (eligibleCampaignsWithStorage.length === 0) {\n    if (eligibleCampaigns.length === 1) {\n      winnerCampaign = eligibleCampaigns[0];\n\n      LogManager.Instance.info(\n        buildMessage(InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n          campaignKey: eligibleCampaigns[0].getKey(),\n          groupId,\n          userId: context.getId(),\n          algo: '',\n        }),\n      );\n    } else if (eligibleCampaigns.length > 1 && megAlgoNumber === Constants.RANDOM_ALGO) {\n      winnerCampaign = _normalizeWeightsAndFindWinningCampaign(eligibleCampaigns, context, campaignIds, groupId);\n    } else if (eligibleCampaigns.length > 1) {\n      winnerCampaign = _getCampaignUsingAdvancedAlgo(settings, eligibleCampaigns, context, campaignIds, groupId);\n    }\n  }\n\n  return winnerCampaign;\n};\n\n/**\n * Normalizes the weights of shortlisted campaigns and determines the winning campaign using random allocation.\n *\n * @param shortlistedCampaigns - An array of shortlisted campaigns.\n * @param context - The context model.\n * @param calledCampaignIds - An array of campaign IDs that have been called.\n * @param groupId - The ID of the group.\n * @returns The winning campaign or null if none is found.\n */\nconst _normalizeWeightsAndFindWinningCampaign = (\n  shortlistedCampaigns: any[],\n  context: ContextModel,\n  calledCampaignIds: any[],\n  groupId: number,\n): any => {\n  // Normalize the weights of all the shortlisted campaigns\n  shortlistedCampaigns.forEach((campaign) => {\n    campaign.weight = Math.floor(100 / shortlistedCampaigns.length);\n  });\n\n  // make shortlistedCampaigns as array of VariationModel\n  shortlistedCampaigns = shortlistedCampaigns.map((campaign) => new VariationModel().modelFromDictionary(campaign));\n\n  // re-distribute the traffic for each camapign\n  setCampaignAllocation(shortlistedCampaigns);\n  const winnerCampaign = new CampaignDecisionService().getVariation(\n    shortlistedCampaigns,\n    new DecisionMaker().calculateBucketValue(getBucketingSeed(context.getId(), undefined, groupId)),\n  );\n\n  LogManager.Instance.info(\n    buildMessage(InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n      campaignKey: winnerCampaign.getKey(),\n      groupId,\n      userId: context.getId(),\n      algo: 'using random algorithm',\n    }),\n  );\n\n  if (winnerCampaign && calledCampaignIds.includes(winnerCampaign.getId())) {\n    return winnerCampaign;\n  }\n  return null;\n};\n\n/**\n * Advanced algorithm to find the winning campaign based on priority order and weighted random distribution.\n *\n * @param settings - The settings model.\n * @param shortlistedCampaigns - An array of shortlisted campaigns.\n * @param context - The context model.\n * @param calledCampaignIds - An array of campaign IDs that have been called.\n * @param groupId - The ID of the group.\n * @returns The winning campaign or null if none is found.\n */\nconst _getCampaignUsingAdvancedAlgo = (\n  settings: SettingsModel,\n  shortlistedCampaigns: any[],\n  context: ContextModel,\n  calledCampaignIds: any[],\n  groupId: number,\n) => {\n  let winnerCampaign = null;\n  let found = false; // flag to check whether winnerCampaign has been found or not and helps to break from the outer loop\n  const priorityOrder = !isUndefined(settings.getGroups()[groupId].p) ? settings.getGroups()[groupId].p : {};\n  const wt = !isUndefined(settings.getGroups()[groupId].wt) ? settings.getGroups()[groupId].wt : {};\n\n  for (let i = 0; i < priorityOrder.length; i++) {\n    for (let j = 0; j < shortlistedCampaigns.length; j++) {\n      if (shortlistedCampaigns[j].id === priorityOrder[i]) {\n        winnerCampaign = cloneObject(shortlistedCampaigns[j]);\n        found = true;\n        break;\n      }\n    }\n    if (found === true) break;\n  }\n\n  // If winnerCampaign not found through Priority, then go for weighted Random distribution and for that,\n  // Store the list of campaigns (participatingCampaigns) out of shortlistedCampaigns and their corresponding weights present in weightage distribution array (wt)\n  if (winnerCampaign === null) {\n    let participatingCampaignList = [];\n    // iterate over shortlisted campaigns and add weights from the weight array\n    for (let i = 0; i < shortlistedCampaigns.length; i++) {\n      const campaignId = shortlistedCampaigns[i].id;\n      if (!isUndefined(wt[campaignId])) {\n        const clonedCampaign = cloneObject(shortlistedCampaigns[i]);\n        clonedCampaign.weight = wt[campaignId];\n        participatingCampaignList.push(clonedCampaign);\n      }\n    }\n    /* Finding winner campaign using weighted Distibution :\n      1. Re-distribute the traffic by assigning range values for each camapign in particaptingCampaignList\n      2. Calculate bucket value for the given userId and groupId\n      3. Get the winnerCampaign by checking the Start and End Bucket Allocations of each campaign\n    */\n\n    // make participatingCampaignList as array of VariationModel\n    participatingCampaignList = participatingCampaignList.map((campaign) =>\n      new VariationModel().modelFromDictionary(campaign),\n    );\n    setCampaignAllocation(participatingCampaignList);\n    winnerCampaign = new CampaignDecisionService().getVariation(\n      participatingCampaignList,\n      new DecisionMaker().calculateBucketValue(getBucketingSeed(context.getId(), undefined, groupId)),\n    );\n  }\n  // WinnerCampaign should not be null, in case when winnerCampaign hasn't been found through PriorityOrder and\n  // also shortlistedCampaigns and wt array does not have a single campaign id in common\n  LogManager.Instance.info(\n    buildMessage(InfoLogMessagesEnum.MEG_WINNER_CAMPAIGN, {\n      campaignKey: winnerCampaign.key,\n      groupId,\n      userId: context.getId(),\n      algo: 'using advanced algorithm',\n    }),\n  );\n\n  if (calledCampaignIds.includes(winnerCampaign.id)) {\n    return winnerCampaign;\n  }\n  return null;\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getCurrentUnixTimestamp, getCurrentUnixTimestampInMillis, getRandomNumber } from './FunctionUtil';\nimport { getUUID } from './UuidUtil';\n\nimport { Constants } from '../constants';\nimport { HeadersEnum } from '../enums/HeadersEnum';\nimport { HttpMethodEnum } from '../enums/HttpMethodEnum';\nimport { UrlEnum } from '../enums/UrlEnum';\nimport { DebugLogMessagesEnum, ErrorLogMessagesEnum } from '../enums/log-messages';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { LogManager } from '../packages/logger';\nimport { NetworkManager, RequestModel, ResponseModel } from '../packages/network-layer';\nimport { SettingsService } from '../services/SettingsService';\nimport { dynamic } from '../types/Common';\nimport { isObject } from './DataTypeUtil';\nimport { buildMessage } from './LogMessageUtil';\nimport { UrlUtil } from './UrlUtil';\n\n/**\n * Constructs base properties for bulk operations.\n * @param {string} accountId - The account identifier.\n * @param {string} userId - The user identifier.\n * @returns {Record<string, dynamic>} - The base properties including session ID and UUID.\n */\nexport function getBasePropertiesForBulk(accountId: string, userId: string): Record<string, dynamic> {\n  const path: Record<string, dynamic> = {\n    sId: getCurrentUnixTimestamp(), // Session ID based on current Unix timestamp\n    u: getUUID(userId, accountId), // UUID generated based on user and account ID\n  };\n  return path;\n}\n\n/**\n * Constructs the settings path with API key and account ID.\n * @param {string} sdkKey - The API key.\n * @param {any} accountId - The account identifier.\n * @returns {Record<string, dynamic>} - The settings path including API key, random number, and account ID.\n */\nexport function getSettingsPath(sdkKey: string, accountId: string | number): Record<string, dynamic> {\n  const path: Record<string, dynamic> = {\n    i: `${sdkKey}`, // Inject API key\n    r: Math.random(), // Random number for cache busting\n    a: accountId, // Account ID\n  };\n  return path;\n}\n\n/**\n * Constructs the tracking path for an event.\n * @param {string} event - The event type.\n * @param {string} accountId - The account identifier.\n * @param {string} userId - The user identifier.\n * @returns {Record<string, dynamic>} - The tracking path for the event.\n */\nexport function getTrackEventPath(event: string, accountId: string, userId: string): Record<string, dynamic> {\n  const path: Record<string, dynamic> = {\n    event_type: event, // Type of the event\n    account_id: accountId, // Account ID\n    uId: userId, // User ID\n    u: getUUID(userId, accountId), // UUID generated for the user\n    sdk: Constants.SDK_NAME, // SDK name constant\n    'sdk-v': Constants.SDK_VERSION, // SDK version\n    random: getRandomNumber(), // Random number for uniqueness\n    ap: Constants.PLATFORM, // Application platform\n    sId: getCurrentUnixTimestamp(), // Session ID\n    ed: JSON.stringify({ p: 'server' }), // Additional encoded data\n  };\n\n  return path;\n}\n\n/**\n * Constructs query parameters for event batching.\n * @param {string} accountId - The account identifier.\n * @returns {Record<string, dynamic>} - The query parameters for event batching.\n */\nexport function getEventBatchingQueryParams(accountId: string): Record<string, dynamic> {\n  const path: Record<string, dynamic> = {\n    a: accountId, // Account ID\n    sd: Constants.SDK_NAME, // SDK name\n    sv: Constants.SDK_VERSION, // SDK version\n  };\n\n  return path;\n}\n\n/**\n * Builds generic properties for different tracking calls required by VWO servers.\n * @param {Object} configObj\n * @param {String} eventName\n * @returns properties\n */\nexport function getEventsBaseProperties(\n  setting: SettingsModel,\n  eventName: string,\n  visitorUserAgent: string = '',\n  ipAddress: string = '',\n): Record<string, any> {\n  const sdkKey = setting.getSdkkey();\n\n  const properties = Object.assign({\n    en: eventName,\n    a: setting.getAccountId(),\n    env: sdkKey,\n    eTime: getCurrentUnixTimestampInMillis(),\n    random: getRandomNumber(),\n    p: 'FS',\n    visitor_ua: visitorUserAgent,\n    visitor_ip: ipAddress,\n  });\n\n  properties.url = Constants.HTTPS_PROTOCOL + UrlUtil.getBaseUrl() + UrlEnum.EVENTS;\n  return properties;\n}\n\n/**\n * Builds generic payload required by all the different tracking calls.\n * @param {Object} settings   settings file\n * @param {String} userId     user id\n * @param {String} eventName  event name\n * @returns properties\n */\nexport function _getEventBasePayload(\n  settings: SettingsModel,\n  userId: string | number,\n  eventName: string,\n  visitorUserAgent = '',\n  ipAddress = '',\n): Record<string, any> {\n  const uuid = getUUID(userId.toString(), settings.getAccountId());\n  const sdkKey = settings.getSdkkey();\n\n  const props: {\n    vwo_sdkName: string;\n    vwo_sdkVersion: string;\n    vwo_envKey: string;\n    id?: string | number;\n    variation?: string | number;\n    isFirst?: number;\n    isCustomEvent?: boolean;\n  } = {\n    vwo_sdkName: Constants.SDK_NAME,\n    vwo_sdkVersion: Constants.SDK_VERSION,\n    vwo_envKey: sdkKey,\n  };\n\n  const properties = {\n    d: {\n      msgId: `${uuid}-${getCurrentUnixTimestampInMillis()}`,\n      visId: uuid,\n      sessionId: getCurrentUnixTimestamp(),\n      visitor_ua: visitorUserAgent,\n      visitor_ip: ipAddress,\n      event: {\n        props: props,\n        name: eventName,\n        time: getCurrentUnixTimestampInMillis(),\n      },\n      visitor: {\n        props: {\n          vwo_fs_environment: sdkKey,\n        },\n      },\n    },\n  };\n\n  return properties;\n}\n\n/**\n * Builds payload to track the visitor.\n * @param {Object} configObj\n * @param {String} userId\n * @param {String} eventName\n * @param {String} campaignId\n * @param {Number} variationId\n * @returns track-user payload\n */\nexport function getTrackUserPayloadData(\n  settings: SettingsModel,\n  userId: string | number,\n  eventName: string,\n  campaignId: number,\n  variationId: number,\n  visitorUserAgent: string = '',\n  ipAddress: string = '',\n): Record<string, any> {\n  const properties = _getEventBasePayload(settings, userId, eventName, visitorUserAgent, ipAddress);\n\n  properties.d.event.props.id = campaignId;\n  properties.d.event.props.variation = variationId;\n  properties.d.event.props.isFirst = 1;\n\n  LogManager.Instance.debug(\n    buildMessage(DebugLogMessagesEnum.IMPRESSION_FOR_TRACK_USER, {\n      accountId: settings.getAccountId(),\n      userId,\n      campaignId,\n    }),\n  );\n\n  return properties;\n}\n\n/**\n * Constructs the payload data for tracking goals with custom event properties.\n * @param {any} settings - Configuration settings.\n * @param {any} userId - User identifier.\n * @param {string} eventName - Name of the event.\n * @param {any} eventProperties - Custom properties for the event.\n * @param {string} [visitorUserAgent=''] - Visitor's user agent.\n * @param {string} [ipAddress=''] - Visitor's IP address.\n * @returns {any} - The constructed payload data.\n */\nexport function getTrackGoalPayloadData(\n  settings: SettingsModel,\n  userId: string | number,\n  eventName: string,\n  eventProperties: Record<string, any>,\n  visitorUserAgent: string = '',\n  ipAddress: string = '',\n): Record<string, any> {\n  const properties = _getEventBasePayload(settings, userId, eventName, visitorUserAgent, ipAddress);\n  properties.d.event.props.isCustomEvent = true; // Mark as a custom event\n  properties.d.event.props.variation = 1; // Temporary value for variation\n  properties.d.event.props.id = 1; // Temporary value for ID\n\n  // Add custom event properties if provided\n  if (eventProperties && isObject(eventProperties) && Object.keys(eventProperties).length > 0) {\n    for (const prop in eventProperties) {\n      properties.d.event.props[prop] = eventProperties[prop];\n    }\n  }\n\n  LogManager.Instance.debug(\n    buildMessage(DebugLogMessagesEnum.IMPRESSION_FOR_TRACK_USER, {\n      eventName,\n      accountId: settings.getAccountId(),\n      userId,\n    }),\n  );\n\n  return properties;\n}\n\n/**\n * Constructs the payload data for syncing visitor attributes.\n * @param {any} settings - Configuration settings.\n * @param {any} userId - User identifier.\n * @param {string} eventName - Name of the event.\n * @param {any} attributeKey - Key of the attribute to sync.\n * @param {any} attributeValue - Value of the attribute.\n * @param {string} [visitorUserAgent=''] - Visitor's user agent.\n * @param {string} [ipAddress=''] - Visitor's IP address.\n * @returns {any} - The constructed payload data.\n */\nexport function getAttributePayloadData(\n  settings: SettingsModel,\n  userId: string | number,\n  eventName: string,\n  attributeKey: string,\n  attributeValue: dynamic,\n  visitorUserAgent: string = '',\n  ipAddress: string = '',\n): Record<string, any> {\n  const properties = _getEventBasePayload(settings, userId, eventName, visitorUserAgent, ipAddress);\n\n  properties.d.event.props.isCustomEvent = true; // Mark as a custom event\n  properties.d.event.props[Constants.VWO_FS_ENVIRONMENT] = settings.getSdkkey(); // Set environment key\n  properties.d.visitor.props[attributeKey] = attributeValue; // Set attribute value\n\n  LogManager.Instance.debug(\n    buildMessage(DebugLogMessagesEnum.IMPRESSION_FOR_TRACK_USER, {\n      eventName,\n      accountId: settings.getAccountId(),\n      userId,\n    }),\n  );\n\n  return properties;\n}\n\n/**\n * Sends a POST API request with the specified properties and payload.\n * @param {any} properties - Properties for the request.\n * @param {any} payload - Payload for the request.\n */\nexport async function sendPostApiRequest(properties: any, payload: any): Promise<void> {\n  NetworkManager.Instance.attachClient();\n\n  const headers: Record<string, string> = {};\n\n  const userAgent = payload.d.visitor_ua; // Extract user agent from payload\n  const ipAddress = payload.d.visitor_ip; // Extract IP address from payload\n\n  // Set headers if available\n  if (userAgent) headers[HeadersEnum.USER_AGENT] = userAgent;\n  if (ipAddress) headers[HeadersEnum.IP] = ipAddress;\n\n  const request: RequestModel = new RequestModel(\n    UrlUtil.getBaseUrl(),\n    HttpMethodEnum.POST,\n    UrlEnum.EVENTS,\n    properties,\n    payload,\n    headers,\n    SettingsService.Instance.protocol,\n    SettingsService.Instance.port,\n  );\n\n  await NetworkManager.Instance.post(request).catch((err: ResponseModel) => {\n    LogManager.Instance.error(\n      buildMessage(ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n        method: HttpMethodEnum.POST,\n        err: isObject(err) ? JSON.stringify(err) : err,\n      }),\n    );\n  });\n}\n\n/**\n * Sends a GET API request to the specified endpoint with the given properties.\n * @param {any} properties - Properties for the request.\n * @param {any} endpoint - Endpoint for the GET request.\n * @returns {Promise<any>} - The response from the GET request.\n */\nexport async function sendGetApiRequest(properties: any, endpoint: any): Promise<any> {\n  NetworkManager.Instance.attachClient();\n  const request: RequestModel = new RequestModel(\n    UrlUtil.getBaseUrl(),\n    HttpMethodEnum.GET,\n    endpoint,\n    properties,\n    null,\n    null,\n    SettingsService.Instance.protocol,\n    SettingsService.Instance.port,\n  );\n  try {\n    const response: ResponseModel = await NetworkManager.Instance.get(request);\n    return response; // Return the response model\n  } catch (err) {\n    LogManager.Instance.error(\n      buildMessage(ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n        method: HttpMethodEnum.GET,\n        err: isObject(err) ? JSON.stringify(err) : err,\n      }),\n    );\n    return null;\n  }\n}\n\n// Flag to determine if the SDK should wait for a network response.\nlet shouldWaitForTrackingCalls = false;\n\n/**\n * Checks if the SDK should wait for a network response.\n * @returns {boolean} - True if the SDK should wait for a network response, false otherwise.\n */\nexport function getShouldWaitForTrackingCalls(): boolean {\n  return shouldWaitForTrackingCalls;\n}\n\n/**\n * Sets the value to determine if the SDK should wait for a network response.\n * @param value - The value to set.\n */\nexport function setShouldWaitForTrackingCalls(value: boolean): void {\n  shouldWaitForTrackingCalls = value;\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { dynamic } from '../types/Common';\n\n/**\n * Creates a Deferred object with properties for promise, resolve, and reject.\n * This allows manual control over the resolution and rejection of a promise.\n * @returns {Deferred} The Deferred object with promise, resolve, and reject methods.\n */\nexport function Deferred(): void {\n  // Create a new Promise and attach resolve and reject methods to the Deferred object\n  this.promise = new Promise((resolve: dynamic, reject: dynamic) => {\n    this.resolve = resolve; // Method to resolve the promise\n    this.reject = reject; // Method to reject the promise\n  });\n\n  return this; // Return the Deferred object with attached methods\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CampaignModel } from '../models/campaign/CampaignModel';\nimport { FeatureModel } from '../models/campaign/FeatureModel';\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { ContextModel } from '../models/user/ContextModel';\nimport { IStorageService } from '../services/StorageService';\nimport { isObject } from './DataTypeUtil';\nimport { checkWhitelistingAndPreSeg } from './DecisionUtil';\nimport { getShouldWaitForTrackingCalls } from './NetworkUtil';\nimport { createAndSendImpressionForVariationShown } from './ImpressionUtil';\n\n/**\n * Evaluates the rules for a given campaign and feature based on the provided context.\n * This function checks for whitelisting and pre-segmentation conditions, and if applicable,\n * sends an impression for the variation shown.\n *\n * @param {SettingsModel} settings - The settings configuration for the evaluation.\n * @param {FeatureModel} feature - The feature being evaluated.\n * @param {CampaignModel} campaign - The campaign associated with the feature.\n * @param {ContextModel} context - The user context for evaluation.\n * @param {Map<string, any>} evaluatedFeatureMap - A map of evaluated features.\n * @param {Map<number, number>} megGroupWinnerCampaigns - A map of MEG group winner campaigns.\n * @param {StorageService} storageService - The storage service for persistence.\n * @param {any} decision - The decision object that will be updated based on the evaluation.\n * @returns {Promise<[boolean, any]>} A promise that resolves to a tuple containing the result of the pre-segmentation\n * and the whitelisted object, if any.\n */\nexport const evaluateRule = async (\n  settings: SettingsModel,\n  feature: FeatureModel,\n  campaign: CampaignModel,\n  context: ContextModel,\n  evaluatedFeatureMap: Map<string, unknown>,\n  megGroupWinnerCampaigns: Map<number, number>,\n  storageService: IStorageService,\n  decision: any,\n): Promise<Record<string, any>> => {\n  // Perform whitelisting and pre-segmentation checks\n  const [preSegmentationResult, whitelistedObject] = await checkWhitelistingAndPreSeg(\n    settings,\n    feature,\n    campaign,\n    context,\n    evaluatedFeatureMap,\n    megGroupWinnerCampaigns,\n    storageService,\n    decision,\n  );\n\n  // If pre-segmentation is successful and a whitelisted object exists, proceed to send an impression\n  if (preSegmentationResult && isObject(whitelistedObject) && Object.keys(whitelistedObject).length > 0) {\n    // Update the decision object with campaign and variation details\n    Object.assign(decision, {\n      experimentId: campaign.getId(),\n      experimentKey: campaign.getKey(),\n      experimentVariationId: whitelistedObject.variationId,\n    });\n\n    // Send an impression for the variation shown\n    if (getShouldWaitForTrackingCalls()) {\n      await createAndSendImpressionForVariationShown(\n        settings,\n        campaign.getId(),\n        whitelistedObject.variation.id,\n        context,\n      );\n    } else {\n      createAndSendImpressionForVariationShown(settings, campaign.getId(), whitelistedObject.variation.id, context);\n    }\n  }\n\n  // Return the results of the evaluation\n  return { preSegmentationResult, whitelistedObject, updatedDecision: decision };\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SettingsModel } from '../models/settings/SettingsModel';\nimport { setVariationAllocation } from './CampaignUtil';\nimport { addLinkedCampaignsToSettings } from './FunctionUtil';\nimport { addIsGatewayServiceRequiredFlag } from './GatewayServiceUtil';\n\nexport function setSettingsAndAddCampaignsToRules(settings, vwoClientInstance) {\n  vwoClientInstance.settings = new SettingsModel(settings);\n  vwoClientInstance.originalSettings = settings;\n  // Optimize loop by avoiding multiple calls to `getCampaigns()`\n  const campaigns = vwoClientInstance.settings.getCampaigns();\n  campaigns.forEach((campaign, index) => {\n    setVariationAllocation(campaign);\n    campaigns[index] = campaign;\n  });\n  addLinkedCampaignsToSettings(vwoClientInstance.settings);\n  addIsGatewayServiceRequiredFlag(vwoClientInstance.settings);\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SettingsService } from '../services/SettingsService';\nimport { isString } from './DataTypeUtil';\n\ninterface IUrlUtil {\n  collectionPrefix?: string;\n  init({ collectionPrefix }?: { collectionPrefix?: string }): IUrlUtil;\n  getBaseUrl(): string;\n}\n\nexport const UrlUtil: IUrlUtil = {\n  /**\n   * Initializes the UrlUtil with optional collectionPrefix and gatewayServiceUrl.\n   * If provided, these values are set after validation.\n   * @param {string} [collectionPrefix] - Optional prefix for URL collections.\n   * @returns {IUrlUtil} The instance of UrlUtil with updated properties.\n   */\n  init: ({ collectionPrefix }: { collectionPrefix?: string } = {}) => {\n    // Set collectionPrefix if it is a valid string\n    if (collectionPrefix && isString(collectionPrefix)) {\n      UrlUtil.collectionPrefix = collectionPrefix;\n    }\n\n    return UrlUtil;\n  },\n\n  /**\n   * Retrieves the base URL.\n   * If gatewayServiceUrl is set, it returns that; otherwise, it constructs the URL using baseUrl and collectionPrefix.\n   * @returns {string} The base URL.\n   */\n  getBaseUrl: () => {\n    const baseUrl: string = SettingsService.Instance.hostname;\n\n    if (SettingsService.Instance.isGatewayServiceProvided) {\n      return baseUrl;\n    }\n\n    // Construct URL with collectionPrefix if it exists\n    if (UrlUtil.collectionPrefix) {\n      return `${baseUrl}/${UrlUtil.collectionPrefix}`;\n    }\n\n    // Return the default baseUrl if no specific URL components are set\n    return baseUrl;\n  },\n};\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SEED_URL } from '../constants/Url';\nimport { v4 as uuidv4 } from 'uuid';\nimport { v5 as uuidv5 } from 'uuid';\n\n/**\n * Generates a random UUID based on an API key.\n * @param sdkKey The API key used to generate a namespace for the UUID.\n * @returns A random UUID string.\n */\nexport function getRandomUUID(sdkKey: string): string {\n  // Generate a namespace based on the API key using DNS namespace\n  const namespace = uuidv5(sdkKey, uuidv5.DNS);\n  // Generate a random UUID using the namespace derived from the API key\n  const randomUUID = uuidv5(uuidv4(), namespace);\n\n  return randomUUID;\n}\n\n/**\n * Generates a UUID for a user based on their userId and accountId.\n * @param userId The user's ID.\n * @param accountId The account ID associated with the user.\n * @returns A UUID string formatted without dashes and in uppercase.\n */\nexport function getUUID(userId: string, accountId: string): string {\n  const VWO_NAMESPACE = uuidv5(SEED_URL, uuidv5.URL);\n  // Convert userId and accountId to string to ensure proper type\n  userId = String(userId);\n  accountId = String(accountId);\n  // Generate a namespace UUID based on the accountId\n  const userIdNamespace = generateUUID(accountId, VWO_NAMESPACE);\n  // Generate a UUID based on the userId and the previously generated namespace\n  const uuidForUserIdAccountId = generateUUID(userId, userIdNamespace);\n\n  // Remove all dashes from the UUID and convert it to uppercase\n  const desiredUuid = uuidForUserIdAccountId?.replace(/-/gi, '').toUpperCase();\n\n  return desiredUuid;\n}\n\n/**\n * Helper function to generate a UUID v5 based on a name and a namespace.\n * @param name The name from which to generate the UUID.\n * @param namespace The namespace used to generate the UUID.\n * @returns A UUID string or undefined if inputs are invalid.\n */\nexport function generateUUID(name: string, namespace: string) {\n  // Check for valid input to prevent errors\n  if (!name || !namespace) {\n    return;\n  }\n\n  // Generate and return the UUID v5\n  return uuidv5(name, namespace);\n}\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HttpMethodEnum } from '../enums/HttpMethodEnum';\nimport { LogManager } from '../packages/logger';\nimport { buildMessage } from './LogMessageUtil';\nimport { ErrorLogMessagesEnum } from '../enums/log-messages';\n\nconst noop = () => {};\n\nexport function sendGetCall(options) {\n  sendRequest(HttpMethodEnum.GET, options);\n}\n\nexport function sendPostCall(options) {\n  sendRequest(HttpMethodEnum.POST, options);\n}\n\nfunction sendRequest(method, options) {\n  const { networkOptions, successCallback = noop, errorCallback = noop } = options;\n\n  let url = `${networkOptions.scheme}://${networkOptions.hostname}${networkOptions.path}`;\n  if (networkOptions.port) {\n    url = `${networkOptions.scheme}://${networkOptions.hostname}:${networkOptions.port}${networkOptions.path}`;\n  }\n  const body = networkOptions.body;\n  const customHeaders = networkOptions.headers || {};\n  const timeout = networkOptions.timeout;\n\n  const xhr = new XMLHttpRequest();\n\n  if (timeout) {\n    xhr.timeout = timeout;\n  }\n\n  xhr.onload = function () {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      const response = xhr.responseText;\n\n      if (method === HttpMethodEnum.GET) {\n        const parsedResponse = JSON.parse(response);\n        successCallback(parsedResponse);\n      } else {\n        successCallback(response);\n      }\n    } else {\n      errorCallback(xhr.statusText);\n    }\n  };\n\n  // Set up a callback function that is called if the request fails\n  xhr.onerror = function () {\n    // An error occurred during the transaction\n    LogManager.Instance.error(\n      buildMessage(ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n        method: HttpMethodEnum.POST,\n        err: `${xhr.statusText}, status: ${xhr.status}`,\n      }),\n    );\n    errorCallback(xhr.statusText);\n  };\n\n  // Set up a callback function that is called if the request times out\n  if (timeout) {\n    xhr.ontimeout = function () {\n      // The request timed out\n      LogManager.Instance.error(\n        buildMessage(ErrorLogMessagesEnum.NETWORK_CALL_FAILED, {\n          method: HttpMethodEnum.POST,\n          err: `Request timed out`,\n        }),\n      );\n    };\n  }\n\n  xhr.open(method, url, true);\n\n  for (const headerName in customHeaders) {\n    if (headerName in customHeaders) {\n      // Skip the Content-Type header\n      // Request header field content-type is not allowed by Access-Control-Allow-Headers\n      if (headerName !== 'Content-Type' && headerName !== 'Content-Length') {\n        xhr.setRequestHeader(headerName, customHeaders[headerName]);\n      }\n    }\n  }\n\n  if (method === HttpMethodEnum.POST) {\n    xhr.send(JSON.stringify(body));\n  } else if (method === HttpMethodEnum.GET) {\n    xhr.send();\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function get() {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function get() {\n    return _parse.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function get() {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function get() {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function get() {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function get() {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function get() {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function get() {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function get() {\n    return _version.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar _default = {\n  randomUUID\n};\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.unsafeStringify = unsafeStringify;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = require(\"./stringify.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.unsafeStringify)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.URL = exports.DNS = void 0;\nexports.default = v35;\n\nvar _stringify = require(\"./stringify.js\");\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _native = _interopRequireDefault(require(\"./native.js\"));\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = require(\"./stringify.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  if (_native.default.randomUUID && !buf && !options) {\n    return _native.default.randomUUID();\n  }\n\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.unsafeStringify)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\nvar _default = version;\nexports.default = _default;","module.exports = {\n  debugMessages: require('./src/debug-messages.json'),\n  infoMessages: require('./src/info-messages.json'),\n  warnMessages: require('./src/warn-messages.json'),\n  errorMessages: require('./src/error-messages.json'),\n  traceMessages: require('./src/trace-messages.json')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];\n    };\n  }\n\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\"\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction* run(value, struct, options = {}) {\n  const {\n    path = [],\n    branch = [value],\n    coerce = false,\n    mask = false\n  } = options;\n  const ctx = {\n    path,\n    branch\n  };\n\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n\n    if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let valid = true;\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false;\n    yield [failure, undefined];\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask\n    });\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false;\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          value[k] = v;\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value, ctx)) {\n      valid = false;\n      yield [failure, undefined];\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value];\n  }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction create(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction mask(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction validate(value, struct, options = {}) {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\n\nfunction assign(...Structs) {\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nfunction deprecated(struct, log) {\n  return new Struct({ ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n\n    *entries(value, ctx) {\n      var _struct;\n\n      (_struct = struct) != null ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = { ...schema\n  };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? { ...struct.schema\n  } : { ...struct\n  };\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n\n    validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n\n    coercer(value) {\n      return isObject(value) ? { ...value\n      } : value;\n    }\n\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\nfunction tuple(Elements) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value), ...failures];\n    }\n\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, coercer) {\n  return new Struct({ ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction defaulted(struct, fallback, options = {}) {\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x\n      };\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nfunction empty(struct) {\n  const expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', value => {\n    if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return size === 0 || expected + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nfunction max(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nfunction min(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nfunction size(struct, min, max = min) {\n  const expected = \"Expected a \" + struct.type;\n  const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nfunction refine(struct, name, refiner) {\n  return new Struct({ ...struct,\n\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure,\n          refinement: name\n        };\n      }\n    }\n\n  });\n}\n\nexports.Struct = Struct;\nexports.StructError = StructError;\nexports.any = any;\nexports.array = array;\nexports.assert = assert;\nexports.assign = assign;\nexports.boolean = boolean;\nexports.coerce = coerce;\nexports.create = create;\nexports.date = date;\nexports.defaulted = defaulted;\nexports.define = define;\nexports.deprecated = deprecated;\nexports.dynamic = dynamic;\nexports.empty = empty;\nexports.enums = enums;\nexports.func = func;\nexports.instance = instance;\nexports.integer = integer;\nexports.intersection = intersection;\nexports.is = is;\nexports.lazy = lazy;\nexports.literal = literal;\nexports.map = map;\nexports.mask = mask;\nexports.max = max;\nexports.min = min;\nexports.never = never;\nexports.nullable = nullable;\nexports.number = number;\nexports.object = object;\nexports.omit = omit;\nexports.optional = optional;\nexports.partial = partial;\nexports.pattern = pattern;\nexports.pick = pick;\nexports.record = record;\nexports.refine = refine;\nexports.regexp = regexp;\nexports.set = set;\nexports.size = size;\nexports.string = string;\nexports.struct = struct;\nexports.trimmed = trimmed;\nexports.tuple = tuple;\nexports.type = type;\nexports.union = union;\nexports.unknown = unknown;\nexports.validate = validate;\n//# sourceMappingURL=index.cjs.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright 2024 Wingify Software Pvt. Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LogLevelEnum } from './packages/logger/enums/LogLevelEnum';\nimport { Connector } from './packages/storage/Connector';\n\nexport { LogLevelEnum, Connector as StorageConnector };\nexport { init, onInit } from './VWO';\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}