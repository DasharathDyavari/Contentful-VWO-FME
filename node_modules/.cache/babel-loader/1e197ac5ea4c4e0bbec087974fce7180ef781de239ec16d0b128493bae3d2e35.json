{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar immer_1 = __importDefault(require(\"immer\"));\nvar react_1 = require(\"react\");\nfunction useMethods(methodsOrOptions, initialState, initializer) {\n  var _a = react_1.useMemo(function () {\n      var methods;\n      var patchListener;\n      if (typeof methodsOrOptions === 'function') {\n        methods = methodsOrOptions;\n      } else {\n        methods = methodsOrOptions.methods;\n        patchListener = methodsOrOptions.patchListener;\n      }\n      return [function (state, action) {\n        return immer_1.default(state, function (draft) {\n          var _a;\n          return (_a = methods(draft))[action.type].apply(_a, action.payload);\n        }, patchListener);\n      }, methods];\n    }, [methodsOrOptions]),\n    reducer = _a[0],\n    methodsFactory = _a[1];\n  var _b = react_1.useReducer(reducer, initialState, initializer),\n    state = _b[0],\n    dispatch = _b[1];\n  var callbacks = react_1.useMemo(function () {\n    var actionTypes = Object.keys(methodsFactory(state));\n    return actionTypes.reduce(function (accum, type) {\n      accum[type] = function () {\n        var payload = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          payload[_i] = arguments[_i];\n        }\n        return dispatch({\n          type: type,\n          payload: payload\n        });\n      };\n      return accum;\n    }, {});\n  }, []);\n  return [state, callbacks];\n}\nexports.default = useMethods;","map":{"version":3,"names":["immer_1","__importDefault","require","react_1","useMethods","methodsOrOptions","initialState","initializer","_a","useMemo","reducer","methodsFactory","_b","useReducer","state","dispatch","callbacks","actionTypes","Object","keys","reduce","accum","type","payload","_i","arguments","length","exports","default"],"sources":["/Users/dasharathdyavari/Desktop/vwo-fme/node_modules/use-methods/src/index.ts"],"sourcesContent":["import produce, { PatchListener } from 'immer';\nimport { Reducer, useMemo, useReducer } from 'react';\n\nexport type StateAndCallbacksFor<M extends MethodsOrOptions> = [StateFor<M>, CallbacksFor<M>];\n\nexport type StateFor<M extends MethodsOrOptions> = M extends MethodsOrOptions<infer S, any>\n  ? S\n  : never;\n\nexport type CallbacksFor<M extends MethodsOrOptions> = M extends MethodsOrOptions<any, infer R>\n  ? {\n      [T in ActionUnion<R>['type']]: (\n        ...payload: ActionByType<ActionUnion<R>, T>['payload']\n      ) => void\n    }\n  : never;\n\nexport type Methods<S = any, R extends MethodRecordBase<S> = any> = (state: S) => R;\n\nexport type Options<S = any, R extends MethodRecordBase<S> = any> = {\n  methods: Methods<S, R>;\n  patchListener?: PatchListener;\n};\n\nexport type MethodsOrOptions<S = any, R extends MethodRecordBase<S> = any> =\n  | Methods<S, R>\n  | Options<S, R>;\n\nexport type MethodRecordBase<S = any> = Record<\n  string,\n  (...args: any[]) => S extends object ? S | void : S\n>;\n\nexport type ActionUnion<R extends MethodRecordBase> = {\n  [T in keyof R]: { type: T; payload: Parameters<R[T]> }\n}[keyof R];\n\nexport type ActionByType<A, T> = A extends { type: infer T2 } ? (T extends T2 ? A : never) : never;\n\nexport default function useMethods<S, R extends MethodRecordBase<S>>(\n  methodsOrOptions: MethodsOrOptions<S, R>,\n  initialState: S,\n): StateAndCallbacksFor<MethodsOrOptions<S, R>>;\nexport default function useMethods<S, R extends MethodRecordBase<S>, I>(\n  methodsOrOptions: MethodsOrOptions<S, R>,\n  initializerArg: I,\n  initializer: (arg: I) => S,\n): StateAndCallbacksFor<MethodsOrOptions<S, R>>;\nexport default function useMethods<S, R extends MethodRecordBase<S>>(\n  methodsOrOptions: MethodsOrOptions<S, R>,\n  initialState: any,\n  initializer?: any,\n): StateAndCallbacksFor<MethodsOrOptions<S, R>> {\n  const [reducer, methodsFactory] = useMemo<[Reducer<S, ActionUnion<R>>, Methods<S, R>]>(() => {\n    let methods: Methods<S, R>;\n    let patchListener: PatchListener | undefined;\n    if (typeof methodsOrOptions === 'function') {\n      methods = methodsOrOptions;\n    } else {\n      methods = methodsOrOptions.methods;\n      patchListener = methodsOrOptions.patchListener;\n    }\n    return [\n      (state: S, action: ActionUnion<R>) => {\n        return (produce as any)(\n          state,\n          (draft: S) => methods(draft)[action.type](...action.payload),\n          patchListener,\n        );\n      },\n      methods,\n    ];\n  }, [methodsOrOptions]);\n  const [state, dispatch] = useReducer(reducer, initialState, initializer);\n  const callbacks = useMemo(() => {\n    const actionTypes: ActionUnion<R>['type'][] = Object.keys(methodsFactory(state));\n    return actionTypes.reduce(\n      (accum, type) => {\n        accum[type] = (...payload) => dispatch({ type, payload } as ActionUnion<R>);\n        return accum;\n      },\n      {} as CallbacksFor<typeof methodsFactory>,\n    );\n  }, []);\n  return [state, callbacks];\n}\n"],"mappings":";;;;;;;;;;AAAA,IAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AA+CA,SAAwBE,UAAUA,CAChCC,gBAAwC,EACxCC,YAAiB,EACjBC,WAAiB;EAEX,IAAAC,EAAA,GAAAL,OAAA,CAAAM,OAAA;;;;;;;;;;;;;;;0BAmBgB;IAnBfC,OAAA,GAAAF,EAAA,GAAO;IAAEG,cAAA,GAAAH,EAAA,GAmBM;EAChB,IAAAI,EAAA,GAAAT,OAAA,CAAAU,UAAA,CAAAH,OAAA,EAAAJ,YAAA,EAAAC,WAAA,CAAkE;IAAjEO,KAAA,GAAAF,EAAA,GAAK;IAAEG,QAAA,GAAAH,EAAA,GAA0D;EACxE,IAAMI,SAAS,GAAGb,OAAA,CAAAM,OAAO,CAAC;IACxB,IAAMQ,WAAW,GAA6BC,MAAM,CAACC,IAAI,CAACR,cAAc,CAACG,KAAK,CAAC,CAAC;IAChF,OAAOG,WAAW,CAACG,MAAM,CACvB,UAACC,KAAK,EAAEC,IAAI;MACVD,KAAK,CAACC,IAAI,CAAC,GAAG;QAAC,IAAAC,OAAA;aAAA,IAAAC,EAAA,IAAU,EAAVA,EAAA,GAAAC,SAAA,CAAAC,MAAU,EAAVF,EAAA,EAAU;UAAVD,OAAA,CAAAC,EAAA,IAAAC,SAAA,CAAAD,EAAA;;QAAe,OAAAT,QAAQ,CAAC;UAAEO,IAAI,EAAAA,IAAA;UAAEC,OAAO,EAAAA;QAAA,CAAoB,CAAC;MAA7C,CAA6C;MAC3E,OAAOF,KAAK;IACd,CAAC,EACD,EAAyC,CAC1C;EACH,CAAC,EAAE,EAAE,CAAC;EACN,OAAO,CAACP,KAAK,EAAEE,SAAS,CAAC;AAC3B;AArCAW,OAAA,CAAAC,OAAA,GAAAxB,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}